(function(){
	var fileData=[]
	fileData.push(function(){return {
	"stat": {
		"mtime": "2019-03-06T07:31:43.268Z",
		"mtimeMs": 1551857503267.6765,
		"atime": "2019-03-06T07:31:43.304Z",
		"atimeMs": 1551857503303.6772,
		"isdirectory": true
	},
	"filename": ""
}})
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.257Z",
		"atimeMs": 1551857503257,
		"isfile": true
	},
	"filename": "README.md",
	"content": "```\n      @@@@@@@                @@@@  @@@@@\n     @@@@@@@@@@              @@@   @@@                                           {\n    @@@@     @@              @@@   @@@                                        }   }   {\n   @@@@          @@@@@@@    @@@   @@@     @@@@@@    @@@@@@                   {   {  }  }\n  @@@@          @@@   @@  @@@@@  @@@@@@  @@@   @@  @@@@  @@                   }   }{  {\n  @@@@         @@@@   @@   @@@    @@@   @@@   @@@ @@@   @@@                  {  }{  }  }\n  @@@@        @@@@    @@   @@@    @@@   @@@@@@@@  @@@@@@@@                  { }{ }{  { }\n  @@@@@       @@@@   @@    @@@    @@@   @@@       @@@                     {  { } { } { }  }\n   @@@@@@@@@@ @@@@@@@@    @@@    @@@    @@@@@@@@  @@@@@@@@                 { }   { }   { }\n      @@@@@               @@@    @@@      @@@@@     @@@@@           @@@@@@   { }   { }    @@@@@@@\n                         @@@    @@@                                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n      @@@@@@            @@@    @@@                                @@ @@@@@@@@@@@@@@@@@@@@@@@@@@\n   @@@@    @@          @@@   @@@@                                @@   @@@@@@@@@@@@@@@@@@@@@@@@\n   @@@@   @@@                       @@                  @@@@     @@@   @@@@@@@@@@@@@@@@@@@@@\n   @@@@@          @@@@@   @@  @@   @@@     @@@@@@@     @@@@@      @@@    @@@@@@@@@@@@@@@@@@\n     @@@@@      @@@  @@@ @@@@@@@@         @@@@  @@@@  @@@@@@@       @@@   @@@@@@@@@@@@@@@@\n       @@@@@   @@@       @@@@     @@@@    @@@    @@@   @@@                 @@@@@@@@@@@@@@\n @@@@@  @@@@  @@@@      @@@@      @@@@   @@@@   @@@@  @@@@\n@@@     @@@@  @@@       @@@@     @@@@    @@@    @@@@  @@@@\n@@@     @@@@  @@@@     @@@@      @@@@   @@@@   @@@@  @@@@\n @@@@@@@@@     @@@@@@  @@@@       @@@@  @@@@@@@@@    @@@@\n                                       @@@          @@@@\n                                      @@@\n                                      @@@\n```\n\nCoffeeScript is a little language that compiles into JavaScript.\n\n## Installation\n\nOnce you have Node.js installed:\n\n```shell\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Getting Started\n\nExecute a script:\n\n```shell\ncoffee /path/to/script.coffee\n```\n\nCompile a script:\n\n```shell\ncoffee -c /path/to/script.coffee\n```\n\nFor documentation, usage, and examples, see: https://coffeescript.org/\n\nTo suggest a feature or report a bug: https://github.com/jashkenas/coffeescript/issues\n\nIf youâd like to chat, drop by #coffeescript on Freenode IRC.\n\nThe source repository: https://github.com/jashkenas/coffeescript.git\n\nChangelog: https://coffeescript.org/#changelog\n\nOur lovely and talented contributors are listed here: https://github.com/jashkenas/coffeescript/contributors\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){return {
	"stat": {
		"mtime": "2019-03-06T07:31:43.256Z",
		"mtimeMs": 1551857503255.6763,
		"atime": "2019-03-06T07:31:43.272Z",
		"atimeMs": 1551857503271.6765,
		"isdirectory": true
	},
	"filename": "lib"
}})
	fileData.push(function(){return {
	"stat": {
		"mtime": "2019-03-06T07:31:43.264Z",
		"mtimeMs": 1551857503263.6765,
		"atime": "2019-03-06T07:31:43.272Z",
		"atimeMs": 1551857503271.6765,
		"isdirectory": true
	},
	"filename": "lib/coffeescript"
}})
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.259Z",
		"atimeMs": 1551857503259,
		"isfile": true
	},
	"filename": "lib/coffeescript/browser.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // This **Browser** compatibility layer extends core CoffeeScript functions\n  // to make things work smoothly when compiling code directly in the browser.\n  // We add support for loading remote Coffee scripts via **XHR**, and\n  // `text/coffeescript` script tags, source maps via data-URLs, and so on.\n  var CoffeeScript, compile, runScripts,\n    indexOf = [].indexOf;\n\n  CoffeeScript = require('./coffeescript');\n\n  ({compile} = CoffeeScript);\n\n  // Use `window.eval` to evaluate code, rather than just `eval`, to run the\n  // script in a clean global scope rather than inheriting the scope of the\n  // CoffeeScript compiler. (So that `cake test:browser` also works in Node,\n  // use either `window.eval` or `global.eval` as appropriate).\n  CoffeeScript.eval = function(code, options = {}) {\n    var globalRoot;\n    if (options.bare == null) {\n      options.bare = true;\n    }\n    globalRoot = typeof window !== \"undefined\" && window !== null ? window : global;\n    return globalRoot['eval'](compile(code, options));\n  };\n\n  // Running code does not provide access to this scope.\n  CoffeeScript.run = function(code, options = {}) {\n    options.bare = true;\n    options.shiftLine = true;\n    return Function(compile(code, options))();\n  };\n\n  // Export this more limited `CoffeeScript` than what is exported by\n  // `index.coffee`, which is intended for a Node environment.\n  module.exports = CoffeeScript;\n\n  // If weâre not in a browser environment, weâre finished with the public API.\n  if (typeof window === \"undefined\" || window === null) {\n    return;\n  }\n\n  // Include source maps where possible. If weâve got a base64 encoder, a\n  // JSON serializer, and tools for escaping unicode characters, weâre good to go.\n  // Ported from https://developer.mozilla.org/en-US/docs/DOM/window.btoa\n  if ((typeof btoa !== \"undefined\" && btoa !== null) && (typeof JSON !== \"undefined\" && JSON !== null)) {\n    compile = function(code, options = {}) {\n      options.inlineMap = true;\n      return CoffeeScript.compile(code, options);\n    };\n  }\n\n  // Load a remote script from the current domain via XHR.\n  CoffeeScript.load = function(url, callback, options = {}, hold = false) {\n    var xhr;\n    options.sourceFiles = [url];\n    xhr = window.ActiveXObject ? new window.ActiveXObject('Microsoft.XMLHTTP') : new window.XMLHttpRequest();\n    xhr.open('GET', url, true);\n    if ('overrideMimeType' in xhr) {\n      xhr.overrideMimeType('text/plain');\n    }\n    xhr.onreadystatechange = function() {\n      var param, ref;\n      if (xhr.readyState === 4) {\n        if ((ref = xhr.status) === 0 || ref === 200) {\n          param = [xhr.responseText, options];\n          if (!hold) {\n            CoffeeScript.run(...param);\n          }\n        } else {\n          throw new Error(`Could not load ${url}`);\n        }\n        if (callback) {\n          return callback(param);\n        }\n      }\n    };\n    return xhr.send(null);\n  };\n\n  // Activate CoffeeScript in the browser by having it compile and evaluate\n  // all script tags with a content-type of `text/coffeescript`.\n  // This happens on page load.\n  runScripts = function() {\n    var coffees, coffeetypes, execute, i, index, j, len, s, script, scripts;\n    scripts = window.document.getElementsByTagName('script');\n    coffeetypes = ['text/coffeescript', 'text/literate-coffeescript'];\n    coffees = (function() {\n      var j, len, ref, results;\n      results = [];\n      for (j = 0, len = scripts.length; j < len; j++) {\n        s = scripts[j];\n        if (ref = s.type, indexOf.call(coffeetypes, ref) >= 0) {\n          results.push(s);\n        }\n      }\n      return results;\n    })();\n    index = 0;\n    execute = function() {\n      var param;\n      param = coffees[index];\n      if (param instanceof Array) {\n        CoffeeScript.run(...param);\n        index++;\n        return execute();\n      }\n    };\n    for (i = j = 0, len = coffees.length; j < len; i = ++j) {\n      script = coffees[i];\n      (function(script, i) {\n        var options, source;\n        options = {\n          literate: script.type === coffeetypes[1]\n        };\n        source = script.src || script.getAttribute('data-src');\n        if (source) {\n          options.filename = source;\n          return CoffeeScript.load(source, function(param) {\n            coffees[i] = param;\n            return execute();\n          }, options, true);\n        } else {\n          // `options.filename` defines the filename the source map appears as\n          // in Developer Tools. If a script tag has an `id`, use that as the\n          // filename; otherwise use `coffeescript`, or `coffeescript1` etc.,\n          // leaving the first one unnumbered for the common case that thereâs\n          // only one CoffeeScript script block to parse.\n          options.filename = script.id && script.id !== '' ? script.id : `coffeescript${(i !== 0 ? i : '')}`;\n          options.sourceFiles = ['embedded'];\n          return coffees[i] = [script.innerHTML, options];\n        }\n      })(script, i);\n    }\n    return execute();\n  };\n\n  // Listen for window load, both in decent browsers and in IE.\n  if (window.addEventListener) {\n    window.addEventListener('DOMContentLoaded', runScripts, false);\n  } else {\n    window.attachEvent('onload', runScripts);\n  }\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.259Z",
		"atimeMs": 1551857503259,
		"isfile": true
	},
	"filename": "lib/coffeescript/cake.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // `cake` is a simplified version of [Make](http://www.gnu.org/software/make/)\n  // ([Rake](http://rake.rubyforge.org/), [Jake](https://github.com/280north/jake))\n  // for CoffeeScript. You define tasks with names and descriptions in a Cakefile,\n  // and can call them from the command line, or invoke them from other tasks.\n\n  // Running `cake` with no arguments will print out a list of all the tasks in the\n  // current directory's Cakefile.\n\n  // External dependencies.\n  var CoffeeScript, cakefileDirectory, fatalError, fs, helpers, missingTask, oparse, options, optparse, path, printTasks, switches, tasks;\n\n  fs = require('fs');\n\n  path = require('path');\n\n  helpers = require('./helpers');\n\n  optparse = require('./optparse');\n\n  CoffeeScript = require('./');\n\n  // Register .coffee extension\n  CoffeeScript.register();\n\n  // Keep track of the list of defined tasks, the accepted options, and so on.\n  tasks = {};\n\n  options = {};\n\n  switches = [];\n\n  oparse = null;\n\n  // Mixin the top-level Cake functions for Cakefiles to use directly.\n  helpers.extend(global, {\n    // Define a Cake task with a short name, an optional sentence description,\n    // and the function to run as the action itself.\n    task: function(name, description, action) {\n      if (!action) {\n        [action, description] = [description, action];\n      }\n      return tasks[name] = {name, description, action};\n    },\n    // Define an option that the Cakefile accepts. The parsed options hash,\n    // containing all of the command-line options passed, will be made available\n    // as the first argument to the action.\n    option: function(letter, flag, description) {\n      return switches.push([letter, flag, description]);\n    },\n    // Invoke another task in the current Cakefile.\n    invoke: function(name) {\n      if (!tasks[name]) {\n        missingTask(name);\n      }\n      return tasks[name].action(options);\n    }\n  });\n\n  // Run `cake`. Executes all of the tasks you pass, in order. Note that Node's\n  // asynchrony may cause tasks to execute in a different order than you'd expect.\n  // If no tasks are passed, print the help screen. Keep a reference to the\n  // original directory name, when running Cake tasks from subdirectories.\n  exports.run = function() {\n    var arg, args, e, i, len, ref, results;\n    global.__originalDirname = fs.realpathSync('.');\n    process.chdir(cakefileDirectory(__originalDirname));\n    args = process.argv.slice(2);\n    CoffeeScript.run(fs.readFileSync('Cakefile').toString(), {\n      filename: 'Cakefile'\n    });\n    oparse = new optparse.OptionParser(switches);\n    if (!args.length) {\n      return printTasks();\n    }\n    try {\n      options = oparse.parse(args);\n    } catch (error) {\n      e = error;\n      return fatalError(`${e}`);\n    }\n    ref = options.arguments;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      arg = ref[i];\n      results.push(invoke(arg));\n    }\n    return results;\n  };\n\n  // Display the list of Cake tasks in a format similar to `rake -T`\n  printTasks = function() {\n    var cakefilePath, desc, name, relative, spaces, task;\n    relative = path.relative || path.resolve;\n    cakefilePath = path.join(relative(__originalDirname, process.cwd()), 'Cakefile');\n    console.log(`${cakefilePath} defines the following tasks:\\n`);\n    for (name in tasks) {\n      task = tasks[name];\n      spaces = 20 - name.length;\n      spaces = spaces > 0 ? Array(spaces + 1).join(' ') : '';\n      desc = task.description ? `# ${task.description}` : '';\n      console.log(`cake ${name}${spaces} ${desc}`);\n    }\n    if (switches.length) {\n      return console.log(oparse.help());\n    }\n  };\n\n  // Print an error and exit when attempting to use an invalid task/option.\n  fatalError = function(message) {\n    console.error(message + '\\n');\n    console.log('To see a list of all tasks/options, run \"cake\"');\n    return process.exit(1);\n  };\n\n  missingTask = function(task) {\n    return fatalError(`No such task: ${task}`);\n  };\n\n  // When `cake` is invoked, search in the current and all parent directories\n  // to find the relevant Cakefile.\n  cakefileDirectory = function(dir) {\n    var parent;\n    if (fs.existsSync(path.join(dir, 'Cakefile'))) {\n      return dir;\n    }\n    parent = path.normalize(path.join(dir, '..'));\n    if (parent !== dir) {\n      return cakefileDirectory(parent);\n    }\n    throw new Error(`Cakefile not found in ${process.cwd()}`);\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.259Z",
		"atimeMs": 1551857503259,
		"isfile": true
	},
	"filename": "lib/coffeescript/coffeescript.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // CoffeeScript can be used both on the server, as a command-line compiler based\n  // on Node.js/V8, or to run CoffeeScript directly in the browser. This module\n  // contains the main entry functions for tokenizing, parsing, and compiling\n  // source CoffeeScript into JavaScript.\n  var FILE_EXTENSIONS, Lexer, SourceMap, base64encode, checkShebangLine, compile, formatSourcePosition, getSourceMap, helpers, lexer, packageJson, parser, sourceMaps, sources, withPrettyErrors,\n    indexOf = [].indexOf;\n\n  ({Lexer} = require('./lexer'));\n\n  ({parser} = require('./parser'));\n\n  helpers = require('./helpers');\n\n  SourceMap = require('./sourcemap');\n\n  // Require `package.json`, which is two levels above this file, as this file is\n  // evaluated from `lib/coffeescript`.\n  packageJson = require('../../package.json');\n\n  // The current CoffeeScript version number.\n  exports.VERSION = packageJson.version;\n\n  exports.FILE_EXTENSIONS = FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];\n\n  // Expose helpers for testing.\n  exports.helpers = helpers;\n\n  // Function that allows for btoa in both nodejs and the browser.\n  base64encode = function(src) {\n    switch (false) {\n      case typeof Buffer !== 'function':\n        return Buffer.from(src).toString('base64');\n      case typeof btoa !== 'function':\n        // The contents of a `<script>` block are encoded via UTF-16, so if any extended\n        // characters are used in the block, btoa will fail as it maxes out at UTF-8.\n        // See https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n        // for the gory details, and for the solution implemented here.\n        return btoa(encodeURIComponent(src).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n          return String.fromCharCode('0x' + p1);\n        }));\n      default:\n        throw new Error('Unable to base64 encode inline sourcemap.');\n    }\n  };\n\n  // Function wrapper to add source file information to SyntaxErrors thrown by the\n  // lexer/parser/compiler.\n  withPrettyErrors = function(fn) {\n    return function(code, options = {}) {\n      var err;\n      try {\n        return fn.call(this, code, options);\n      } catch (error) {\n        err = error;\n        if (typeof code !== 'string') { // Support `CoffeeScript.nodes(tokens)`.\n          throw err;\n        }\n        throw helpers.updateSyntaxError(err, code, options.filename);\n      }\n    };\n  };\n\n  // For each compiled file, save its source in memory in case we need to\n  // recompile it later. We might need to recompile if the first compilation\n  // didnât create a source map (faster) but something went wrong and we need\n  // a stack trace. Assuming that most of the time, code isnât throwing\n  // exceptions, itâs probably more efficient to compile twice only when we\n  // need a stack trace, rather than always generating a source map even when\n  // itâs not likely to be used. Save in form of `filename`: [`(source)`]\n  sources = {};\n\n  // Also save source maps if generated, in form of `(source)`: [`(source map)`].\n  sourceMaps = {};\n\n  // Compile CoffeeScript code to JavaScript, using the Coffee/Jison compiler.\n\n  // If `options.sourceMap` is specified, then `options.filename` must also be\n  // specified. All options that can be passed to `SourceMap#generate` may also\n  // be passed here.\n\n  // This returns a javascript string, unless `options.sourceMap` is passed,\n  // in which case this returns a `{js, v3SourceMap, sourceMap}`\n  // object, where sourceMap is a sourcemap.coffee#SourceMap object, handy for\n  // doing programmatic lookups.\n  exports.compile = compile = withPrettyErrors(function(code, options = {}) {\n    var currentColumn, currentLine, encoded, filename, fragment, fragments, generateSourceMap, header, i, j, js, len, len1, map, newLines, ref, ref1, sourceMapDataURI, sourceURL, token, tokens, transpiler, transpilerOptions, transpilerOutput, v3SourceMap;\n    // Clone `options`, to avoid mutating the `options` object passed in.\n    options = Object.assign({}, options);\n    // Always generate a source map if no filename is passed in, since without a\n    // a filename we have no way to retrieve this source later in the event that\n    // we need to recompile it to get a source map for `prepareStackTrace`.\n    generateSourceMap = options.sourceMap || options.inlineMap || (options.filename == null);\n    filename = options.filename || '<anonymous>';\n    checkShebangLine(filename, code);\n    if (sources[filename] == null) {\n      sources[filename] = [];\n    }\n    sources[filename].push(code);\n    if (generateSourceMap) {\n      map = new SourceMap;\n    }\n    tokens = lexer.tokenize(code, options);\n    // Pass a list of referenced variables, so that generated variables wonât get\n    // the same name.\n    options.referencedVars = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if (token[0] === 'IDENTIFIER') {\n          results.push(token[1]);\n        }\n      }\n      return results;\n    })();\n    // Check for import or export; if found, force bare mode.\n    if (!((options.bare != null) && options.bare === true)) {\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if ((ref = token[0]) === 'IMPORT' || ref === 'EXPORT') {\n          options.bare = true;\n          break;\n        }\n      }\n    }\n    fragments = parser.parse(tokens).compileToFragments(options);\n    currentLine = 0;\n    if (options.header) {\n      currentLine += 1;\n    }\n    if (options.shiftLine) {\n      currentLine += 1;\n    }\n    currentColumn = 0;\n    js = \"\";\n    for (j = 0, len1 = fragments.length; j < len1; j++) {\n      fragment = fragments[j];\n      // Update the sourcemap with data from each fragment.\n      if (generateSourceMap) {\n        // Do not include empty, whitespace, or semicolon-only fragments.\n        if (fragment.locationData && !/^[;\\s]*$/.test(fragment.code)) {\n          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {\n            noReplace: true\n          });\n        }\n        newLines = helpers.count(fragment.code, \"\\n\");\n        currentLine += newLines;\n        if (newLines) {\n          currentColumn = fragment.code.length - (fragment.code.lastIndexOf(\"\\n\") + 1);\n        } else {\n          currentColumn += fragment.code.length;\n        }\n      }\n      // Copy the code from each fragment into the final JavaScript.\n      js += fragment.code;\n    }\n    if (options.header) {\n      header = `Generated by CoffeeScript ${this.VERSION}`;\n      js = `// ${header}\\n${js}`;\n    }\n    if (generateSourceMap) {\n      v3SourceMap = map.generate(options, code);\n      if (sourceMaps[filename] == null) {\n        sourceMaps[filename] = [];\n      }\n      sourceMaps[filename].push(map);\n    }\n    if (options.transpile) {\n      if (typeof options.transpile !== 'object') {\n        // This only happens if run via the Node API and `transpile` is set to\n        // something other than an object.\n        throw new Error('The transpile option must be given an object with options to pass to Babel');\n      }\n      // Get the reference to Babel that we have been passed if this compiler\n      // is run via the CLI or Node API.\n      transpiler = options.transpile.transpile;\n      delete options.transpile.transpile;\n      transpilerOptions = Object.assign({}, options.transpile);\n      // See https://github.com/babel/babel/issues/827#issuecomment-77573107:\n      // Babel can take a v3 source map object as input in `inputSourceMap`\n      // and it will return an *updated* v3 source map object in its output.\n      if (v3SourceMap && (transpilerOptions.inputSourceMap == null)) {\n        transpilerOptions.inputSourceMap = v3SourceMap;\n      }\n      transpilerOutput = transpiler(js, transpilerOptions);\n      js = transpilerOutput.code;\n      if (v3SourceMap && transpilerOutput.map) {\n        v3SourceMap = transpilerOutput.map;\n      }\n    }\n    if (options.inlineMap) {\n      encoded = base64encode(JSON.stringify(v3SourceMap));\n      sourceMapDataURI = `//# sourceMappingURL=data:application/json;base64,${encoded}`;\n      sourceURL = `//# sourceURL=${(ref1 = options.filename) != null ? ref1 : 'coffeescript'}`;\n      js = `${js}\\n${sourceMapDataURI}\\n${sourceURL}`;\n    }\n    if (options.sourceMap) {\n      return {\n        js,\n        sourceMap: map,\n        v3SourceMap: JSON.stringify(v3SourceMap, null, 2)\n      };\n    } else {\n      return js;\n    }\n  });\n\n  // Tokenize a string of CoffeeScript code, and return the array of tokens.\n  exports.tokens = withPrettyErrors(function(code, options) {\n    return lexer.tokenize(code, options);\n  });\n\n  // Parse a string of CoffeeScript code or an array of lexed tokens, and\n  // return the AST. You can then compile it by calling `.compile()` on the root,\n  // or traverse it by using `.traverseChildren()` with a callback.\n  exports.nodes = withPrettyErrors(function(source, options) {\n    if (typeof source === 'string') {\n      return parser.parse(lexer.tokenize(source, options));\n    } else {\n      return parser.parse(source);\n    }\n  });\n\n  // This file used to export these methods; leave stubs that throw warnings\n  // instead. These methods have been moved into `index.coffee` to provide\n  // separate entrypoints for Node and non-Node environments, so that static\n  // analysis tools donât choke on Node packages when compiling for a non-Node\n  // environment.\n  exports.run = exports.eval = exports.register = function() {\n    throw new Error('require index.coffee, not this file');\n  };\n\n  // Instantiate a Lexer for our use here.\n  lexer = new Lexer;\n\n  // The real Lexer produces a generic stream of tokens. This object provides a\n  // thin wrapper around it, compatible with the Jison API. We can then pass it\n  // directly as a âJison lexer.â\n  parser.lexer = {\n    lex: function() {\n      var tag, token;\n      token = parser.tokens[this.pos++];\n      if (token) {\n        [tag, this.yytext, this.yylloc] = token;\n        parser.errorToken = token.origin || token;\n        this.yylineno = this.yylloc.first_line;\n      } else {\n        tag = '';\n      }\n      return tag;\n    },\n    setInput: function(tokens) {\n      parser.tokens = tokens;\n      return this.pos = 0;\n    },\n    upcomingInput: function() {\n      return '';\n    }\n  };\n\n  // Make all the AST nodes visible to the parser.\n  parser.yy = require('./nodes');\n\n  // Override Jison's default error handling function.\n  parser.yy.parseError = function(message, {token}) {\n    var errorLoc, errorTag, errorText, errorToken, tokens;\n    // Disregard Jison's message, it contains redundant line number information.\n    // Disregard the token, we take its value directly from the lexer in case\n    // the error is caused by a generated token which might refer to its origin.\n    ({errorToken, tokens} = parser);\n    [errorTag, errorText, errorLoc] = errorToken;\n    errorText = (function() {\n      switch (false) {\n        case errorToken !== tokens[tokens.length - 1]:\n          return 'end of input';\n        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':\n          return 'indentation';\n        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'INFINITY' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':\n          return errorTag.replace(/_START$/, '').toLowerCase();\n        default:\n          return helpers.nameWhitespaceCharacter(errorText);\n      }\n    })();\n    // The second argument has a `loc` property, which should have the location\n    // data for this token. Unfortunately, Jison seems to send an outdated `loc`\n    // (from the previous token), so we take the location information directly\n    // from the lexer.\n    return helpers.throwSyntaxError(`unexpected ${errorText}`, errorLoc);\n  };\n\n  // Based on http://v8.googlecode.com/svn/branches/bleeding_edge/src/messages.js\n  // Modified to handle sourceMap\n  formatSourcePosition = function(frame, getSourceMapping) {\n    var as, column, fileLocation, filename, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;\n    filename = void 0;\n    fileLocation = '';\n    if (frame.isNative()) {\n      fileLocation = \"native\";\n    } else {\n      if (frame.isEval()) {\n        filename = frame.getScriptNameOrSourceURL();\n        if (!filename) {\n          fileLocation = `${frame.getEvalOrigin()}, `;\n        }\n      } else {\n        filename = frame.getFileName();\n      }\n      filename || (filename = \"<anonymous>\");\n      line = frame.getLineNumber();\n      column = frame.getColumnNumber();\n      // Check for a sourceMap position\n      source = getSourceMapping(filename, line, column);\n      fileLocation = source ? `${filename}:${source[0]}:${source[1]}` : `${filename}:${line}:${column}`;\n    }\n    functionName = frame.getFunctionName();\n    isConstructor = frame.isConstructor();\n    isMethodCall = !(frame.isToplevel() || isConstructor);\n    if (isMethodCall) {\n      methodName = frame.getMethodName();\n      typeName = frame.getTypeName();\n      if (functionName) {\n        tp = as = '';\n        if (typeName && functionName.indexOf(typeName)) {\n          tp = `${typeName}.`;\n        }\n        if (methodName && functionName.indexOf(`.${methodName}`) !== functionName.length - methodName.length - 1) {\n          as = ` [as ${methodName}]`;\n        }\n        return `${tp}${functionName}${as} (${fileLocation})`;\n      } else {\n        return `${typeName}.${methodName || '<anonymous>'} (${fileLocation})`;\n      }\n    } else if (isConstructor) {\n      return `new ${functionName || '<anonymous>'} (${fileLocation})`;\n    } else if (functionName) {\n      return `${functionName} (${fileLocation})`;\n    } else {\n      return fileLocation;\n    }\n  };\n\n  getSourceMap = function(filename, line, column) {\n    var answer, i, map, ref, ref1, sourceLocation;\n    if (!(filename === '<anonymous>' || (ref = filename.slice(filename.lastIndexOf('.')), indexOf.call(FILE_EXTENSIONS, ref) >= 0))) {\n      // Skip files that we didnât compile, like Node system files that appear in\n      // the stack trace, as they never have source maps.\n      return null;\n    }\n    if (filename !== '<anonymous>' && (sourceMaps[filename] != null)) {\n      return sourceMaps[filename][sourceMaps[filename].length - 1];\n    // CoffeeScript compiled in a browser or via `CoffeeScript.compile` or `.run`\n    // may get compiled with `options.filename` thatâs missing, which becomes\n    // `<anonymous>`; but the runtime might request the stack trace with the\n    // filename of the script file. See if we have a source map cached under\n    // `<anonymous>` that matches the error.\n    } else if (sourceMaps['<anonymous>'] != null) {\n      ref1 = sourceMaps['<anonymous>'];\n      // Work backwards from the most recent anonymous source maps, until we find\n      // one that works. This isnât foolproof; there is a chance that multiple\n      // source maps will have line/column pairs that match. But we have no other\n      // way to match them. `frame.getFunction().toString()` doesnât always work,\n      // and itâs not foolproof either.\n      for (i = ref1.length - 1; i >= 0; i += -1) {\n        map = ref1[i];\n        sourceLocation = map.sourceLocation([line - 1, column - 1]);\n        if (((sourceLocation != null ? sourceLocation[0] : void 0) != null) && (sourceLocation[1] != null)) {\n          return map;\n        }\n      }\n    }\n    // If all else fails, recompile this source to get a source map. We need the\n    // previous section (for `<anonymous>`) despite this option, because after it\n    // gets compiled we will still need to look it up from\n    // `sourceMaps['<anonymous>']` in order to find and return it. Thatâs why we\n    // start searching from the end in the previous block, because most of the\n    // time the source map we want is the last one.\n    if (sources[filename] != null) {\n      answer = compile(sources[filename][sources[filename].length - 1], {\n        filename: filename,\n        sourceMap: true,\n        literate: helpers.isLiterate(filename)\n      });\n      return answer.sourceMap;\n    } else {\n      return null;\n    }\n  };\n\n  // Based on [michaelficarra/CoffeeScriptRedux](http://goo.gl/ZTx1p)\n  // NodeJS / V8 have no support for transforming positions in stack traces using\n  // sourceMap, so we must monkey-patch Error to display CoffeeScript source\n  // positions.\n  Error.prepareStackTrace = function(err, stack) {\n    var frame, frames, getSourceMapping;\n    getSourceMapping = function(filename, line, column) {\n      var answer, sourceMap;\n      sourceMap = getSourceMap(filename, line, column);\n      if (sourceMap != null) {\n        answer = sourceMap.sourceLocation([line - 1, column - 1]);\n      }\n      if (answer != null) {\n        return [answer[0] + 1, answer[1] + 1];\n      } else {\n        return null;\n      }\n    };\n    frames = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = stack.length; i < len; i++) {\n        frame = stack[i];\n        if (frame.getFunction() === exports.run) {\n          break;\n        }\n        results.push(`    at ${formatSourcePosition(frame, getSourceMapping)}`);\n      }\n      return results;\n    })();\n    return `${err.toString()}\\n${frames.join('\\n')}\\n`;\n  };\n\n  checkShebangLine = function(file, input) {\n    var args, firstLine, ref, rest;\n    firstLine = input.split(/$/m)[0];\n    rest = firstLine != null ? firstLine.match(/^#!\\s*([^\\s]+\\s*)(.*)/) : void 0;\n    args = rest != null ? (ref = rest[2]) != null ? ref.split(/\\s/).filter(function(s) {\n      return s !== '';\n    }) : void 0 : void 0;\n    if ((args != null ? args.length : void 0) > 1) {\n      console.error('The script to be run begins with a shebang line with more than one\\nargument. This script will fail on platforms such as Linux which only\\nallow a single argument.');\n      console.error(`The shebang line was: '${firstLine}' in file '${file}'`);\n      return console.error(`The arguments were: ${JSON.stringify(args)}`);\n    }\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.259Z",
		"atimeMs": 1551857503259,
		"isfile": true
	},
	"filename": "lib/coffeescript/command.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // The `coffee` utility. Handles command-line compilation of CoffeeScript\n  // into various forms: saved into `.js` files or printed to stdout\n  // or recompiled every time the source is saved,\n  // printed as a token stream or as the syntax tree, or launch an\n  // interactive REPL.\n\n  // External dependencies.\n  var BANNER, CoffeeScript, EventEmitter, SWITCHES, buildCSOptionParser, compileJoin, compileOptions, compilePath, compileScript, compileStdio, exec, findDirectoryIndex, forkNode, fs, helpers, hidden, joinTimeout, makePrelude, mkdirp, notSources, optionParser, optparse, opts, outputPath, parseOptions, path, printLine, printTokens, printWarn, removeSource, removeSourceDir, silentUnlink, sourceCode, sources, spawn, timeLog, usage, useWinPathSep, version, wait, watch, watchDir, watchedDirs, writeJs,\n    indexOf = [].indexOf;\n\n  fs = require('fs');\n\n  path = require('path');\n\n  helpers = require('./helpers');\n\n  optparse = require('./optparse');\n\n  CoffeeScript = require('./');\n\n  ({spawn, exec} = require('child_process'));\n\n  ({EventEmitter} = require('events'));\n\n  useWinPathSep = path.sep === '\\\\';\n\n  // Allow CoffeeScript to emit Node.js events.\n  helpers.extend(CoffeeScript, new EventEmitter);\n\n  printLine = function(line) {\n    return process.stdout.write(line + '\\n');\n  };\n\n  printWarn = function(line) {\n    return process.stderr.write(line + '\\n');\n  };\n\n  hidden = function(file) {\n    return /^\\.|~$/.test(file);\n  };\n\n  // The help banner that is printed in conjunction with `-h`/`--help`.\n  BANNER = 'Usage: coffee [options] path/to/script.coffee [args]\\n\\nIf called without options, `coffee` will run your script.';\n\n  // The list of all the valid option flags that `coffee` knows how to handle.\n  SWITCHES = [['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-i', '--interactive', 'run an interactive CoffeeScript REPL'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-m', '--map', 'generate source map and save as .js.map files'], ['-M', '--inline-map', 'generate source map and include it directly in output'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['--nodejs [ARGS]', 'pass options directly to the \"node\" binary'], ['--no-header', 'suppress the \"Generated by\" header'], ['-o', '--output [PATH]', 'set the output path or path/filename for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-r', '--require [MODULE*]', 'require the given module before eval or REPL'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-l', '--literate', 'treat stdio as literate style coffeescript'], ['-t', '--transpile', 'pipe generated JavaScript through Babel'], ['--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];\n\n  // Top-level objects shared by all the functions.\n  opts = {};\n\n  sources = [];\n\n  sourceCode = [];\n\n  notSources = {};\n\n  watchedDirs = {};\n\n  optionParser = null;\n\n  exports.buildCSOptionParser = buildCSOptionParser = function() {\n    return new optparse.OptionParser(SWITCHES, BANNER);\n  };\n\n  // Run `coffee` by parsing passed options and determining what action to take.\n  // Many flags cause us to divert before compiling anything. Flags passed after\n  // `--` will be passed verbatim to your script as arguments in `process.argv`\n  exports.run = function() {\n    var err, i, len, literals, outputBasename, ref, replCliOpts, results, source;\n    optionParser = buildCSOptionParser();\n    try {\n      parseOptions();\n    } catch (error) {\n      err = error;\n      console.error(`option parsing error: ${err.message}`);\n      process.exit(1);\n    }\n    if ((!opts.doubleDashed) && (opts.arguments[1] === '--')) {\n      printWarn('coffee was invoked with \\'--\\' as the second positional argument, which is\\nnow deprecated. To pass \\'--\\' as an argument to a script to run, put an\\nadditional \\'--\\' before the path to your script.\\n\\n\\'--\\' will be removed from the argument list.');\n      printWarn(`The positional arguments were: ${JSON.stringify(opts.arguments)}`);\n      opts.arguments = [opts.arguments[0]].concat(opts.arguments.slice(2));\n    }\n    // Make the REPL *CLI* use the global context so as to (a) be consistent with the\n    // `node` REPL CLI and, therefore, (b) make packages that modify native prototypes\n    // (such as 'colors' and 'sugar') work as expected.\n    replCliOpts = {\n      useGlobal: true\n    };\n    if (opts.require) {\n      opts.prelude = makePrelude(opts.require);\n    }\n    replCliOpts.prelude = opts.prelude;\n    replCliOpts.transpile = opts.transpile;\n    if (opts.nodejs) {\n      return forkNode();\n    }\n    if (opts.help) {\n      return usage();\n    }\n    if (opts.version) {\n      return version();\n    }\n    if (opts.interactive) {\n      return require('./repl').start(replCliOpts);\n    }\n    if (opts.stdio) {\n      return compileStdio();\n    }\n    if (opts.eval) {\n      return compileScript(null, opts.arguments[0]);\n    }\n    if (!opts.arguments.length) {\n      return require('./repl').start(replCliOpts);\n    }\n    literals = opts.run ? opts.arguments.splice(1) : [];\n    process.argv = process.argv.slice(0, 2).concat(literals);\n    process.argv[0] = 'coffee';\n    if (opts.output) {\n      outputBasename = path.basename(opts.output);\n      if (indexOf.call(outputBasename, '.') >= 0 && (outputBasename !== '.' && outputBasename !== '..') && !helpers.ends(opts.output, path.sep)) {\n        // An output filename was specified, e.g. `/dist/scripts.js`.\n        opts.outputFilename = outputBasename;\n        opts.outputPath = path.resolve(path.dirname(opts.output));\n      } else {\n        // An output path was specified, e.g. `/dist`.\n        opts.outputFilename = null;\n        opts.outputPath = path.resolve(opts.output);\n      }\n    }\n    if (opts.join) {\n      opts.join = path.resolve(opts.join);\n      console.error('\\nThe --join option is deprecated and will be removed in a future version.\\n\\nIf for some reason it\\'s necessary to share local variables between files,\\nreplace...\\n\\n    $ coffee --compile --join bundle.js -- a.coffee b.coffee c.coffee\\n\\nwith...\\n\\n    $ cat a.coffee b.coffee c.coffee | coffee --compile --stdio > bundle.js\\n');\n    }\n    ref = opts.arguments;\n    results = [];\n    for (i = 0, len = ref.length; i < len; i++) {\n      source = ref[i];\n      source = path.resolve(source);\n      results.push(compilePath(source, true, source));\n    }\n    return results;\n  };\n\n  makePrelude = function(requires) {\n    return requires.map(function(module) {\n      var full, match, name;\n      if (match = module.match(/^(.*)=(.*)$/)) {\n        [full, name, module] = match;\n      }\n      name || (name = helpers.baseFileName(module, true, useWinPathSep));\n      return `global['${name}'] = require('${module}')`;\n    }).join(';');\n  };\n\n  // Compile a path, which could be a script or a directory. If a directory\n  // is passed, recursively compile all '.coffee', '.litcoffee', and '.coffee.md'\n  // extension source files in it and all subdirectories.\n  compilePath = function(source, topLevel, base) {\n    var code, err, file, files, i, len, results, stats;\n    if (indexOf.call(sources, source) >= 0 || watchedDirs[source] || !topLevel && (notSources[source] || hidden(source))) {\n      return;\n    }\n    try {\n      stats = fs.statSync(source);\n    } catch (error) {\n      err = error;\n      if (err.code === 'ENOENT') {\n        console.error(`File not found: ${source}`);\n        process.exit(1);\n      }\n      throw err;\n    }\n    if (stats.isDirectory()) {\n      if (path.basename(source) === 'node_modules') {\n        notSources[source] = true;\n        return;\n      }\n      if (opts.run) {\n        compilePath(findDirectoryIndex(source), topLevel, base);\n        return;\n      }\n      if (opts.watch) {\n        watchDir(source, base);\n      }\n      try {\n        files = fs.readdirSync(source);\n      } catch (error) {\n        err = error;\n        if (err.code === 'ENOENT') {\n          return;\n        } else {\n          throw err;\n        }\n      }\n      results = [];\n      for (i = 0, len = files.length; i < len; i++) {\n        file = files[i];\n        results.push(compilePath(path.join(source, file), false, base));\n      }\n      return results;\n    } else if (topLevel || helpers.isCoffee(source)) {\n      sources.push(source);\n      sourceCode.push(null);\n      delete notSources[source];\n      if (opts.watch) {\n        watch(source, base);\n      }\n      try {\n        code = fs.readFileSync(source);\n      } catch (error) {\n        err = error;\n        if (err.code === 'ENOENT') {\n          return;\n        } else {\n          throw err;\n        }\n      }\n      return compileScript(source, code.toString(), base);\n    } else {\n      return notSources[source] = true;\n    }\n  };\n\n  findDirectoryIndex = function(source) {\n    var err, ext, i, index, len, ref;\n    ref = CoffeeScript.FILE_EXTENSIONS;\n    for (i = 0, len = ref.length; i < len; i++) {\n      ext = ref[i];\n      index = path.join(source, `index${ext}`);\n      try {\n        if ((fs.statSync(index)).isFile()) {\n          return index;\n        }\n      } catch (error) {\n        err = error;\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n    }\n    console.error(`Missing index.coffee or index.litcoffee in ${source}`);\n    return process.exit(1);\n  };\n\n  // Compile a single source script, containing the given code, according to the\n  // requested options. If evaluating the script directly, set `__filename`,\n  // `__dirname` and `module.filename` to be correct relative to the script's path.\n  compileScript = function(file, input, base = null) {\n    var compiled, err, message, options, saveTo, task;\n    options = compileOptions(file, base);\n    try {\n      task = {file, input, options};\n      CoffeeScript.emit('compile', task);\n      if (opts.tokens) {\n        return printTokens(CoffeeScript.tokens(task.input, task.options));\n      } else if (opts.nodes) {\n        return printLine(CoffeeScript.nodes(task.input, task.options).toString().trim());\n      } else if (opts.run) {\n        CoffeeScript.register();\n        if (opts.prelude) {\n          CoffeeScript.eval(opts.prelude, task.options);\n        }\n        return CoffeeScript.run(task.input, task.options);\n      } else if (opts.join && task.file !== opts.join) {\n        if (helpers.isLiterate(file)) {\n          task.input = helpers.invertLiterate(task.input);\n        }\n        sourceCode[sources.indexOf(task.file)] = task.input;\n        return compileJoin();\n      } else {\n        compiled = CoffeeScript.compile(task.input, task.options);\n        task.output = compiled;\n        if (opts.map) {\n          task.output = compiled.js;\n          task.sourceMap = compiled.v3SourceMap;\n        }\n        CoffeeScript.emit('success', task);\n        if (opts.print) {\n          return printLine(task.output.trim());\n        } else if (opts.compile || opts.map) {\n          saveTo = opts.outputFilename && sources.length === 1 ? path.join(opts.outputPath, opts.outputFilename) : options.jsPath;\n          return writeJs(base, task.file, task.output, saveTo, task.sourceMap);\n        }\n      }\n    } catch (error) {\n      err = error;\n      CoffeeScript.emit('failure', err, task);\n      if (CoffeeScript.listeners('failure').length) {\n        return;\n      }\n      message = (err != null ? err.stack : void 0) || `${err}`;\n      if (opts.watch) {\n        return printLine(message + '\\x07');\n      } else {\n        printWarn(message);\n        return process.exit(1);\n      }\n    }\n  };\n\n  // Attach the appropriate listeners to compile scripts incoming over **stdin**,\n  // and write them back to **stdout**.\n  compileStdio = function() {\n    var buffers, stdin;\n    if (opts.map) {\n      console.error('--stdio and --map cannot be used together');\n      process.exit(1);\n    }\n    buffers = [];\n    stdin = process.openStdin();\n    stdin.on('data', function(buffer) {\n      if (buffer) {\n        return buffers.push(buffer);\n      }\n    });\n    return stdin.on('end', function() {\n      return compileScript(null, Buffer.concat(buffers).toString());\n    });\n  };\n\n  // If all of the source files are done being read, concatenate and compile\n  // them together.\n  joinTimeout = null;\n\n  compileJoin = function() {\n    if (!opts.join) {\n      return;\n    }\n    if (!sourceCode.some(function(code) {\n      return code === null;\n    })) {\n      clearTimeout(joinTimeout);\n      return joinTimeout = wait(100, function() {\n        return compileScript(opts.join, sourceCode.join('\\n'), opts.join);\n      });\n    }\n  };\n\n  // Watch a source CoffeeScript file using `fs.watch`, recompiling it every\n  // time the file is updated. May be used in combination with other options,\n  // such as `--print`.\n  watch = function(source, base) {\n    var compile, compileTimeout, err, prevStats, rewatch, startWatcher, watchErr, watcher;\n    watcher = null;\n    prevStats = null;\n    compileTimeout = null;\n    watchErr = function(err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n      if (indexOf.call(sources, source) < 0) {\n        return;\n      }\n      try {\n        rewatch();\n        return compile();\n      } catch (error) {\n        removeSource(source, base);\n        return compileJoin();\n      }\n    };\n    compile = function() {\n      clearTimeout(compileTimeout);\n      return compileTimeout = wait(25, function() {\n        return fs.stat(source, function(err, stats) {\n          if (err) {\n            return watchErr(err);\n          }\n          if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {\n            return rewatch();\n          }\n          prevStats = stats;\n          return fs.readFile(source, function(err, code) {\n            if (err) {\n              return watchErr(err);\n            }\n            compileScript(source, code.toString(), base);\n            return rewatch();\n          });\n        });\n      });\n    };\n    startWatcher = function() {\n      return watcher = fs.watch(source).on('change', compile).on('error', function(err) {\n        if (err.code !== 'EPERM') {\n          throw err;\n        }\n        return removeSource(source, base);\n      });\n    };\n    rewatch = function() {\n      if (watcher != null) {\n        watcher.close();\n      }\n      return startWatcher();\n    };\n    try {\n      return startWatcher();\n    } catch (error) {\n      err = error;\n      return watchErr(err);\n    }\n  };\n\n  // Watch a directory of files for new additions.\n  watchDir = function(source, base) {\n    var err, readdirTimeout, startWatcher, stopWatcher, watcher;\n    watcher = null;\n    readdirTimeout = null;\n    startWatcher = function() {\n      return watcher = fs.watch(source).on('error', function(err) {\n        if (err.code !== 'EPERM') {\n          throw err;\n        }\n        return stopWatcher();\n      }).on('change', function() {\n        clearTimeout(readdirTimeout);\n        return readdirTimeout = wait(25, function() {\n          var err, file, files, i, len, results;\n          try {\n            files = fs.readdirSync(source);\n          } catch (error) {\n            err = error;\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n            return stopWatcher();\n          }\n          results = [];\n          for (i = 0, len = files.length; i < len; i++) {\n            file = files[i];\n            results.push(compilePath(path.join(source, file), false, base));\n          }\n          return results;\n        });\n      });\n    };\n    stopWatcher = function() {\n      watcher.close();\n      return removeSourceDir(source, base);\n    };\n    watchedDirs[source] = true;\n    try {\n      return startWatcher();\n    } catch (error) {\n      err = error;\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n  };\n\n  removeSourceDir = function(source, base) {\n    var file, i, len, sourcesChanged;\n    delete watchedDirs[source];\n    sourcesChanged = false;\n    for (i = 0, len = sources.length; i < len; i++) {\n      file = sources[i];\n      if (!(source === path.dirname(file))) {\n        continue;\n      }\n      removeSource(file, base);\n      sourcesChanged = true;\n    }\n    if (sourcesChanged) {\n      return compileJoin();\n    }\n  };\n\n  // Remove a file from our source list, and source code cache. Optionally remove\n  // the compiled JS version as well.\n  removeSource = function(source, base) {\n    var index;\n    index = sources.indexOf(source);\n    sources.splice(index, 1);\n    sourceCode.splice(index, 1);\n    if (!opts.join) {\n      silentUnlink(outputPath(source, base));\n      silentUnlink(outputPath(source, base, '.js.map'));\n      return timeLog(`removed ${source}`);\n    }\n  };\n\n  silentUnlink = function(path) {\n    var err, ref;\n    try {\n      return fs.unlinkSync(path);\n    } catch (error) {\n      err = error;\n      if ((ref = err.code) !== 'ENOENT' && ref !== 'EPERM') {\n        throw err;\n      }\n    }\n  };\n\n  // Get the corresponding output JavaScript path for a source file.\n  outputPath = function(source, base, extension = \".js\") {\n    var basename, dir, srcDir;\n    basename = helpers.baseFileName(source, true, useWinPathSep);\n    srcDir = path.dirname(source);\n    dir = !opts.outputPath ? srcDir : source === base ? opts.outputPath : path.join(opts.outputPath, path.relative(base, srcDir));\n    return path.join(dir, basename + extension);\n  };\n\n  // Recursively mkdir, like `mkdir -p`.\n  mkdirp = function(dir, fn) {\n    var mkdirs, mode;\n    mode = 0o777 & ~process.umask();\n    return (mkdirs = function(p, fn) {\n      return fs.exists(p, function(exists) {\n        if (exists) {\n          return fn();\n        } else {\n          return mkdirs(path.dirname(p), function() {\n            return fs.mkdir(p, mode, function(err) {\n              if (err) {\n                return fn(err);\n              }\n              return fn();\n            });\n          });\n        }\n      });\n    })(dir, fn);\n  };\n\n  // Write out a JavaScript source file with the compiled code. By default, files\n  // are written out in `cwd` as `.js` files with the same name, but the output\n  // directory can be customized with `--output`.\n\n  // If `generatedSourceMap` is provided, this will write a `.js.map` file into the\n  // same directory as the `.js` file.\n  writeJs = function(base, sourcePath, js, jsPath, generatedSourceMap = null) {\n    var compile, jsDir, sourceMapPath;\n    sourceMapPath = `${jsPath}.map`;\n    jsDir = path.dirname(jsPath);\n    compile = function() {\n      if (opts.compile) {\n        if (js.length <= 0) {\n          js = ' ';\n        }\n        if (generatedSourceMap) {\n          js = `${js}\\n//# sourceMappingURL=${helpers.baseFileName(sourceMapPath, false, useWinPathSep)}\\n`;\n        }\n        fs.writeFile(jsPath, js, function(err) {\n          if (err) {\n            printLine(err.message);\n            return process.exit(1);\n          } else if (opts.compile && opts.watch) {\n            return timeLog(`compiled ${sourcePath}`);\n          }\n        });\n      }\n      if (generatedSourceMap) {\n        return fs.writeFile(sourceMapPath, generatedSourceMap, function(err) {\n          if (err) {\n            printLine(`Could not write source map: ${err.message}`);\n            return process.exit(1);\n          }\n        });\n      }\n    };\n    return fs.exists(jsDir, function(itExists) {\n      if (itExists) {\n        return compile();\n      } else {\n        return mkdirp(jsDir, compile);\n      }\n    });\n  };\n\n  // Convenience for cleaner setTimeouts.\n  wait = function(milliseconds, func) {\n    return setTimeout(func, milliseconds);\n  };\n\n  // When watching scripts, it's useful to log changes with the timestamp.\n  timeLog = function(message) {\n    return console.log(`${(new Date).toLocaleTimeString()} - ${message}`);\n  };\n\n  // Pretty-print a stream of tokens, sans location data.\n  printTokens = function(tokens) {\n    var strings, tag, token, value;\n    strings = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        tag = token[0];\n        value = token[1].toString().replace(/\\n/, '\\\\n');\n        results.push(`[${tag} ${value}]`);\n      }\n      return results;\n    })();\n    return printLine(strings.join(' '));\n  };\n\n  // Use the [OptionParser module](optparse.html) to extract all options from\n  // `process.argv` that are specified in `SWITCHES`.\n  parseOptions = function() {\n    var o;\n    o = opts = optionParser.parse(process.argv.slice(2));\n    o.compile || (o.compile = !!o.output);\n    o.run = !(o.compile || o.print || o.map);\n    return o.print = !!(o.print || (o.eval || o.stdio && o.compile));\n  };\n\n  // The compile-time options to pass to the CoffeeScript compiler.\n  compileOptions = function(filename, base) {\n    var answer, cwd, jsDir, jsPath;\n    if (opts.transpile) {\n      try {\n        // The user has requested that the CoffeeScript compiler also transpile\n        // via Babel. We donât include Babel as a dependency because we want to\n        // avoid dependencies in general, and most users probably wonât be relying\n        // on us to transpile for them; we assume most users will probably either\n        // run CoffeeScriptâs output without transpilation (modern Node or evergreen\n        // browsers) or use a proper build chain like Gulp or Webpack.\n        require('@babel/core');\n      } catch (error) {\n        try {\n          require('babel-core');\n        } catch (error) {\n          // Give appropriate instructions depending on whether `coffee` was run\n          // locally or globally.\n          if (require.resolve('.').indexOf(process.cwd()) === 0) {\n            console.error('To use --transpile, you must have @babel/core installed:\\n  npm install --save-dev @babel/core\\nAnd you must save options to configure Babel in one of the places it looks to find its options.\\nSee https://coffeescript.org/#transpilation');\n          } else {\n            console.error('To use --transpile with globally-installed CoffeeScript, you must have @babel/core installed globally:\\n  npm install --global @babel/core\\nAnd you must save options to configure Babel in one of the places it looks to find its options, relative to the file being compiled or to the current folder.\\nSee https://coffeescript.org/#transpilation');\n          }\n          process.exit(1);\n        }\n      }\n      if (typeof opts.transpile !== 'object') {\n        opts.transpile = {};\n      }\n      // Pass a reference to Babel into the compiler, so that the transpile option\n      // is available for the CLI. We need to do this so that tools like Webpack\n      // can `require('coffeescript')` and build correctly, without trying to\n      // require Babel.\n      opts.transpile.transpile = CoffeeScript.transpile;\n      // Babel searches for its options (a `.babelrc` file, a `.babelrc.js` file,\n      // a `package.json` file with a `babel` key, etc.) relative to the path\n      // given to it in its `filename` option. Make sure we have a path to pass\n      // along.\n      if (!opts.transpile.filename) {\n        opts.transpile.filename = filename || path.resolve(base || process.cwd(), '<anonymous>');\n      }\n    } else {\n      opts.transpile = false;\n    }\n    answer = {\n      filename: filename,\n      literate: opts.literate || helpers.isLiterate(filename),\n      bare: opts.bare,\n      header: opts.compile && !opts['no-header'],\n      transpile: opts.transpile,\n      sourceMap: opts.map,\n      inlineMap: opts['inline-map']\n    };\n    if (filename) {\n      if (base) {\n        cwd = process.cwd();\n        jsPath = outputPath(filename, base);\n        jsDir = path.dirname(jsPath);\n        answer = helpers.merge(answer, {\n          jsPath,\n          sourceRoot: path.relative(jsDir, cwd),\n          sourceFiles: [path.relative(cwd, filename)],\n          generatedFile: helpers.baseFileName(jsPath, false, useWinPathSep)\n        });\n      } else {\n        answer = helpers.merge(answer, {\n          sourceRoot: \"\",\n          sourceFiles: [helpers.baseFileName(filename, false, useWinPathSep)],\n          generatedFile: helpers.baseFileName(filename, true, useWinPathSep) + \".js\"\n        });\n      }\n    }\n    return answer;\n  };\n\n  // Start up a new Node.js instance with the arguments in `--nodejs` passed to\n  // the `node` binary, preserving the other options.\n  forkNode = function() {\n    var args, i, len, nodeArgs, p, ref, signal;\n    nodeArgs = opts.nodejs.split(/\\s+/);\n    args = process.argv.slice(1);\n    args.splice(args.indexOf('--nodejs'), 2);\n    p = spawn(process.execPath, nodeArgs.concat(args), {\n      cwd: process.cwd(),\n      env: process.env,\n      stdio: [0, 1, 2]\n    });\n    ref = ['SIGINT', 'SIGTERM'];\n    for (i = 0, len = ref.length; i < len; i++) {\n      signal = ref[i];\n      process.on(signal, (function(signal) {\n        return function() {\n          return p.kill(signal);\n        };\n      })(signal));\n    }\n    return p.on('exit', function(code) {\n      return process.exit(code);\n    });\n  };\n\n  // Print the `--help` usage message and exit. Deprecated switches are not\n  // shown.\n  usage = function() {\n    return printLine(optionParser.help());\n  };\n\n  // Print the `--version` message and exit.\n  version = function() {\n    return printLine(`CoffeeScript version ${CoffeeScript.VERSION}`);\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.260Z",
		"atimeMs": 1551857503260,
		"isfile": true
	},
	"filename": "lib/coffeescript/grammar.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // The CoffeeScript parser is generated by [Jison](https://github.com/zaach/jison)\n  // from this grammar file. Jison is a bottom-up parser generator, similar in\n  // style to [Bison](http://www.gnu.org/software/bison), implemented in JavaScript.\n  // It can recognize [LALR(1), LR(0), SLR(1), and LR(1)](https://en.wikipedia.org/wiki/LR_grammar)\n  // type grammars. To create the Jison parser, we list the pattern to match\n  // on the left-hand side, and the action to take (usually the creation of syntax\n  // tree nodes) on the right. As the parser runs, it\n  // shifts tokens from our token stream, from left to right, and\n  // [attempts to match](https://en.wikipedia.org/wiki/Bottom-up_parsing)\n  // the token sequence against the rules below. When a match can be made, it\n  // reduces into the [nonterminal](https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols)\n  // (the enclosing name at the top), and we proceed from there.\n\n  // If you run the `cake build:parser` command, Jison constructs a parse table\n  // from our rules and saves it into `lib/parser.js`.\n\n  // The only dependency is on the **Jison.Parser**.\n  var Parser, alt, alternatives, grammar, name, o, operators, token, tokens, unwrap;\n\n  ({Parser} = require('jison'));\n\n  // Jison DSL\n  // ---------\n\n  // Since we're going to be wrapped in a function by Jison in any case, if our\n  // action immediately returns a value, we can optimize by removing the function\n  // wrapper and just returning the value directly.\n  unwrap = /^function\\s*\\(\\)\\s*\\{\\s*return\\s*([\\s\\S]*);\\s*\\}/;\n\n  // Our handy DSL for Jison grammar generation, thanks to\n  // [Tim Caswell](https://github.com/creationix). For every rule in the grammar,\n  // we pass the pattern-defining string, the action to run, and extra options,\n  // optionally. If no action is specified, we simply pass the value of the\n  // previous nonterminal.\n  o = function(patternString, action, options) {\n    var getAddDataToNodeFunctionString, match, patternCount, performActionFunctionString;\n    patternString = patternString.replace(/\\s{2,}/g, ' ');\n    patternCount = patternString.split(' ').length;\n    if (action) {\n      action = (match = unwrap.exec(action)) ? match[1] : `(${action}())`;\n      // All runtime functions we need are defined on `yy`\n      action = action.replace(/\\bnew /g, '$&yy.');\n      action = action.replace(/\\b(?:Block\\.wrap|extend)\\b/g, 'yy.$&');\n      // Returns strings of functions to add to `parser.js` which add extra data\n      // that nodes may have, such as comments or location data. Location data\n      // is added to the first parameter passed in, and the parameter is returned.\n      // If the parameter is not a node, it will just be passed through unaffected.\n      getAddDataToNodeFunctionString = function(first, last) {\n        return `yy.addDataToNode(yy, @${first}${(last ? `, @${last}` : '')})`;\n      };\n      action = action.replace(/LOC\\(([0-9]*)\\)/g, getAddDataToNodeFunctionString('$1'));\n      action = action.replace(/LOC\\(([0-9]*),\\s*([0-9]*)\\)/g, getAddDataToNodeFunctionString('$1', '$2'));\n      performActionFunctionString = `$$ = ${getAddDataToNodeFunctionString(1, patternCount)}(${action});`;\n    } else {\n      performActionFunctionString = '$$ = $1;';\n    }\n    return [patternString, performActionFunctionString, options];\n  };\n\n  // Grammatical Rules\n  // -----------------\n\n  // In all of the rules that follow, you'll see the name of the nonterminal as\n  // the key to a list of alternative matches. With each match's action, the\n  // dollar-sign variables are provided by Jison as references to the value of\n  // their numeric position, so in this rule:\n\n  //     'Expression UNLESS Expression'\n\n  // `$1` would be the value of the first `Expression`, `$2` would be the token\n  // for the `UNLESS` terminal, and `$3` would be the value of the second\n  // `Expression`.\n  grammar = {\n    // The **Root** is the top-level node in the syntax tree. Since we parse bottom-up,\n    // all parsing must end here.\n    Root: [\n      o('',\n      function() {\n        return new Block;\n      }),\n      o('Body')\n    ],\n    // Any list of statements and expressions, separated by line breaks or semicolons.\n    Body: [\n      o('Line',\n      function() {\n        return Block.wrap([$1]);\n      }),\n      o('Body TERMINATOR Line',\n      function() {\n        return $1.push($3);\n      }),\n      o('Body TERMINATOR')\n    ],\n    // Block and statements, which make up a line in a body. YieldReturn is a\n    // statement, but not included in Statement because that results in an ambiguous\n    // grammar.\n    Line: [o('Expression'), o('ExpressionLine'), o('Statement'), o('FuncDirective')],\n    FuncDirective: [o('YieldReturn'), o('AwaitReturn')],\n    // Pure statements which cannot be expressions.\n    Statement: [\n      o('Return'),\n      o('STATEMENT',\n      function() {\n        return new StatementLiteral($1);\n      }),\n      o('Import'),\n      o('Export')\n    ],\n    // All the different types of expressions in our language. The basic unit of\n    // CoffeeScript is the **Expression** -- everything that can be an expression\n    // is one. Blocks serve as the building blocks of many other rules, making\n    // them somewhat circular.\n    Expression: [o('Value'), o('Code'), o('Operation'), o('Assign'), o('If'), o('Try'), o('While'), o('For'), o('Switch'), o('Class'), o('Throw'), o('Yield')],\n    // Expressions which are written in single line and would otherwise require being\n    // wrapped in braces: E.g `a = b if do -> f a is 1`, `if f (a) -> a*2 then ...`,\n    // `for x in do (obj) -> f obj when x > 8 then f x`\n    ExpressionLine: [o('CodeLine'), o('IfLine'), o('OperationLine')],\n    Yield: [\n      o('YIELD',\n      function() {\n        return new Op($1,\n      new Value(new Literal('')));\n      }),\n      o('YIELD Expression',\n      function() {\n        return new Op($1,\n      $2);\n      }),\n      o('YIELD INDENT Object OUTDENT',\n      function() {\n        return new Op($1,\n      $3);\n      }),\n      o('YIELD FROM Expression',\n      function() {\n        return new Op($1.concat($2),\n      $3);\n      })\n    ],\n    // An indented block of expressions. Note that the [Rewriter](rewriter.html)\n    // will convert some postfix forms into blocks for us, by adjusting the\n    // token stream.\n    Block: [\n      o('INDENT OUTDENT',\n      function() {\n        return new Block;\n      }),\n      o('INDENT Body OUTDENT',\n      function() {\n        return $2;\n      })\n    ],\n    Identifier: [\n      o('IDENTIFIER',\n      function() {\n        return new IdentifierLiteral($1);\n      }),\n      o('CSX_TAG',\n      function() {\n        return new CSXTag($1);\n      })\n    ],\n    Property: [\n      o('PROPERTY',\n      function() {\n        return new PropertyName($1);\n      })\n    ],\n    // Alphanumerics are separated from the other **Literal** matchers because\n    // they can also serve as keys in object literals.\n    AlphaNumeric: [\n      o('NUMBER',\n      function() {\n        return new NumberLiteral($1);\n      }),\n      o('String')\n    ],\n    String: [\n      o('STRING',\n      function() {\n        return new StringLiteral($1);\n      }),\n      o('STRING_START Body STRING_END',\n      function() {\n        return new StringWithInterpolations($2);\n      })\n    ],\n    Regex: [\n      o('REGEX',\n      function() {\n        return new RegexLiteral($1);\n      }),\n      o('REGEX_START Invocation REGEX_END',\n      function() {\n        return new RegexWithInterpolations($2.args);\n      })\n    ],\n    // All of our immediate values. Generally these can be passed straight\n    // through and printed to JavaScript.\n    Literal: [\n      o('AlphaNumeric'),\n      o('JS',\n      function() {\n        return new PassthroughLiteral($1);\n      }),\n      o('Regex'),\n      o('UNDEFINED',\n      function() {\n        return new UndefinedLiteral($1);\n      }),\n      o('NULL',\n      function() {\n        return new NullLiteral($1);\n      }),\n      o('BOOL',\n      function() {\n        return new BooleanLiteral($1);\n      }),\n      o('INFINITY',\n      function() {\n        return new InfinityLiteral($1);\n      }),\n      o('NAN',\n      function() {\n        return new NaNLiteral($1);\n      })\n    ],\n    // Assignment of a variable, property, or index to a value.\n    Assign: [\n      o('Assignable = Expression',\n      function() {\n        return new Assign($1,\n      $3);\n      }),\n      o('Assignable = TERMINATOR Expression',\n      function() {\n        return new Assign($1,\n      $4);\n      }),\n      o('Assignable = INDENT Expression OUTDENT',\n      function() {\n        return new Assign($1,\n      $4);\n      })\n    ],\n    // Assignment when it happens within an object literal. The difference from\n    // the ordinary **Assign** is that these allow numbers and strings as keys.\n    AssignObj: [\n      o('ObjAssignable',\n      function() {\n        return new Value($1);\n      }),\n      o('ObjRestValue'),\n      o('ObjAssignable : Expression',\n      function() {\n        return new Assign(LOC(1)(new Value($1)),\n      $3,\n      'object',\n      {\n          operatorToken: LOC(2)(new Literal($2))\n        });\n      }),\n      o('ObjAssignable : INDENT Expression OUTDENT',\n      function() {\n        return new Assign(LOC(1)(new Value($1)),\n      $4,\n      'object',\n      {\n          operatorToken: LOC(2)(new Literal($2))\n        });\n      }),\n      o('SimpleObjAssignable = Expression',\n      function() {\n        return new Assign(LOC(1)(new Value($1)),\n      $3,\n      null,\n      {\n          operatorToken: LOC(2)(new Literal($2))\n        });\n      }),\n      o('SimpleObjAssignable = INDENT Expression OUTDENT',\n      function() {\n        return new Assign(LOC(1)(new Value($1)),\n      $4,\n      null,\n      {\n          operatorToken: LOC(2)(new Literal($2))\n        });\n      })\n    ],\n    SimpleObjAssignable: [o('Identifier'), o('Property'), o('ThisProperty')],\n    ObjAssignable: [\n      o('SimpleObjAssignable'),\n      o('[ Expression ]',\n      function() {\n        return new Value(new ComputedPropertyName($2));\n      }),\n      o('AlphaNumeric')\n    ],\n    // Object literal spread properties.\n    ObjRestValue: [\n      o('SimpleObjAssignable ...',\n      function() {\n        return new Splat(new Value($1));\n      }),\n      o('... SimpleObjAssignable',\n      function() {\n        return new Splat(new Value($2));\n      }),\n      o('ObjSpreadExpr ...',\n      function() {\n        return new Splat($1);\n      }),\n      o('... ObjSpreadExpr',\n      function() {\n        return new Splat($2);\n      })\n    ],\n    ObjSpreadExpr: [\n      o('ObjSpreadIdentifier'),\n      o('Object'),\n      o('Parenthetical'),\n      o('Super'),\n      o('This'),\n      o('SUPER Arguments',\n      function() {\n        return new SuperCall(LOC(1)(new Super),\n      $2,\n      false,\n      $1);\n      }),\n      o('SimpleObjAssignable Arguments',\n      function() {\n        return new Call(new Value($1),\n      $2);\n      }),\n      o('ObjSpreadExpr Arguments',\n      function() {\n        return new Call($1,\n      $2);\n      })\n    ],\n    ObjSpreadIdentifier: [\n      o('SimpleObjAssignable ObjSpreadAccessor',\n      function() {\n        return (new Value($1)).add($2);\n      }),\n      o('ObjSpreadExpr ObjSpreadAccessor',\n      function() {\n        return (new Value($1)).add($2);\n      })\n    ],\n    ObjSpreadAccessor: [\n      o('. Property',\n      function() {\n        return new Access($2);\n      }),\n      o('INDEX_START IndexValue INDEX_END',\n      function() {\n        return $2;\n      })\n    ],\n    // A return statement from a function body.\n    Return: [\n      o('RETURN Expression',\n      function() {\n        return new Return($2);\n      }),\n      o('RETURN INDENT Object OUTDENT',\n      function() {\n        return new Return(new Value($3));\n      }),\n      o('RETURN',\n      function() {\n        return new Return;\n      })\n    ],\n    YieldReturn: [\n      o('YIELD RETURN Expression',\n      function() {\n        return new YieldReturn($3);\n      }),\n      o('YIELD RETURN',\n      function() {\n        return new YieldReturn;\n      })\n    ],\n    AwaitReturn: [\n      o('AWAIT RETURN Expression',\n      function() {\n        return new AwaitReturn($3);\n      }),\n      o('AWAIT RETURN',\n      function() {\n        return new AwaitReturn;\n      })\n    ],\n    // The **Code** node is the function literal. It's defined by an indented block\n    // of **Block** preceded by a function arrow, with an optional parameter list.\n    Code: [\n      o('PARAM_START ParamList PARAM_END FuncGlyph Block',\n      function() {\n        return new Code($2,\n      $5,\n      $4,\n      LOC(1)(new Literal($1)));\n      }),\n      o('FuncGlyph Block',\n      function() {\n        return new Code([],\n      $2,\n      $1);\n      })\n    ],\n    // The Codeline is the **Code** node with **Line** instead of indented **Block**.\n    CodeLine: [\n      o('PARAM_START ParamList PARAM_END FuncGlyph Line',\n      function() {\n        return new Code($2,\n      LOC(5)(Block.wrap([$5])),\n      $4,\n      LOC(1)(new Literal($1)));\n      }),\n      o('FuncGlyph Line',\n      function() {\n        return new Code([],\n      LOC(2)(Block.wrap([$2])),\n      $1);\n      })\n    ],\n    // CoffeeScript has two different symbols for functions. `->` is for ordinary\n    // functions, and `=>` is for functions bound to the current value of *this*.\n    FuncGlyph: [\n      o('->',\n      function() {\n        return new FuncGlyph($1);\n      }),\n      o('=>',\n      function() {\n        return new FuncGlyph($1);\n      })\n    ],\n    // An optional, trailing comma.\n    OptComma: [o(''), o(',')],\n    // The list of parameters that a function accepts can be of any length.\n    ParamList: [\n      o('',\n      function() {\n        return [];\n      }),\n      o('Param',\n      function() {\n        return [$1];\n      }),\n      o('ParamList , Param',\n      function() {\n        return $1.concat($3);\n      }),\n      o('ParamList OptComma TERMINATOR Param',\n      function() {\n        return $1.concat($4);\n      }),\n      o('ParamList OptComma INDENT ParamList OptComma OUTDENT',\n      function() {\n        return $1.concat($4);\n      })\n    ],\n    // A single parameter in a function definition can be ordinary, or a splat\n    // that hoovers up the remaining arguments.\n    Param: [\n      o('ParamVar',\n      function() {\n        return new Param($1);\n      }),\n      o('ParamVar ...',\n      function() {\n        return new Param($1,\n      null,\n      true);\n      }),\n      o('... ParamVar',\n      function() {\n        return new Param($2,\n      null,\n      true);\n      }),\n      o('ParamVar = Expression',\n      function() {\n        return new Param($1,\n      $3);\n      }),\n      o('...',\n      function() {\n        return new Expansion;\n      })\n    ],\n    // Function Parameters\n    ParamVar: [o('Identifier'), o('ThisProperty'), o('Array'), o('Object')],\n    // A splat that occurs outside of a parameter list.\n    Splat: [\n      o('Expression ...',\n      function() {\n        return new Splat($1);\n      }),\n      o('... Expression',\n      function() {\n        return new Splat($2);\n      })\n    ],\n    // Variables and properties that can be assigned to.\n    SimpleAssignable: [\n      o('Identifier',\n      function() {\n        return new Value($1);\n      }),\n      o('Value Accessor',\n      function() {\n        return $1.add($2);\n      }),\n      o('Code Accessor',\n      function() {\n        return new Value($1).add($2);\n      }),\n      o('ThisProperty')\n    ],\n    // Everything that can be assigned to.\n    Assignable: [\n      o('SimpleAssignable'),\n      o('Array',\n      function() {\n        return new Value($1);\n      }),\n      o('Object',\n      function() {\n        return new Value($1);\n      })\n    ],\n    // The types of things that can be treated as values -- assigned to, invoked\n    // as functions, indexed into, named as a class, etc.\n    Value: [\n      o('Assignable'),\n      o('Literal',\n      function() {\n        return new Value($1);\n      }),\n      o('Parenthetical',\n      function() {\n        return new Value($1);\n      }),\n      o('Range',\n      function() {\n        return new Value($1);\n      }),\n      o('Invocation',\n      function() {\n        return new Value($1);\n      }),\n      o('This'),\n      o('Super',\n      function() {\n        return new Value($1);\n      })\n    ],\n    // A `super`-based expression that can be used as a value.\n    Super: [\n      o('SUPER . Property',\n      function() {\n        return new Super(LOC(3)(new Access($3)),\n      [],\n      false,\n      $1);\n      }),\n      o('SUPER INDEX_START Expression INDEX_END',\n      function() {\n        return new Super(LOC(3)(new Index($3)),\n      [],\n      false,\n      $1);\n      })\n    ],\n    // The general group of accessors into an object, by property, by prototype\n    // or by array index or slice.\n    Accessor: [\n      o('.  Property',\n      function() {\n        return new Access($2);\n      }),\n      o('?. Property',\n      function() {\n        return new Access($2,\n      'soak');\n      }),\n      o(':: Property',\n      function() {\n        return [LOC(1)(new Access(new PropertyName('prototype'))),\n      LOC(2)(new Access($2))];\n      }),\n      o('?:: Property',\n      function() {\n        return [LOC(1)(new Access(new PropertyName('prototype'),\n      'soak')),\n      LOC(2)(new Access($2))];\n      }),\n      o('::',\n      function() {\n        return new Access(new PropertyName('prototype'));\n      }),\n      o('?::',\n      function() {\n        return new Access(new PropertyName('prototype'),\n      'soak');\n      }),\n      o('Index')\n    ],\n    // Indexing into an object or array using bracket notation.\n    Index: [\n      o('INDEX_START IndexValue INDEX_END',\n      function() {\n        return $2;\n      }),\n      o('INDEX_SOAK  Index',\n      function() {\n        return extend($2,\n      {\n          soak: true\n        });\n      })\n    ],\n    IndexValue: [\n      o('Expression',\n      function() {\n        return new Index($1);\n      }),\n      o('Slice',\n      function() {\n        return new Slice($1);\n      })\n    ],\n    // In CoffeeScript, an object literal is simply a list of assignments.\n    Object: [\n      o('{ AssignList OptComma }',\n      function() {\n        return new Obj($2,\n      $1.generated);\n      })\n    ],\n    // Assignment of properties within an object literal can be separated by\n    // comma, as in JavaScript, or simply by newline.\n    AssignList: [\n      o('',\n      function() {\n        return [];\n      }),\n      o('AssignObj',\n      function() {\n        return [$1];\n      }),\n      o('AssignList , AssignObj',\n      function() {\n        return $1.concat($3);\n      }),\n      o('AssignList OptComma TERMINATOR AssignObj',\n      function() {\n        return $1.concat($4);\n      }),\n      o('AssignList OptComma INDENT AssignList OptComma OUTDENT',\n      function() {\n        return $1.concat($4);\n      })\n    ],\n    // Class definitions have optional bodies of prototype property assignments,\n    // and optional references to the superclass.\n    Class: [\n      o('CLASS',\n      function() {\n        return new Class;\n      }),\n      o('CLASS Block',\n      function() {\n        return new Class(null,\n      null,\n      $2);\n      }),\n      o('CLASS EXTENDS Expression',\n      function() {\n        return new Class(null,\n      $3);\n      }),\n      o('CLASS EXTENDS Expression Block',\n      function() {\n        return new Class(null,\n      $3,\n      $4);\n      }),\n      o('CLASS SimpleAssignable',\n      function() {\n        return new Class($2);\n      }),\n      o('CLASS SimpleAssignable Block',\n      function() {\n        return new Class($2,\n      null,\n      $3);\n      }),\n      o('CLASS SimpleAssignable EXTENDS Expression',\n      function() {\n        return new Class($2,\n      $4);\n      }),\n      o('CLASS SimpleAssignable EXTENDS Expression Block',\n      function() {\n        return new Class($2,\n      $4,\n      $5);\n      })\n    ],\n    Import: [\n      o('IMPORT String',\n      function() {\n        return new ImportDeclaration(null,\n      $2);\n      }),\n      o('IMPORT ImportDefaultSpecifier FROM String',\n      function() {\n        return new ImportDeclaration(new ImportClause($2,\n      null),\n      $4);\n      }),\n      o('IMPORT ImportNamespaceSpecifier FROM String',\n      function() {\n        return new ImportDeclaration(new ImportClause(null,\n      $2),\n      $4);\n      }),\n      o('IMPORT { } FROM String',\n      function() {\n        return new ImportDeclaration(new ImportClause(null,\n      new ImportSpecifierList([])),\n      $5);\n      }),\n      o('IMPORT { ImportSpecifierList OptComma } FROM String',\n      function() {\n        return new ImportDeclaration(new ImportClause(null,\n      new ImportSpecifierList($3)),\n      $7);\n      }),\n      o('IMPORT ImportDefaultSpecifier , ImportNamespaceSpecifier FROM String',\n      function() {\n        return new ImportDeclaration(new ImportClause($2,\n      $4),\n      $6);\n      }),\n      o('IMPORT ImportDefaultSpecifier , { ImportSpecifierList OptComma } FROM String',\n      function() {\n        return new ImportDeclaration(new ImportClause($2,\n      new ImportSpecifierList($5)),\n      $9);\n      })\n    ],\n    ImportSpecifierList: [\n      o('ImportSpecifier',\n      function() {\n        return [$1];\n      }),\n      o('ImportSpecifierList , ImportSpecifier',\n      function() {\n        return $1.concat($3);\n      }),\n      o('ImportSpecifierList OptComma TERMINATOR ImportSpecifier',\n      function() {\n        return $1.concat($4);\n      }),\n      o('INDENT ImportSpecifierList OptComma OUTDENT',\n      function() {\n        return $2;\n      }),\n      o('ImportSpecifierList OptComma INDENT ImportSpecifierList OptComma OUTDENT',\n      function() {\n        return $1.concat($4);\n      })\n    ],\n    ImportSpecifier: [\n      o('Identifier',\n      function() {\n        return new ImportSpecifier($1);\n      }),\n      o('Identifier AS Identifier',\n      function() {\n        return new ImportSpecifier($1,\n      $3);\n      }),\n      o('DEFAULT',\n      function() {\n        return new ImportSpecifier(new Literal($1));\n      }),\n      o('DEFAULT AS Identifier',\n      function() {\n        return new ImportSpecifier(new Literal($1),\n      $3);\n      })\n    ],\n    ImportDefaultSpecifier: [\n      o('Identifier',\n      function() {\n        return new ImportDefaultSpecifier($1);\n      })\n    ],\n    ImportNamespaceSpecifier: [\n      o('IMPORT_ALL AS Identifier',\n      function() {\n        return new ImportNamespaceSpecifier(new Literal($1),\n      $3);\n      })\n    ],\n    Export: [\n      o('EXPORT { }',\n      function() {\n        return new ExportNamedDeclaration(new ExportSpecifierList([]));\n      }),\n      o('EXPORT { ExportSpecifierList OptComma }',\n      function() {\n        return new ExportNamedDeclaration(new ExportSpecifierList($3));\n      }),\n      o('EXPORT Class',\n      function() {\n        return new ExportNamedDeclaration($2);\n      }),\n      o('EXPORT Identifier = Expression',\n      function() {\n        return new ExportNamedDeclaration(new Assign($2,\n      $4,\n      null,\n      {\n          moduleDeclaration: 'export'\n        }));\n      }),\n      o('EXPORT Identifier = TERMINATOR Expression',\n      function() {\n        return new ExportNamedDeclaration(new Assign($2,\n      $5,\n      null,\n      {\n          moduleDeclaration: 'export'\n        }));\n      }),\n      o('EXPORT Identifier = INDENT Expression OUTDENT',\n      function() {\n        return new ExportNamedDeclaration(new Assign($2,\n      $5,\n      null,\n      {\n          moduleDeclaration: 'export'\n        }));\n      }),\n      o('EXPORT DEFAULT Expression',\n      function() {\n        return new ExportDefaultDeclaration($3);\n      }),\n      o('EXPORT DEFAULT INDENT Object OUTDENT',\n      function() {\n        return new ExportDefaultDeclaration(new Value($4));\n      }),\n      o('EXPORT EXPORT_ALL FROM String',\n      function() {\n        return new ExportAllDeclaration(new Literal($2),\n      $4);\n      }),\n      o('EXPORT { ExportSpecifierList OptComma } FROM String',\n      function() {\n        return new ExportNamedDeclaration(new ExportSpecifierList($3),\n      $7);\n      })\n    ],\n    ExportSpecifierList: [\n      o('ExportSpecifier',\n      function() {\n        return [$1];\n      }),\n      o('ExportSpecifierList , ExportSpecifier',\n      function() {\n        return $1.concat($3);\n      }),\n      o('ExportSpecifierList OptComma TERMINATOR ExportSpecifier',\n      function() {\n        return $1.concat($4);\n      }),\n      o('INDENT ExportSpecifierList OptComma OUTDENT',\n      function() {\n        return $2;\n      }),\n      o('ExportSpecifierList OptComma INDENT ExportSpecifierList OptComma OUTDENT',\n      function() {\n        return $1.concat($4);\n      })\n    ],\n    ExportSpecifier: [\n      o('Identifier',\n      function() {\n        return new ExportSpecifier($1);\n      }),\n      o('Identifier AS Identifier',\n      function() {\n        return new ExportSpecifier($1,\n      $3);\n      }),\n      o('Identifier AS DEFAULT',\n      function() {\n        return new ExportSpecifier($1,\n      new Literal($3));\n      }),\n      o('DEFAULT',\n      function() {\n        return new ExportSpecifier(new Literal($1));\n      }),\n      o('DEFAULT AS Identifier',\n      function() {\n        return new ExportSpecifier(new Literal($1),\n      $3);\n      })\n    ],\n    // Ordinary function invocation, or a chained series of calls.\n    Invocation: [\n      o('Value OptFuncExist String',\n      function() {\n        return new TaggedTemplateCall($1,\n      $3,\n      $2);\n      }),\n      o('Value OptFuncExist Arguments',\n      function() {\n        return new Call($1,\n      $3,\n      $2);\n      }),\n      o('SUPER OptFuncExist Arguments',\n      function() {\n        return new SuperCall(LOC(1)(new Super),\n      $3,\n      $2,\n      $1);\n      })\n    ],\n    // An optional existence check on a function.\n    OptFuncExist: [\n      o('',\n      function() {\n        return false;\n      }),\n      o('FUNC_EXIST',\n      function() {\n        return true;\n      })\n    ],\n    // The list of arguments to a function call.\n    Arguments: [\n      o('CALL_START CALL_END',\n      function() {\n        return [];\n      }),\n      o('CALL_START ArgList OptComma CALL_END',\n      function() {\n        return $2;\n      })\n    ],\n    // A reference to the *this* current object.\n    This: [\n      o('THIS',\n      function() {\n        return new Value(new ThisLiteral($1));\n      }),\n      o('@',\n      function() {\n        return new Value(new ThisLiteral($1));\n      })\n    ],\n    // A reference to a property on *this*.\n    ThisProperty: [\n      o('@ Property',\n      function() {\n        return new Value(LOC(1)(new ThisLiteral($1)),\n      [LOC(2)(new Access($2))],\n      'this');\n      })\n    ],\n    // The array literal.\n    Array: [\n      o('[ ]',\n      function() {\n        return new Arr([]);\n      }),\n      o('[ Elisions ]',\n      function() {\n        return new Arr($2);\n      }),\n      o('[ ArgElisionList OptElisions ]',\n      function() {\n        return new Arr([].concat($2,\n      $3));\n      })\n    ],\n    // Inclusive and exclusive range dots.\n    RangeDots: [\n      o('..',\n      function() {\n        return 'inclusive';\n      }),\n      o('...',\n      function() {\n        return 'exclusive';\n      })\n    ],\n    // The CoffeeScript range literal.\n    Range: [\n      o('[ Expression RangeDots Expression ]',\n      function() {\n        return new Range($2,\n      $4,\n      $3);\n      }),\n      o('[ ExpressionLine RangeDots Expression ]',\n      function() {\n        return new Range($2,\n      $4,\n      $3);\n      })\n    ],\n    // Array slice literals.\n    Slice: [\n      o('Expression RangeDots Expression',\n      function() {\n        return new Range($1,\n      $3,\n      $2);\n      }),\n      o('Expression RangeDots',\n      function() {\n        return new Range($1,\n      null,\n      $2);\n      }),\n      o('ExpressionLine RangeDots Expression',\n      function() {\n        return new Range($1,\n      $3,\n      $2);\n      }),\n      o('ExpressionLine RangeDots',\n      function() {\n        return new Range($1,\n      null,\n      $2);\n      }),\n      o('RangeDots Expression',\n      function() {\n        return new Range(null,\n      $2,\n      $1);\n      }),\n      o('RangeDots',\n      function() {\n        return new Range(null,\n      null,\n      $1);\n      })\n    ],\n    // The **ArgList** is the list of objects passed into a function call\n    // (i.e. comma-separated expressions). Newlines work as well.\n    ArgList: [\n      o('Arg',\n      function() {\n        return [$1];\n      }),\n      o('ArgList , Arg',\n      function() {\n        return $1.concat($3);\n      }),\n      o('ArgList OptComma TERMINATOR Arg',\n      function() {\n        return $1.concat($4);\n      }),\n      o('INDENT ArgList OptComma OUTDENT',\n      function() {\n        return $2;\n      }),\n      o('ArgList OptComma INDENT ArgList OptComma OUTDENT',\n      function() {\n        return $1.concat($4);\n      })\n    ],\n    // Valid arguments are Blocks or Splats.\n    Arg: [\n      o('Expression'),\n      o('ExpressionLine'),\n      o('Splat'),\n      o('...',\n      function() {\n        return new Expansion;\n      })\n    ],\n    // The **ArgElisionList** is the list of objects, contents of an array literal\n    // (i.e. comma-separated expressions and elisions). Newlines work as well.\n    ArgElisionList: [\n      o('ArgElision'),\n      o('ArgElisionList , ArgElision',\n      function() {\n        return $1.concat($3);\n      }),\n      o('ArgElisionList OptElisions TERMINATOR ArgElision',\n      function() {\n        return $1.concat($2,\n      $4);\n      }),\n      o('INDENT ArgElisionList OptElisions OUTDENT',\n      function() {\n        return $2.concat($3);\n      }),\n      o('ArgElisionList OptElisions INDENT ArgElisionList OptElisions OUTDENT',\n      function() {\n        return $1.concat($2,\n      $4,\n      $5);\n      })\n    ],\n    ArgElision: [\n      o('Arg',\n      function() {\n        return [$1];\n      }),\n      o('Elisions Arg',\n      function() {\n        return $1.concat($2);\n      })\n    ],\n    OptElisions: [\n      o('OptComma',\n      function() {\n        return [];\n      }),\n      o(', Elisions',\n      function() {\n        return [].concat($2);\n      })\n    ],\n    Elisions: [\n      o('Elision',\n      function() {\n        return [$1];\n      }),\n      o('Elisions Elision',\n      function() {\n        return $1.concat($2);\n      })\n    ],\n    Elision: [\n      o(',',\n      function() {\n        return new Elision;\n      })\n    ],\n    // Just simple, comma-separated, required arguments (no fancy syntax). We need\n    // this to be separate from the **ArgList** for use in **Switch** blocks, where\n    // having the newlines wouldn't make sense.\n    SimpleArgs: [\n      o('Expression'),\n      o('ExpressionLine'),\n      o('SimpleArgs , Expression',\n      function() {\n        return [].concat($1,\n      $3);\n      }),\n      o('SimpleArgs , ExpressionLine',\n      function() {\n        return [].concat($1,\n      $3);\n      })\n    ],\n    // The variants of *try/catch/finally* exception handling blocks.\n    Try: [\n      o('TRY Block',\n      function() {\n        return new Try($2);\n      }),\n      o('TRY Block Catch',\n      function() {\n        return new Try($2,\n      $3[0],\n      $3[1]);\n      }),\n      o('TRY Block FINALLY Block',\n      function() {\n        return new Try($2,\n      null,\n      null,\n      $4);\n      }),\n      o('TRY Block Catch FINALLY Block',\n      function() {\n        return new Try($2,\n      $3[0],\n      $3[1],\n      $5);\n      })\n    ],\n    // A catch clause names its error and runs a block of code.\n    Catch: [\n      o('CATCH Identifier Block',\n      function() {\n        return [$2,\n      $3];\n      }),\n      o('CATCH Object Block',\n      function() {\n        return [LOC(2)(new Value($2)),\n      $3];\n      }),\n      o('CATCH Block',\n      function() {\n        return [null,\n      $2];\n      })\n    ],\n    // Throw an exception object.\n    Throw: [\n      o('THROW Expression',\n      function() {\n        return new Throw($2);\n      }),\n      o('THROW INDENT Object OUTDENT',\n      function() {\n        return new Throw(new Value($3));\n      })\n    ],\n    // Parenthetical expressions. Note that the **Parenthetical** is a **Value**,\n    // not an **Expression**, so if you need to use an expression in a place\n    // where only values are accepted, wrapping it in parentheses will always do\n    // the trick.\n    Parenthetical: [\n      o('( Body )',\n      function() {\n        return new Parens($2);\n      }),\n      o('( INDENT Body OUTDENT )',\n      function() {\n        return new Parens($3);\n      })\n    ],\n    // The condition portion of a while loop.\n    WhileLineSource: [\n      o('WHILE ExpressionLine',\n      function() {\n        return new While($2);\n      }),\n      o('WHILE ExpressionLine WHEN ExpressionLine',\n      function() {\n        return new While($2,\n      {\n          guard: $4\n        });\n      }),\n      o('UNTIL ExpressionLine',\n      function() {\n        return new While($2,\n      {\n          invert: true\n        });\n      }),\n      o('UNTIL ExpressionLine WHEN ExpressionLine',\n      function() {\n        return new While($2,\n      {\n          invert: true,\n          guard: $4\n        });\n      })\n    ],\n    WhileSource: [\n      o('WHILE Expression',\n      function() {\n        return new While($2);\n      }),\n      o('WHILE Expression WHEN Expression',\n      function() {\n        return new While($2,\n      {\n          guard: $4\n        });\n      }),\n      o('WHILE ExpressionLine WHEN Expression',\n      function() {\n        return new While($2,\n      {\n          guard: $4\n        });\n      }),\n      o('UNTIL Expression',\n      function() {\n        return new While($2,\n      {\n          invert: true\n        });\n      }),\n      o('UNTIL Expression WHEN Expression',\n      function() {\n        return new While($2,\n      {\n          invert: true,\n          guard: $4\n        });\n      }),\n      o('UNTIL ExpressionLine WHEN Expression',\n      function() {\n        return new While($2,\n      {\n          invert: true,\n          guard: $4\n        });\n      })\n    ],\n    // The while loop can either be normal, with a block of expressions to execute,\n    // or postfix, with a single expression. There is no do..while.\n    While: [\n      o('WhileSource Block',\n      function() {\n        return $1.addBody($2);\n      }),\n      o('WhileLineSource Block',\n      function() {\n        return $1.addBody($2);\n      }),\n      o('Statement  WhileSource',\n      function() {\n        return $2.addBody(LOC(1)(Block.wrap([$1])));\n      }),\n      o('Expression WhileSource',\n      function() {\n        return $2.addBody(LOC(1)(Block.wrap([$1])));\n      }),\n      o('Loop',\n      function() {\n        return $1;\n      })\n    ],\n    Loop: [\n      o('LOOP Block',\n      function() {\n        return new While(LOC(1)(new BooleanLiteral('true'))).addBody($2);\n      }),\n      o('LOOP Expression',\n      function() {\n        return new While(LOC(1)(new BooleanLiteral('true'))).addBody(LOC(2)(Block.wrap([$2])));\n      })\n    ],\n    // Array, object, and range comprehensions, at the most generic level.\n    // Comprehensions can either be normal, with a block of expressions to execute,\n    // or postfix, with a single expression.\n    For: [\n      o('Statement    ForBody',\n      function() {\n        return $2.addBody($1);\n      }),\n      o('Expression   ForBody',\n      function() {\n        return $2.addBody($1);\n      }),\n      o('ForBody      Block',\n      function() {\n        return $1.addBody($2);\n      }),\n      o('ForLineBody  Block',\n      function() {\n        return $1.addBody($2);\n      })\n    ],\n    ForBody: [\n      o('FOR Range',\n      function() {\n        return new For([],\n      {\n          source: LOC(2)(new Value($2))\n        });\n      }),\n      o('FOR Range BY Expression',\n      function() {\n        return new For([],\n      {\n          source: LOC(2)(new Value($2)),\n          step: $4\n        });\n      }),\n      o('ForStart ForSource',\n      function() {\n        return $1.addSource($2);\n      })\n    ],\n    ForLineBody: [\n      o('FOR Range BY ExpressionLine',\n      function() {\n        return new For([],\n      {\n          source: LOC(2)(new Value($2)),\n          step: $4\n        });\n      }),\n      o('ForStart ForLineSource',\n      function() {\n        return $1.addSource($2);\n      })\n    ],\n    ForStart: [\n      o('FOR ForVariables',\n      function() {\n        return new For([],\n      {\n          name: $2[0],\n          index: $2[1]\n        });\n      }),\n      o('FOR AWAIT ForVariables',\n      function() {\n        var index,\n      name;\n        [name,\n      index] = $3;\n        return new For([],\n      {\n          name,\n          index,\n          await: true,\n          awaitTag: LOC(2)(new Literal($2))\n        });\n      }),\n      o('FOR OWN ForVariables',\n      function() {\n        var index,\n      name;\n        [name,\n      index] = $3;\n        return new For([],\n      {\n          name,\n          index,\n          own: true,\n          ownTag: LOC(2)(new Literal($2))\n        });\n      })\n    ],\n    // An array of all accepted values for a variable inside the loop.\n    // This enables support for pattern matching.\n    ForValue: [\n      o('Identifier'),\n      o('ThisProperty'),\n      o('Array',\n      function() {\n        return new Value($1);\n      }),\n      o('Object',\n      function() {\n        return new Value($1);\n      })\n    ],\n    // An array or range comprehension has variables for the current element\n    // and (optional) reference to the current index. Or, *key, value*, in the case\n    // of object comprehensions.\n    ForVariables: [\n      o('ForValue',\n      function() {\n        return [$1];\n      }),\n      o('ForValue , ForValue',\n      function() {\n        return [$1,\n      $3];\n      })\n    ],\n    // The source of a comprehension is an array or object with an optional guard\n    // clause. If it's an array comprehension, you can also choose to step through\n    // in fixed-size increments.\n    ForSource: [\n      o('FORIN Expression',\n      function() {\n        return {\n          source: $2\n        };\n      }),\n      o('FOROF Expression',\n      function() {\n        return {\n          source: $2,\n          object: true\n        };\n      }),\n      o('FORIN Expression WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4\n        };\n      }),\n      o('FORIN ExpressionLine WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4\n        };\n      }),\n      o('FOROF Expression WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          object: true\n        };\n      }),\n      o('FOROF ExpressionLine WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          object: true\n        };\n      }),\n      o('FORIN Expression BY Expression',\n      function() {\n        return {\n          source: $2,\n          step: $4\n        };\n      }),\n      o('FORIN ExpressionLine BY Expression',\n      function() {\n        return {\n          source: $2,\n          step: $4\n        };\n      }),\n      o('FORIN Expression WHEN Expression BY Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN ExpressionLine WHEN Expression BY Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN Expression WHEN ExpressionLine BY Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN ExpressionLine WHEN ExpressionLine BY Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN Expression BY Expression WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORIN ExpressionLine BY Expression WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORIN Expression BY ExpressionLine WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORIN ExpressionLine BY ExpressionLine WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORFROM Expression',\n      function() {\n        return {\n          source: $2,\n          from: true\n        };\n      }),\n      o('FORFROM Expression WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          from: true\n        };\n      }),\n      o('FORFROM ExpressionLine WHEN Expression',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          from: true\n        };\n      })\n    ],\n    ForLineSource: [\n      o('FORIN ExpressionLine',\n      function() {\n        return {\n          source: $2\n        };\n      }),\n      o('FOROF ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          object: true\n        };\n      }),\n      o('FORIN Expression WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4\n        };\n      }),\n      o('FORIN ExpressionLine WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4\n        };\n      }),\n      o('FOROF Expression WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          object: true\n        };\n      }),\n      o('FOROF ExpressionLine WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          object: true\n        };\n      }),\n      o('FORIN Expression BY ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          step: $4\n        };\n      }),\n      o('FORIN ExpressionLine BY ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          step: $4\n        };\n      }),\n      o('FORIN Expression WHEN Expression BY ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN ExpressionLine WHEN Expression BY ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN Expression WHEN ExpressionLine BY ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN ExpressionLine WHEN ExpressionLine BY ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          step: $6\n        };\n      }),\n      o('FORIN Expression BY Expression WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORIN ExpressionLine BY Expression WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORIN Expression BY ExpressionLine WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORIN ExpressionLine BY ExpressionLine WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          step: $4,\n          guard: $6\n        };\n      }),\n      o('FORFROM ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          from: true\n        };\n      }),\n      o('FORFROM Expression WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          from: true\n        };\n      }),\n      o('FORFROM ExpressionLine WHEN ExpressionLine',\n      function() {\n        return {\n          source: $2,\n          guard: $4,\n          from: true\n        };\n      })\n    ],\n    Switch: [\n      o('SWITCH Expression INDENT Whens OUTDENT',\n      function() {\n        return new Switch($2,\n      $4);\n      }),\n      o('SWITCH ExpressionLine INDENT Whens OUTDENT',\n      function() {\n        return new Switch($2,\n      $4);\n      }),\n      o('SWITCH Expression INDENT Whens ELSE Block OUTDENT',\n      function() {\n        return new Switch($2,\n      $4,\n      $6);\n      }),\n      o('SWITCH ExpressionLine INDENT Whens ELSE Block OUTDENT',\n      function() {\n        return new Switch($2,\n      $4,\n      $6);\n      }),\n      o('SWITCH INDENT Whens OUTDENT',\n      function() {\n        return new Switch(null,\n      $3);\n      }),\n      o('SWITCH INDENT Whens ELSE Block OUTDENT',\n      function() {\n        return new Switch(null,\n      $3,\n      $5);\n      })\n    ],\n    Whens: [\n      o('When'),\n      o('Whens When',\n      function() {\n        return $1.concat($2);\n      })\n    ],\n    // An individual **When** clause, with action.\n    When: [\n      o('LEADING_WHEN SimpleArgs Block',\n      function() {\n        return [[$2,\n      $3]];\n      }),\n      o('LEADING_WHEN SimpleArgs Block TERMINATOR',\n      function() {\n        return [[$2,\n      $3]];\n      })\n    ],\n    // The most basic form of *if* is a condition and an action. The following\n    // if-related rules are broken up along these lines in order to avoid\n    // ambiguity.\n    IfBlock: [\n      o('IF Expression Block',\n      function() {\n        return new If($2,\n      $3,\n      {\n          type: $1\n        });\n      }),\n      o('IfBlock ELSE IF Expression Block',\n      function() {\n        return $1.addElse(LOC(3,\n      5)(new If($4,\n      $5,\n      {\n          type: $3\n        })));\n      })\n    ],\n    // The full complement of *if* expressions, including postfix one-liner\n    // *if* and *unless*.\n    If: [\n      o('IfBlock'),\n      o('IfBlock ELSE Block',\n      function() {\n        return $1.addElse($3);\n      }),\n      o('Statement  POST_IF Expression',\n      function() {\n        return new If($3,\n      LOC(1)(Block.wrap([$1])),\n      {\n          type: $2,\n          statement: true\n        });\n      }),\n      o('Expression POST_IF Expression',\n      function() {\n        return new If($3,\n      LOC(1)(Block.wrap([$1])),\n      {\n          type: $2,\n          statement: true\n        });\n      })\n    ],\n    IfBlockLine: [\n      o('IF ExpressionLine Block',\n      function() {\n        return new If($2,\n      $3,\n      {\n          type: $1\n        });\n      }),\n      o('IfBlockLine ELSE IF ExpressionLine Block',\n      function() {\n        return $1.addElse(LOC(3,\n      5)(new If($4,\n      $5,\n      {\n          type: $3\n        })));\n      })\n    ],\n    IfLine: [\n      o('IfBlockLine'),\n      o('IfBlockLine ELSE Block',\n      function() {\n        return $1.addElse($3);\n      }),\n      o('Statement  POST_IF ExpressionLine',\n      function() {\n        return new If($3,\n      LOC(1)(Block.wrap([$1])),\n      {\n          type: $2,\n          statement: true\n        });\n      }),\n      o('Expression POST_IF ExpressionLine',\n      function() {\n        return new If($3,\n      LOC(1)(Block.wrap([$1])),\n      {\n          type: $2,\n          statement: true\n        });\n      })\n    ],\n    // Arithmetic and logical operators, working on one or more operands.\n    // Here they are grouped by order of precedence. The actual precedence rules\n    // are defined at the bottom of the page. It would be shorter if we could\n    // combine most of these rules into a single generic *Operand OpSymbol Operand*\n    // -type rule, but in order to make the precedence binding possible, separate\n    // rules are necessary.\n    OperationLine: [\n      o('UNARY ExpressionLine',\n      function() {\n        return new Op($1,\n      $2);\n      })\n    ],\n    Operation: [\n      o('UNARY Expression',\n      function() {\n        return new Op($1,\n      $2);\n      }),\n      o('UNARY_MATH Expression',\n      function() {\n        return new Op($1,\n      $2);\n      }),\n      o('-     Expression',\n      (function() {\n        return new Op('-',\n      $2);\n      }),\n      {\n        prec: 'UNARY_MATH'\n      }),\n      o('+     Expression',\n      (function() {\n        return new Op('+',\n      $2);\n      }),\n      {\n        prec: 'UNARY_MATH'\n      }),\n      o('AWAIT Expression',\n      function() {\n        return new Op($1,\n      $2);\n      }),\n      o('AWAIT INDENT Object OUTDENT',\n      function() {\n        return new Op($1,\n      $3);\n      }),\n      o('-- SimpleAssignable',\n      function() {\n        return new Op('--',\n      $2);\n      }),\n      o('++ SimpleAssignable',\n      function() {\n        return new Op('++',\n      $2);\n      }),\n      o('SimpleAssignable --',\n      function() {\n        return new Op('--',\n      $1,\n      null,\n      true);\n      }),\n      o('SimpleAssignable ++',\n      function() {\n        return new Op('++',\n      $1,\n      null,\n      true);\n      }),\n      // [The existential operator](https://coffeescript.org/#existential-operator).\n      o('Expression ?',\n      function() {\n        return new Existence($1);\n      }),\n      o('Expression +  Expression',\n      function() {\n        return new Op('+',\n      $1,\n      $3);\n      }),\n      o('Expression -  Expression',\n      function() {\n        return new Op('-',\n      $1,\n      $3);\n      }),\n      o('Expression MATH     Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression **       Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression SHIFT    Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression COMPARE  Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression &        Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression ^        Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression |        Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression &&       Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression ||       Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression BIN?     Expression',\n      function() {\n        return new Op($2,\n      $1,\n      $3);\n      }),\n      o('Expression RELATION Expression',\n      function() {\n        if ($2.charAt(0) === '!') {\n          return new Op($2.slice(1),\n      $1,\n      $3).invert();\n        } else {\n          return new Op($2,\n      $1,\n      $3);\n        }\n      }),\n      o('SimpleAssignable COMPOUND_ASSIGN Expression',\n      function() {\n        return new Assign($1,\n      $3,\n      $2);\n      }),\n      o('SimpleAssignable COMPOUND_ASSIGN INDENT Expression OUTDENT',\n      function() {\n        return new Assign($1,\n      $4,\n      $2);\n      }),\n      o('SimpleAssignable COMPOUND_ASSIGN TERMINATOR Expression',\n      function() {\n        return new Assign($1,\n      $4,\n      $2);\n      })\n    ]\n  };\n\n  // Precedence\n  // ----------\n\n  // Operators at the top of this list have higher precedence than the ones lower\n  // down. Following these rules is what makes `2 + 3 * 4` parse as:\n\n  //     2 + (3 * 4)\n\n  // And not:\n\n  //     (2 + 3) * 4\n  operators = [['left', '.', '?.', '::', '?::'], ['left', 'CALL_START', 'CALL_END'], ['nonassoc', '++', '--'], ['left', '?'], ['right', 'UNARY'], ['right', 'AWAIT'], ['right', '**'], ['right', 'UNARY_MATH'], ['left', 'MATH'], ['left', '+', '-'], ['left', 'SHIFT'], ['left', 'RELATION'], ['left', 'COMPARE'], ['left', '&'], ['left', '^'], ['left', '|'], ['left', '&&'], ['left', '||'], ['left', 'BIN?'], ['nonassoc', 'INDENT', 'OUTDENT'], ['right', 'YIELD'], ['right', '=', ':', 'COMPOUND_ASSIGN', 'RETURN', 'THROW', 'EXTENDS'], ['right', 'FORIN', 'FOROF', 'FORFROM', 'BY', 'WHEN'], ['right', 'IF', 'ELSE', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'SUPER', 'CLASS', 'IMPORT', 'EXPORT'], ['left', 'POST_IF']];\n\n  // Wrapping Up\n  // -----------\n\n  // Finally, now that we have our **grammar** and our **operators**, we can create\n  // our **Jison.Parser**. We do this by processing all of our rules, recording all\n  // terminals (every symbol which does not appear as the name of a rule above)\n  // as \"tokens\".\n  tokens = [];\n\n  for (name in grammar) {\n    alternatives = grammar[name];\n    grammar[name] = (function() {\n      var i, j, len, len1, ref, results;\n      results = [];\n      for (i = 0, len = alternatives.length; i < len; i++) {\n        alt = alternatives[i];\n        ref = alt[0].split(' ');\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          token = ref[j];\n          if (!grammar[token]) {\n            tokens.push(token);\n          }\n        }\n        if (name === 'Root') {\n          alt[1] = `return ${alt[1]}`;\n        }\n        results.push(alt);\n      }\n      return results;\n    })();\n  }\n\n  // Initialize the **Parser** with our list of terminal **tokens**, our **grammar**\n  // rules, and the name of the root. Reverse the operators because Jison orders\n  // precedence from low to high, and we have it high to low\n  // (as in [Yacc](http://dinosaur.compilertools.net/yacc/index.html)).\n  exports.parser = new Parser({\n    tokens: tokens.join(' '),\n    bnf: grammar,\n    operators: operators.reverse(),\n    startSymbol: 'Root'\n  });\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.260Z",
		"atimeMs": 1551857503260,
		"isfile": true
	},
	"filename": "lib/coffeescript/helpers.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // This file contains the common helper functions that we'd like to share among\n  // the **Lexer**, **Rewriter**, and the **Nodes**. Merge objects, flatten\n  // arrays, count characters, that sort of thing.\n\n  // Peek at the beginning of a given string to see if it matches a sequence.\n  var attachCommentsToNode, buildLocationData, buildLocationHash, buildTokenDataDictionary, extend, flatten, ref, repeat, syntaxErrorToString;\n\n  exports.starts = function(string, literal, start) {\n    return literal === string.substr(start, literal.length);\n  };\n\n  // Peek at the end of a given string to see if it matches a sequence.\n  exports.ends = function(string, literal, back) {\n    var len;\n    len = literal.length;\n    return literal === string.substr(string.length - len - (back || 0), len);\n  };\n\n  // Repeat a string `n` times.\n  exports.repeat = repeat = function(str, n) {\n    var res;\n    // Use clever algorithm to have O(log(n)) string concatenation operations.\n    res = '';\n    while (n > 0) {\n      if (n & 1) {\n        res += str;\n      }\n      n >>>= 1;\n      str += str;\n    }\n    return res;\n  };\n\n  // Trim out all falsy values from an array.\n  exports.compact = function(array) {\n    var i, item, len1, results;\n    results = [];\n    for (i = 0, len1 = array.length; i < len1; i++) {\n      item = array[i];\n      if (item) {\n        results.push(item);\n      }\n    }\n    return results;\n  };\n\n  // Count the number of occurrences of a string in a string.\n  exports.count = function(string, substr) {\n    var num, pos;\n    num = pos = 0;\n    if (!substr.length) {\n      return 1 / 0;\n    }\n    while (pos = 1 + string.indexOf(substr, pos)) {\n      num++;\n    }\n    return num;\n  };\n\n  // Merge objects, returning a fresh copy with attributes from both sides.\n  // Used every time `Base#compile` is called, to allow properties in the\n  // options hash to propagate down the tree without polluting other branches.\n  exports.merge = function(options, overrides) {\n    return extend(extend({}, options), overrides);\n  };\n\n  // Extend a source object with the properties of another object (shallow copy).\n  extend = exports.extend = function(object, properties) {\n    var key, val;\n    for (key in properties) {\n      val = properties[key];\n      object[key] = val;\n    }\n    return object;\n  };\n\n  // Return a flattened version of an array.\n  // Handy for getting a list of `children` from the nodes.\n  exports.flatten = flatten = function(array) {\n    var element, flattened, i, len1;\n    flattened = [];\n    for (i = 0, len1 = array.length; i < len1; i++) {\n      element = array[i];\n      if ('[object Array]' === Object.prototype.toString.call(element)) {\n        flattened = flattened.concat(flatten(element));\n      } else {\n        flattened.push(element);\n      }\n    }\n    return flattened;\n  };\n\n  // Delete a key from an object, returning the value. Useful when a node is\n  // looking for a particular method in an options hash.\n  exports.del = function(obj, key) {\n    var val;\n    val = obj[key];\n    delete obj[key];\n    return val;\n  };\n\n  // Typical Array::some\n  exports.some = (ref = Array.prototype.some) != null ? ref : function(fn) {\n    var e, i, len1, ref1;\n    ref1 = this;\n    for (i = 0, len1 = ref1.length; i < len1; i++) {\n      e = ref1[i];\n      if (fn(e)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Helper function for extracting code from Literate CoffeeScript by stripping\n  // out all non-code blocks, producing a string of CoffeeScript code that can\n  // be compiled ânormally.â\n  exports.invertLiterate = function(code) {\n    var blankLine, i, indented, insideComment, len1, line, listItemStart, out, ref1;\n    out = [];\n    blankLine = /^\\s*$/;\n    indented = /^[\\t ]/;\n    listItemStart = /^(?:\\t?| {0,3})(?:[\\*\\-\\+]|[0-9]{1,9}\\.)[ \\t]/; // Up to one tab, or up to three spaces, or neither;\n    // followed by `*`, `-` or `+`;\n    // or by an integer up to 9 digits long, followed by a period;\n    // followed by a space or a tab.\n    insideComment = false;\n    ref1 = code.split('\\n');\n    for (i = 0, len1 = ref1.length; i < len1; i++) {\n      line = ref1[i];\n      if (blankLine.test(line)) {\n        insideComment = false;\n        out.push(line);\n      } else if (insideComment || listItemStart.test(line)) {\n        insideComment = true;\n        out.push(`# ${line}`);\n      } else if (!insideComment && indented.test(line)) {\n        out.push(line);\n      } else {\n        insideComment = true;\n        out.push(`# ${line}`);\n      }\n    }\n    return out.join('\\n');\n  };\n\n  // Merge two jison-style location data objects together.\n  // If `last` is not provided, this will simply return `first`.\n  buildLocationData = function(first, last) {\n    if (!last) {\n      return first;\n    } else {\n      return {\n        first_line: first.first_line,\n        first_column: first.first_column,\n        last_line: last.last_line,\n        last_column: last.last_column\n      };\n    }\n  };\n\n  buildLocationHash = function(loc) {\n    return `${loc.first_line}x${loc.first_column}-${loc.last_line}x${loc.last_column}`;\n  };\n\n  // Build a dictionary of extra token properties organized by tokensâ locations\n  // used as lookup hashes.\n  buildTokenDataDictionary = function(parserState) {\n    var base, i, len1, ref1, token, tokenData, tokenHash;\n    tokenData = {};\n    ref1 = parserState.parser.tokens;\n    for (i = 0, len1 = ref1.length; i < len1; i++) {\n      token = ref1[i];\n      if (!token.comments) {\n        continue;\n      }\n      tokenHash = buildLocationHash(token[2]);\n      // Multiple tokens might have the same location hash, such as the generated\n      // `JS` tokens added at the start or end of the token stream to hold\n      // comments that start or end a file.\n      if (tokenData[tokenHash] == null) {\n        tokenData[tokenHash] = {};\n      }\n      if (token.comments) { // `comments` is always an array.\n        // For âoverlappingâ tokens, that is tokens with the same location data\n        // and therefore matching `tokenHash`es, merge the comments from both/all\n        // tokens together into one array, even if there are duplicate comments;\n        // they will get sorted out later.\n        ((base = tokenData[tokenHash]).comments != null ? base.comments : base.comments = []).push(...token.comments);\n      }\n    }\n    return tokenData;\n  };\n\n  // This returns a function which takes an object as a parameter, and if that\n  // object is an AST node, updates that object's locationData.\n  // The object is returned either way.\n  exports.addDataToNode = function(parserState, first, last) {\n    return function(obj) {\n      var objHash, ref1;\n      // Add location data.\n      if (((obj != null ? obj.updateLocationDataIfMissing : void 0) != null) && (first != null)) {\n        obj.updateLocationDataIfMissing(buildLocationData(first, last));\n      }\n      // Add comments, building the dictionary of token data if it hasnât been\n      // built yet.\n      if (parserState.tokenData == null) {\n        parserState.tokenData = buildTokenDataDictionary(parserState);\n      }\n      if (obj.locationData != null) {\n        objHash = buildLocationHash(obj.locationData);\n        if (((ref1 = parserState.tokenData[objHash]) != null ? ref1.comments : void 0) != null) {\n          attachCommentsToNode(parserState.tokenData[objHash].comments, obj);\n        }\n      }\n      return obj;\n    };\n  };\n\n  exports.attachCommentsToNode = attachCommentsToNode = function(comments, node) {\n    if ((comments == null) || comments.length === 0) {\n      return;\n    }\n    if (node.comments == null) {\n      node.comments = [];\n    }\n    return node.comments.push(...comments);\n  };\n\n  // Convert jison location data to a string.\n  // `obj` can be a token, or a locationData.\n  exports.locationDataToString = function(obj) {\n    var locationData;\n    if ((\"2\" in obj) && (\"first_line\" in obj[2])) {\n      locationData = obj[2];\n    } else if (\"first_line\" in obj) {\n      locationData = obj;\n    }\n    if (locationData) {\n      return `${locationData.first_line + 1}:${locationData.first_column + 1}-` + `${locationData.last_line + 1}:${locationData.last_column + 1}`;\n    } else {\n      return \"No location data\";\n    }\n  };\n\n  // A `.coffee.md` compatible version of `basename`, that returns the file sans-extension.\n  exports.baseFileName = function(file, stripExt = false, useWinPathSep = false) {\n    var parts, pathSep;\n    pathSep = useWinPathSep ? /\\\\|\\// : /\\//;\n    parts = file.split(pathSep);\n    file = parts[parts.length - 1];\n    if (!(stripExt && file.indexOf('.') >= 0)) {\n      return file;\n    }\n    parts = file.split('.');\n    parts.pop();\n    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {\n      parts.pop();\n    }\n    return parts.join('.');\n  };\n\n  // Determine if a filename represents a CoffeeScript file.\n  exports.isCoffee = function(file) {\n    return /\\.((lit)?coffee|coffee\\.md)$/.test(file);\n  };\n\n  // Determine if a filename represents a Literate CoffeeScript file.\n  exports.isLiterate = function(file) {\n    return /\\.(litcoffee|coffee\\.md)$/.test(file);\n  };\n\n  // Throws a SyntaxError from a given location.\n  // The error's `toString` will return an error message following the \"standard\"\n  // format `<filename>:<line>:<col>: <message>` plus the line with the error and a\n  // marker showing where the error is.\n  exports.throwSyntaxError = function(message, location) {\n    var error;\n    error = new SyntaxError(message);\n    error.location = location;\n    error.toString = syntaxErrorToString;\n    // Instead of showing the compiler's stacktrace, show our custom error message\n    // (this is useful when the error bubbles up in Node.js applications that\n    // compile CoffeeScript for example).\n    error.stack = error.toString();\n    throw error;\n  };\n\n  // Update a compiler SyntaxError with source code information if it didn't have\n  // it already.\n  exports.updateSyntaxError = function(error, code, filename) {\n    // Avoid screwing up the `stack` property of other errors (i.e. possible bugs).\n    if (error.toString === syntaxErrorToString) {\n      error.code || (error.code = code);\n      error.filename || (error.filename = filename);\n      error.stack = error.toString();\n    }\n    return error;\n  };\n\n  syntaxErrorToString = function() {\n    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, start;\n    if (!(this.code && this.location)) {\n      return Error.prototype.toString.call(this);\n    }\n    ({first_line, first_column, last_line, last_column} = this.location);\n    if (last_line == null) {\n      last_line = first_line;\n    }\n    if (last_column == null) {\n      last_column = first_column;\n    }\n    filename = this.filename || '[stdin]';\n    codeLine = this.code.split('\\n')[first_line];\n    start = first_column;\n    // Show only the first line on multi-line errors.\n    end = first_line === last_line ? last_column + 1 : codeLine.length;\n    marker = codeLine.slice(0, start).replace(/[^\\s]/g, ' ') + repeat('^', end - start);\n    // Check to see if we're running on a color-enabled TTY.\n    if (typeof process !== \"undefined\" && process !== null) {\n      colorsEnabled = ((ref1 = process.stdout) != null ? ref1.isTTY : void 0) && !((ref2 = process.env) != null ? ref2.NODE_DISABLE_COLORS : void 0);\n    }\n    if ((ref3 = this.colorful) != null ? ref3 : colorsEnabled) {\n      colorize = function(str) {\n        return `\\x1B[1;31m${str}\\x1B[0m`;\n      };\n      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);\n      marker = colorize(marker);\n    }\n    return `${filename}:${first_line + 1}:${first_column + 1}: error: ${this.message}\\n${codeLine}\\n${marker}`;\n  };\n\n  exports.nameWhitespaceCharacter = function(string) {\n    switch (string) {\n      case ' ':\n        return 'space';\n      case '\\n':\n        return 'newline';\n      case '\\r':\n        return 'carriage return';\n      case '\\t':\n        return 'tab';\n      default:\n        return string;\n    }\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.260Z",
		"atimeMs": 1551857503260,
		"isfile": true
	},
	"filename": "lib/coffeescript/index.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // Node.js Implementation\n  var CoffeeScript, ext, fs, helpers, i, len, path, ref, universalCompile, vm,\n    hasProp = {}.hasOwnProperty;\n\n  CoffeeScript = require('./coffeescript');\n\n  fs = require('fs');\n\n  vm = require('vm');\n\n  path = require('path');\n\n  helpers = CoffeeScript.helpers;\n\n  CoffeeScript.transpile = function(js, options) {\n    var babel;\n    try {\n      babel = require('@babel/core');\n    } catch (error) {\n      try {\n        babel = require('babel-core');\n      } catch (error) {\n        // This error is only for Node, as CLI users will see a different error\n        // earlier if they donât have Babel installed.\n        throw new Error('To use the transpile option, you must have the \\'@babel/core\\' module installed');\n      }\n    }\n    return babel.transform(js, options);\n  };\n\n  // The `compile` method shared by the CLI, Node and browser APIs.\n  universalCompile = CoffeeScript.compile;\n\n  // The `compile` method particular to the Node API.\n  CoffeeScript.compile = function(code, options) {\n    // Pass a reference to Babel into the compiler, so that the transpile option\n    // is available in the Node API. We need to do this so that tools like Webpack\n    // can `require('coffeescript')` and build correctly, without trying to\n    // require Babel.\n    if (options != null ? options.transpile : void 0) {\n      options.transpile.transpile = CoffeeScript.transpile;\n    }\n    return universalCompile.call(CoffeeScript, code, options);\n  };\n\n  // Compile and execute a string of CoffeeScript (on the server), correctly\n  // setting `__filename`, `__dirname`, and relative `require()`.\n  CoffeeScript.run = function(code, options = {}) {\n    var answer, dir, mainModule, ref;\n    mainModule = require.main;\n    // Set the filename.\n    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '<anonymous>';\n    // Clear the module cache.\n    mainModule.moduleCache && (mainModule.moduleCache = {});\n    // Assign paths for node_modules loading\n    dir = options.filename != null ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');\n    mainModule.paths = require('module')._nodeModulePaths(dir);\n    // Save the options for compiling child imports.\n    mainModule.options = options;\n    // Compile.\n    if (!helpers.isCoffee(mainModule.filename) || require.extensions) {\n      answer = CoffeeScript.compile(code, options);\n      code = (ref = answer.js) != null ? ref : answer;\n    }\n    return mainModule._compile(code, mainModule.filename);\n  };\n\n  // Compile and evaluate a string of CoffeeScript (in a Node.js-like environment).\n  // The CoffeeScript REPL uses this to run the input.\n  CoffeeScript.eval = function(code, options = {}) {\n    var Module, _module, _require, createContext, i, isContext, js, k, len, o, r, ref, ref1, ref2, ref3, sandbox, v;\n    if (!(code = code.trim())) {\n      return;\n    }\n    createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;\n    isContext = (ref1 = vm.isContext) != null ? ref1 : function(ctx) {\n      return options.sandbox instanceof createContext().constructor;\n    };\n    if (createContext) {\n      if (options.sandbox != null) {\n        if (isContext(options.sandbox)) {\n          sandbox = options.sandbox;\n        } else {\n          sandbox = createContext();\n          ref2 = options.sandbox;\n          for (k in ref2) {\n            if (!hasProp.call(ref2, k)) continue;\n            v = ref2[k];\n            sandbox[k] = v;\n          }\n        }\n        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;\n      } else {\n        sandbox = global;\n      }\n      sandbox.__filename = options.filename || 'eval';\n      sandbox.__dirname = path.dirname(sandbox.__filename);\n      // define module/require only if they chose not to specify their own\n      if (!(sandbox !== global || sandbox.module || sandbox.require)) {\n        Module = require('module');\n        sandbox.module = _module = new Module(options.modulename || 'eval');\n        sandbox.require = _require = function(path) {\n          return Module._load(path, _module, true);\n        };\n        _module.filename = sandbox.__filename;\n        ref3 = Object.getOwnPropertyNames(require);\n        for (i = 0, len = ref3.length; i < len; i++) {\n          r = ref3[i];\n          if (r !== 'paths' && r !== 'arguments' && r !== 'caller') {\n            _require[r] = require[r];\n          }\n        }\n        // use the same hack node currently uses for their own REPL\n        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());\n        _require.resolve = function(request) {\n          return Module._resolveFilename(request, _module);\n        };\n      }\n    }\n    o = {};\n    for (k in options) {\n      if (!hasProp.call(options, k)) continue;\n      v = options[k];\n      o[k] = v;\n    }\n    o.bare = true; // ensure return value\n    js = CoffeeScript.compile(code, o);\n    if (sandbox === global) {\n      return vm.runInThisContext(js);\n    } else {\n      return vm.runInContext(js, sandbox);\n    }\n  };\n\n  CoffeeScript.register = function() {\n    return require('./register');\n  };\n\n  // Throw error with deprecation warning when depending upon implicit `require.extensions` registration\n  if (require.extensions) {\n    ref = CoffeeScript.FILE_EXTENSIONS;\n    for (i = 0, len = ref.length; i < len; i++) {\n      ext = ref[i];\n      (function(ext) {\n        var base;\n        return (base = require.extensions)[ext] != null ? base[ext] : base[ext] = function() {\n          throw new Error(`Use CoffeeScript.register() or require the coffeescript/register module to require ${ext} files.`);\n        };\n      })(ext);\n    }\n  }\n\n  CoffeeScript._compileFile = function(filename, options = {}) {\n    var answer, err, raw, stripped;\n    raw = fs.readFileSync(filename, 'utf8');\n    // Strip the Unicode byte order mark, if this file begins with one.\n    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;\n    options = Object.assign({}, options, {\n      filename: filename,\n      literate: helpers.isLiterate(filename),\n      sourceFiles: [filename],\n      inlineMap: true // Always generate a source map, so that stack traces line up.\n    });\n    try {\n      answer = CoffeeScript.compile(stripped, options);\n    } catch (error) {\n      err = error;\n      // As the filename and code of a dynamically loaded file will be different\n      // from the original file compiled with CoffeeScript.run, add that\n      // information to error so it can be pretty-printed later.\n      throw helpers.updateSyntaxError(err, stripped, filename);\n    }\n    return answer;\n  };\n\n  module.exports = CoffeeScript;\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.261Z",
		"atimeMs": 1551857503261,
		"isfile": true
	},
	"filename": "lib/coffeescript/lexer.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // The CoffeeScript Lexer. Uses a series of token-matching regexes to attempt\n  // matches against the beginning of the source code. When a match is found,\n  // a token is produced, we consume the match, and start again. Tokens are in the\n  // form:\n\n  //     [tag, value, locationData]\n\n  // where locationData is {first_line, first_column, last_line, last_column}, which is a\n  // format that can be fed directly into [Jison](https://github.com/zaach/jison).  These\n  // are read by jison in the `parser.lexer` function defined in coffeescript.coffee.\n  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARABLE_LEFT_SIDE, COMPARE, COMPOUND_ASSIGN, CSX_ATTRIBUTE, CSX_FRAGMENT_IDENTIFIER, CSX_IDENTIFIER, CSX_INTERPOLATION, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_OMIT, HERE_JSTOKEN, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INSIDE_CSX, INVERSES, JSTOKEN, JS_KEYWORDS, LEADING_BLANK_LINE, LINE_BREAK, LINE_CONTINUER, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, REGEX_INVALID_ESCAPE, RELATION, RESERVED, Rewriter, SHIFT, SIMPLE_STRING_OMIT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_INVALID_ESCAPE, STRING_OMIT, STRING_SINGLE, STRING_START, TRAILING_BLANK_LINE, TRAILING_SPACES, UNARY, UNARY_MATH, UNFINISHED, UNICODE_CODE_POINT_ESCAPE, VALID_FLAGS, WHITESPACE, attachCommentsToNode, compact, count, invertLiterate, isForFrom, isUnassignable, key, locationDataToString, merge, repeat, starts, throwSyntaxError,\n    indexOf = [].indexOf,\n    slice = [].slice;\n\n  ({Rewriter, INVERSES} = require('./rewriter'));\n\n  // Import the helpers we need.\n  ({count, starts, compact, repeat, invertLiterate, merge, attachCommentsToNode, locationDataToString, throwSyntaxError} = require('./helpers'));\n\n  // The Lexer Class\n  // ---------------\n\n  // The Lexer class reads a stream of CoffeeScript and divvies it up into tagged\n  // tokens. Some potential ambiguity in the grammar has been avoided by\n  // pushing some extra smarts into the Lexer.\n  exports.Lexer = Lexer = class Lexer {\n    // **tokenize** is the Lexer's main method. Scan by attempting to match tokens\n    // one at a time, using a regular expression anchored at the start of the\n    // remaining code, or a custom recursive token-matching method\n    // (for interpolations). When the next token has been recorded, we move forward\n    // within the code past the token, and begin again.\n\n    // Each tokenizing method is responsible for returning the number of characters\n    // it has consumed.\n\n    // Before returning the token stream, run it through the [Rewriter](rewriter.html).\n    tokenize(code, opts = {}) {\n      var consumed, end, i, ref;\n      this.literate = opts.literate; // Are we lexing literate CoffeeScript?\n      this.indent = 0; // The current indentation level.\n      this.baseIndent = 0; // The overall minimum indentation level.\n      this.indebt = 0; // The over-indentation at the current level.\n      this.outdebt = 0; // The under-outdentation at the current level.\n      this.indents = []; // The stack of all current indentation levels.\n      this.indentLiteral = ''; // The indentation.\n      this.ends = []; // The stack for pairing up tokens.\n      this.tokens = []; // Stream of parsed tokens in the form `['TYPE', value, location data]`.\n      this.seenFor = false; // Used to recognize `FORIN`, `FOROF` and `FORFROM` tokens.\n      this.seenImport = false; // Used to recognize `IMPORT FROM? AS?` tokens.\n      this.seenExport = false; // Used to recognize `EXPORT FROM? AS?` tokens.\n      this.importSpecifierList = false; // Used to identify when in an `IMPORT {...} FROM? ...`.\n      this.exportSpecifierList = false; // Used to identify when in an `EXPORT {...} FROM? ...`.\n      this.csxDepth = 0; // Used to optimize CSX checks, how deep in CSX we are.\n      this.csxObjAttribute = {}; // Used to detect if CSX attributes is wrapped in {} (<div {props...} />).\n      this.chunkLine = opts.line || 0; // The start line for the current @chunk.\n      this.chunkColumn = opts.column || 0; // The start column of the current @chunk.\n      code = this.clean(code); // The stripped, cleaned original source code.\n      \n      // At every position, run through this list of attempted matches,\n      // short-circuiting if any of them succeed. Their order determines precedence:\n      // `@literalToken` is the fallback catch-all.\n      i = 0;\n      while (this.chunk = code.slice(i)) {\n        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.csxToken() || this.regexToken() || this.jsToken() || this.literalToken();\n        // Update position.\n        [this.chunkLine, this.chunkColumn] = this.getLineAndColumnFromChunk(consumed);\n        i += consumed;\n        if (opts.untilBalanced && this.ends.length === 0) {\n          return {\n            tokens: this.tokens,\n            index: i\n          };\n        }\n      }\n      this.closeIndentation();\n      if (end = this.ends.pop()) {\n        this.error(`missing ${end.tag}`, ((ref = end.origin) != null ? ref : end)[2]);\n      }\n      if (opts.rewrite === false) {\n        return this.tokens;\n      }\n      return (new Rewriter).rewrite(this.tokens);\n    }\n\n    // Preprocess the code to remove leading and trailing whitespace, carriage\n    // returns, etc. If weâre lexing literate CoffeeScript, strip external Markdown\n    // by removing all lines that arenât indented by at least four spaces or a tab.\n    clean(code) {\n      if (code.charCodeAt(0) === BOM) {\n        code = code.slice(1);\n      }\n      code = code.replace(/\\r/g, '').replace(TRAILING_SPACES, '');\n      if (WHITESPACE.test(code)) {\n        code = `\\n${code}`;\n        this.chunkLine--;\n      }\n      if (this.literate) {\n        code = invertLiterate(code);\n      }\n      return code;\n    }\n\n    // Tokenizers\n    // ----------\n\n    // Matches identifying literals: variables, keywords, method names, etc.\n    // Check to ensure that JavaScript reserved words arenât being used as\n    // identifiers. Because CoffeeScript reserves a handful of keywords that are\n    // allowed in JavaScript, weâre careful not to tag them as keywords when\n    // referenced as property names here, so you can still do `jQuery.is()` even\n    // though `is` means `===` otherwise.\n    identifierToken() {\n      var alias, colon, colonOffset, colonToken, id, idLength, inCSXTag, input, match, poppedToken, prev, prevprev, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, regExSuper, regex, sup, tag, tagToken;\n      inCSXTag = this.atCSXTag();\n      regex = inCSXTag ? CSX_ATTRIBUTE : IDENTIFIER;\n      if (!(match = regex.exec(this.chunk))) {\n        return 0;\n      }\n      [input, id, colon] = match;\n      // Preserve length of id for location data\n      idLength = id.length;\n      poppedToken = void 0;\n      if (id === 'own' && this.tag() === 'FOR') {\n        this.token('OWN', id);\n        return id.length;\n      }\n      if (id === 'from' && this.tag() === 'YIELD') {\n        this.token('FROM', id);\n        return id.length;\n      }\n      if (id === 'as' && this.seenImport) {\n        if (this.value() === '*') {\n          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';\n        } else if (ref = this.value(true), indexOf.call(COFFEE_KEYWORDS, ref) >= 0) {\n          prev = this.prev();\n          [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)];\n        }\n        if ((ref1 = this.tag()) === 'DEFAULT' || ref1 === 'IMPORT_ALL' || ref1 === 'IDENTIFIER') {\n          this.token('AS', id);\n          return id.length;\n        }\n      }\n      if (id === 'as' && this.seenExport) {\n        if ((ref2 = this.tag()) === 'IDENTIFIER' || ref2 === 'DEFAULT') {\n          this.token('AS', id);\n          return id.length;\n        }\n        if (ref3 = this.value(true), indexOf.call(COFFEE_KEYWORDS, ref3) >= 0) {\n          prev = this.prev();\n          [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)];\n          this.token('AS', id);\n          return id.length;\n        }\n      }\n      if (id === 'default' && this.seenExport && ((ref4 = this.tag()) === 'EXPORT' || ref4 === 'AS')) {\n        this.token('DEFAULT', id);\n        return id.length;\n      }\n      if (id === 'do' && (regExSuper = /^(\\s*super)(?!\\(\\))/.exec(this.chunk.slice(3)))) {\n        this.token('SUPER', 'super');\n        this.token('CALL_START', '(');\n        this.token('CALL_END', ')');\n        [input, sup] = regExSuper;\n        return sup.length + 3;\n      }\n      prev = this.prev();\n      tag = colon || (prev != null) && (((ref5 = prev[0]) === '.' || ref5 === '?.' || ref5 === '::' || ref5 === '?::') || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';\n      if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {\n        tag = id.toUpperCase();\n        if (tag === 'WHEN' && (ref6 = this.tag(), indexOf.call(LINE_BREAK, ref6) >= 0)) {\n          tag = 'LEADING_WHEN';\n        } else if (tag === 'FOR') {\n          this.seenFor = true;\n        } else if (tag === 'UNLESS') {\n          tag = 'IF';\n        } else if (tag === 'IMPORT') {\n          this.seenImport = true;\n        } else if (tag === 'EXPORT') {\n          this.seenExport = true;\n        } else if (indexOf.call(UNARY, tag) >= 0) {\n          tag = 'UNARY';\n        } else if (indexOf.call(RELATION, tag) >= 0) {\n          if (tag !== 'INSTANCEOF' && this.seenFor) {\n            tag = 'FOR' + tag;\n            this.seenFor = false;\n          } else {\n            tag = 'RELATION';\n            if (this.value() === '!') {\n              poppedToken = this.tokens.pop();\n              id = '!' + id;\n            }\n          }\n        }\n      } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {\n        tag = 'FORFROM';\n        this.seenFor = false;\n      // Throw an error on attempts to use `get` or `set` as keywords, or\n      // what CoffeeScript would normally interpret as calls to functions named\n      // `get` or `set`, i.e. `get({foo: function () {}})`.\n      } else if (tag === 'PROPERTY' && prev) {\n        if (prev.spaced && (ref7 = prev[0], indexOf.call(CALLABLE, ref7) >= 0) && /^[gs]et$/.test(prev[1]) && this.tokens.length > 1 && ((ref8 = this.tokens[this.tokens.length - 2][0]) !== '.' && ref8 !== '?.' && ref8 !== '@')) {\n          this.error(`'${prev[1]}' cannot be used as a keyword, or as a function call without parentheses`, prev[2]);\n        } else if (prev[0] === '.' && this.tokens.length > 1 && (prevprev = this.tokens[this.tokens.length - 2])[0] === 'UNARY' && prevprev[1] === 'new') {\n          prevprev[0] = 'IDENTIFIER';\n        } else if (this.tokens.length > 2) {\n          prevprev = this.tokens[this.tokens.length - 2];\n          if (((ref9 = prev[0]) === '@' || ref9 === 'THIS') && prevprev && prevprev.spaced && /^[gs]et$/.test(prevprev[1]) && ((ref10 = this.tokens[this.tokens.length - 3][0]) !== '.' && ref10 !== '?.' && ref10 !== '@')) {\n            this.error(`'${prevprev[1]}' cannot be used as a keyword, or as a function call without parentheses`, prevprev[2]);\n          }\n        }\n      }\n      if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0) {\n        this.error(`reserved word '${id}'`, {\n          length: id.length\n        });\n      }\n      if (!(tag === 'PROPERTY' || this.exportSpecifierList)) {\n        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {\n          alias = id;\n          id = COFFEE_ALIAS_MAP[id];\n        }\n        tag = (function() {\n          switch (id) {\n            case '!':\n              return 'UNARY';\n            case '==':\n            case '!=':\n              return 'COMPARE';\n            case 'true':\n            case 'false':\n              return 'BOOL';\n            case 'break':\n            case 'continue':\n            case 'debugger':\n              return 'STATEMENT';\n            case '&&':\n            case '||':\n              return id;\n            default:\n              return tag;\n          }\n        })();\n      }\n      tagToken = this.token(tag, id, 0, idLength);\n      if (alias) {\n        tagToken.origin = [tag, alias, tagToken[2]];\n      }\n      if (poppedToken) {\n        [tagToken[2].first_line, tagToken[2].first_column] = [poppedToken[2].first_line, poppedToken[2].first_column];\n      }\n      if (colon) {\n        colonOffset = input.lastIndexOf(inCSXTag ? '=' : ':');\n        colonToken = this.token(':', ':', colonOffset, colon.length);\n        if (inCSXTag) { // used by rewriter\n          colonToken.csxColon = true;\n        }\n      }\n      if (inCSXTag && tag === 'IDENTIFIER' && prev[0] !== ':') {\n        this.token(',', ',', 0, 0, tagToken);\n      }\n      return input.length;\n    }\n\n    // Matches numbers, including decimals, hex, and exponential notation.\n    // Be careful not to interfere with ranges in progress.\n    numberToken() {\n      var base, lexedLength, match, number, numberValue, tag;\n      if (!(match = NUMBER.exec(this.chunk))) {\n        return 0;\n      }\n      number = match[0];\n      lexedLength = number.length;\n      switch (false) {\n        case !/^0[BOX]/.test(number):\n          this.error(`radix prefix in '${number}' must be lowercase`, {\n            offset: 1\n          });\n          break;\n        case !/^(?!0x).*E/.test(number):\n          this.error(`exponential notation in '${number}' must be indicated with a lowercase 'e'`, {\n            offset: number.indexOf('E')\n          });\n          break;\n        case !/^0\\d*[89]/.test(number):\n          this.error(`decimal literal '${number}' must not be prefixed with '0'`, {\n            length: lexedLength\n          });\n          break;\n        case !/^0\\d+/.test(number):\n          this.error(`octal literal '${number}' must be prefixed with '0o'`, {\n            length: lexedLength\n          });\n      }\n      base = (function() {\n        switch (number.charAt(1)) {\n          case 'b':\n            return 2;\n          case 'o':\n            return 8;\n          case 'x':\n            return 16;\n          default:\n            return null;\n        }\n      })();\n      numberValue = base != null ? parseInt(number.slice(2), base) : parseFloat(number);\n      tag = numberValue === 2e308 ? 'INFINITY' : 'NUMBER';\n      this.token(tag, number, 0, lexedLength);\n      return lexedLength;\n    }\n\n    // Matches strings, including multiline strings, as well as heredocs, with or without\n    // interpolation.\n    stringToken() {\n      var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, prev, quote, ref, regex, token, tokens;\n      [quote] = STRING_START.exec(this.chunk) || [];\n      if (!quote) {\n        return 0;\n      }\n      // If the preceding token is `from` and this is an import or export statement,\n      // properly tag the `from`.\n      prev = this.prev();\n      if (prev && this.value() === 'from' && (this.seenImport || this.seenExport)) {\n        prev[0] = 'FROM';\n      }\n      regex = (function() {\n        switch (quote) {\n          case \"'\":\n            return STRING_SINGLE;\n          case '\"':\n            return STRING_DOUBLE;\n          case \"'''\":\n            return HEREDOC_SINGLE;\n          case '\"\"\"':\n            return HEREDOC_DOUBLE;\n        }\n      })();\n      heredoc = quote.length === 3;\n      ({\n        tokens,\n        index: end\n      } = this.matchWithInterpolations(regex, quote));\n      $ = tokens.length - 1;\n      delimiter = quote.charAt(0);\n      if (heredoc) {\n        // Find the smallest indentation. It will be removed from all lines later.\n        indent = null;\n        doc = ((function() {\n          var j, len, results;\n          results = [];\n          for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n            token = tokens[i];\n            if (token[0] === 'NEOSTRING') {\n              results.push(token[1]);\n            }\n          }\n          return results;\n        })()).join('#{}');\n        while (match = HEREDOC_INDENT.exec(doc)) {\n          attempt = match[1];\n          if (indent === null || (0 < (ref = attempt.length) && ref < indent.length)) {\n            indent = attempt;\n          }\n        }\n        if (indent) {\n          indentRegex = RegExp(`\\\\n${indent}`, \"g\");\n        }\n        this.mergeInterpolationTokens(tokens, {delimiter}, (value, i) => {\n          value = this.formatString(value, {\n            delimiter: quote\n          });\n          if (indentRegex) {\n            value = value.replace(indentRegex, '\\n');\n          }\n          if (i === 0) {\n            value = value.replace(LEADING_BLANK_LINE, '');\n          }\n          if (i === $) {\n            value = value.replace(TRAILING_BLANK_LINE, '');\n          }\n          return value;\n        });\n      } else {\n        this.mergeInterpolationTokens(tokens, {delimiter}, (value, i) => {\n          value = this.formatString(value, {\n            delimiter: quote\n          });\n          // Remove indentation from multiline single-quoted strings.\n          value = value.replace(SIMPLE_STRING_OMIT, function(match, offset) {\n            if ((i === 0 && offset === 0) || (i === $ && offset + match.length === value.length)) {\n              return '';\n            } else {\n              return ' ';\n            }\n          });\n          return value;\n        });\n      }\n      if (this.atCSXTag()) {\n        this.token(',', ',', 0, 0, this.prev);\n      }\n      return end;\n    }\n\n    // Matches and consumes comments. The comments are taken out of the token\n    // stream and saved for later, to be reinserted into the output after\n    // everything has been parsed and the JavaScript code generated.\n    commentToken(chunk = this.chunk) {\n      var comment, commentAttachments, content, contents, here, i, match, matchIllegal, newLine, placeholderToken, prev;\n      if (!(match = chunk.match(COMMENT))) {\n        return 0;\n      }\n      [comment, here] = match;\n      contents = null;\n      // Does this comment follow code on the same line?\n      newLine = /^\\s*\\n+\\s*#/.test(comment);\n      if (here) {\n        matchIllegal = HERECOMMENT_ILLEGAL.exec(comment);\n        if (matchIllegal) {\n          this.error(`block comments cannot contain ${matchIllegal[0]}`, {\n            offset: matchIllegal.index,\n            length: matchIllegal[0].length\n          });\n        }\n        // Parse indentation or outdentation as if this block comment didnât exist.\n        chunk = chunk.replace(`###${here}###`, '');\n        // Remove leading newlines, like `Rewriter::removeLeadingNewlines`, to\n        // avoid the creation of unwanted `TERMINATOR` tokens.\n        chunk = chunk.replace(/^\\n+/, '');\n        this.lineToken(chunk);\n        // Pull out the ###-style commentâs content, and format it.\n        content = here;\n        if (indexOf.call(content, '\\n') >= 0) {\n          content = content.replace(RegExp(`\\\\n${repeat(' ', this.indent)}`, \"g\"), '\\n');\n        }\n        contents = [content];\n      } else {\n        // The `COMMENT` regex captures successive line comments as one token.\n        // Remove any leading newlines before the first comment, but preserve\n        // blank lines between line comments.\n        content = comment.replace(/^(\\n*)/, '');\n        content = content.replace(/^([ |\\t]*)#/gm, '');\n        contents = content.split('\\n');\n      }\n      commentAttachments = (function() {\n        var j, len, results;\n        results = [];\n        for (i = j = 0, len = contents.length; j < len; i = ++j) {\n          content = contents[i];\n          results.push({\n            content: content,\n            here: here != null,\n            newLine: newLine || i !== 0 // Line comments after the first one start new lines, by definition.\n          });\n        }\n        return results;\n      })();\n      prev = this.prev();\n      if (!prev) {\n        // If thereâs no previous token, create a placeholder token to attach\n        // this comment to; and follow with a newline.\n        commentAttachments[0].newLine = true;\n        this.lineToken(this.chunk.slice(comment.length));\n        placeholderToken = this.makeToken('JS', '');\n        placeholderToken.generated = true;\n        placeholderToken.comments = commentAttachments;\n        this.tokens.push(placeholderToken);\n        this.newlineToken(0);\n      } else {\n        attachCommentsToNode(commentAttachments, prev);\n      }\n      return comment.length;\n    }\n\n    // Matches JavaScript interpolated directly into the source via backticks.\n    jsToken() {\n      var match, script;\n      if (!(this.chunk.charAt(0) === '`' && (match = HERE_JSTOKEN.exec(this.chunk) || JSTOKEN.exec(this.chunk)))) {\n        return 0;\n      }\n      // Convert escaped backticks to backticks, and escaped backslashes\n      // just before escaped backticks to backslashes\n      script = match[1].replace(/\\\\+(`|$)/g, function(string) {\n        // `string` is always a value like '\\`', '\\\\\\`', '\\\\\\\\\\`', etc.\n        // By reducing it to its latter half, we turn '\\`' to '`', '\\\\\\`' to '\\`', etc.\n        return string.slice(-Math.ceil(string.length / 2));\n      });\n      this.token('JS', script, 0, match[0].length);\n      return match[0].length;\n    }\n\n    // Matches regular expression literals, as well as multiline extended ones.\n    // Lexing regular expressions is difficult to distinguish from division, so we\n    // borrow some basic heuristics from JavaScript and Ruby.\n    regexToken() {\n      var body, closed, comment, comments, end, flags, index, j, len, match, origin, prev, ref, ref1, regex, tokens;\n      switch (false) {\n        case !(match = REGEX_ILLEGAL.exec(this.chunk)):\n          this.error(`regular expressions cannot begin with ${match[2]}`, {\n            offset: match.index + match[1].length\n          });\n          break;\n        case !(match = this.matchWithInterpolations(HEREGEX, '///')):\n          ({tokens, index} = match);\n          comments = this.chunk.slice(0, index).match(/\\s+(#(?!{).*)/g);\n          if (comments) {\n            for (j = 0, len = comments.length; j < len; j++) {\n              comment = comments[j];\n              this.commentToken(comment);\n            }\n          }\n          break;\n        case !(match = REGEX.exec(this.chunk)):\n          [regex, body, closed] = match;\n          this.validateEscapes(body, {\n            isRegex: true,\n            offsetInChunk: 1\n          });\n          index = regex.length;\n          prev = this.prev();\n          if (prev) {\n            if (prev.spaced && (ref = prev[0], indexOf.call(CALLABLE, ref) >= 0)) {\n              if (!closed || POSSIBLY_DIVISION.test(regex)) {\n                return 0;\n              }\n            } else if (ref1 = prev[0], indexOf.call(NOT_REGEX, ref1) >= 0) {\n              return 0;\n            }\n          }\n          if (!closed) {\n            this.error('missing / (unclosed regex)');\n          }\n          break;\n        default:\n          return 0;\n      }\n      [flags] = REGEX_FLAGS.exec(this.chunk.slice(index));\n      end = index + flags.length;\n      origin = this.makeToken('REGEX', null, 0, end);\n      switch (false) {\n        case !!VALID_FLAGS.test(flags):\n          this.error(`invalid regular expression flags ${flags}`, {\n            offset: index,\n            length: flags.length\n          });\n          break;\n        case !(regex || tokens.length === 1):\n          if (body) {\n            body = this.formatRegex(body, {\n              flags,\n              delimiter: '/'\n            });\n          } else {\n            body = this.formatHeregex(tokens[0][1], {flags});\n          }\n          this.token('REGEX', `${this.makeDelimitedLiteral(body, {\n            delimiter: '/'\n          })}${flags}`, 0, end, origin);\n          break;\n        default:\n          this.token('REGEX_START', '(', 0, 0, origin);\n          this.token('IDENTIFIER', 'RegExp', 0, 0);\n          this.token('CALL_START', '(', 0, 0);\n          this.mergeInterpolationTokens(tokens, {\n            delimiter: '\"',\n            double: true\n          }, (str) => {\n            return this.formatHeregex(str, {flags});\n          });\n          if (flags) {\n            this.token(',', ',', index - 1, 0);\n            this.token('STRING', '\"' + flags + '\"', index - 1, flags.length);\n          }\n          this.token(')', ')', end - 1, 0);\n          this.token('REGEX_END', ')', end - 1, 0);\n      }\n      return end;\n    }\n\n    // Matches newlines, indents, and outdents, and determines which is which.\n    // If we can detect that the current line is continued onto the next line,\n    // then the newline is suppressed:\n\n    //     elements\n    //       .each( ... )\n    //       .map( ... )\n\n    // Keeps track of the level of indentation, because a single outdent token\n    // can close multiple indents, so we need to know how far in we happen to be.\n    lineToken(chunk = this.chunk) {\n      var backslash, diff, indent, match, minLiteralLength, newIndentLiteral, noNewlines, prev, size;\n      if (!(match = MULTI_DENT.exec(chunk))) {\n        return 0;\n      }\n      indent = match[0];\n      prev = this.prev();\n      backslash = (prev != null ? prev[0] : void 0) === '\\\\';\n      if (!(backslash && this.seenFor)) {\n        this.seenFor = false;\n      }\n      if (!((backslash && this.seenImport) || this.importSpecifierList)) {\n        this.seenImport = false;\n      }\n      if (!((backslash && this.seenExport) || this.exportSpecifierList)) {\n        this.seenExport = false;\n      }\n      size = indent.length - 1 - indent.lastIndexOf('\\n');\n      noNewlines = this.unfinished();\n      newIndentLiteral = size > 0 ? indent.slice(-size) : '';\n      if (!/^(.?)\\1*$/.exec(newIndentLiteral)) {\n        this.error('mixed indentation', {\n          offset: indent.length\n        });\n        return indent.length;\n      }\n      minLiteralLength = Math.min(newIndentLiteral.length, this.indentLiteral.length);\n      if (newIndentLiteral.slice(0, minLiteralLength) !== this.indentLiteral.slice(0, minLiteralLength)) {\n        this.error('indentation mismatch', {\n          offset: indent.length\n        });\n        return indent.length;\n      }\n      if (size - this.indebt === this.indent) {\n        if (noNewlines) {\n          this.suppressNewlines();\n        } else {\n          this.newlineToken(0);\n        }\n        return indent.length;\n      }\n      if (size > this.indent) {\n        if (noNewlines) {\n          if (!backslash) {\n            this.indebt = size - this.indent;\n          }\n          this.suppressNewlines();\n          return indent.length;\n        }\n        if (!this.tokens.length) {\n          this.baseIndent = this.indent = size;\n          this.indentLiteral = newIndentLiteral;\n          return indent.length;\n        }\n        diff = size - this.indent + this.outdebt;\n        this.token('INDENT', diff, indent.length - size, size);\n        this.indents.push(diff);\n        this.ends.push({\n          tag: 'OUTDENT'\n        });\n        this.outdebt = this.indebt = 0;\n        this.indent = size;\n        this.indentLiteral = newIndentLiteral;\n      } else if (size < this.baseIndent) {\n        this.error('missing indentation', {\n          offset: indent.length\n        });\n      } else {\n        this.indebt = 0;\n        this.outdentToken(this.indent - size, noNewlines, indent.length);\n      }\n      return indent.length;\n    }\n\n    // Record an outdent token or multiple tokens, if we happen to be moving back\n    // inwards past several recorded indents. Sets new @indent value.\n    outdentToken(moveOut, noNewlines, outdentLength) {\n      var decreasedIndent, dent, lastIndent, ref;\n      decreasedIndent = this.indent - moveOut;\n      while (moveOut > 0) {\n        lastIndent = this.indents[this.indents.length - 1];\n        if (!lastIndent) {\n          this.outdebt = moveOut = 0;\n        } else if (this.outdebt && moveOut <= this.outdebt) {\n          this.outdebt -= moveOut;\n          moveOut = 0;\n        } else {\n          dent = this.indents.pop() + this.outdebt;\n          if (outdentLength && (ref = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref) >= 0)) {\n            decreasedIndent -= dent - moveOut;\n            moveOut = dent;\n          }\n          this.outdebt = 0;\n          // pair might call outdentToken, so preserve decreasedIndent\n          this.pair('OUTDENT');\n          this.token('OUTDENT', moveOut, 0, outdentLength);\n          moveOut -= dent;\n        }\n      }\n      if (dent) {\n        this.outdebt -= moveOut;\n      }\n      this.suppressSemicolons();\n      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {\n        this.token('TERMINATOR', '\\n', outdentLength, 0);\n      }\n      this.indent = decreasedIndent;\n      this.indentLiteral = this.indentLiteral.slice(0, decreasedIndent);\n      return this;\n    }\n\n    // Matches and consumes non-meaningful whitespace. Tag the previous token\n    // as being âspacedâ, because there are some cases where it makes a difference.\n    whitespaceToken() {\n      var match, nline, prev;\n      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\\n'))) {\n        return 0;\n      }\n      prev = this.prev();\n      if (prev) {\n        prev[match ? 'spaced' : 'newLine'] = true;\n      }\n      if (match) {\n        return match[0].length;\n      } else {\n        return 0;\n      }\n    }\n\n    // Generate a newline token. Consecutive newlines get merged together.\n    newlineToken(offset) {\n      this.suppressSemicolons();\n      if (this.tag() !== 'TERMINATOR') {\n        this.token('TERMINATOR', '\\n', offset, 0);\n      }\n      return this;\n    }\n\n    // Use a `\\` at a line-ending to suppress the newline.\n    // The slash is removed here once its job is done.\n    suppressNewlines() {\n      var prev;\n      prev = this.prev();\n      if (prev[1] === '\\\\') {\n        if (prev.comments && this.tokens.length > 1) {\n          // `@tokens.length` should be at least 2 (some code, then `\\`).\n          // If something puts a `\\` after nothing, they deserve to lose any\n          // comments that trail it.\n          attachCommentsToNode(prev.comments, this.tokens[this.tokens.length - 2]);\n        }\n        this.tokens.pop();\n      }\n      return this;\n    }\n\n    // CSX is like JSX but for CoffeeScript.\n    csxToken() {\n      var afterTag, colon, csxTag, end, firstChar, id, input, match, origin, prev, prevChar, ref, token, tokens;\n      firstChar = this.chunk[0];\n      // Check the previous token to detect if attribute is spread.\n      prevChar = this.tokens.length > 0 ? this.tokens[this.tokens.length - 1][0] : '';\n      if (firstChar === '<') {\n        match = CSX_IDENTIFIER.exec(this.chunk.slice(1)) || CSX_FRAGMENT_IDENTIFIER.exec(this.chunk.slice(1));\n        // Not the right hand side of an unspaced comparison (i.e. `a<b`).\n        if (!(match && (this.csxDepth > 0 || !(prev = this.prev()) || prev.spaced || (ref = prev[0], indexOf.call(COMPARABLE_LEFT_SIDE, ref) < 0)))) {\n          return 0;\n        }\n        [input, id, colon] = match;\n        origin = this.token('CSX_TAG', id, 1, id.length);\n        this.token('CALL_START', '(');\n        this.token('[', '[');\n        this.ends.push({\n          tag: '/>',\n          origin: origin,\n          name: id\n        });\n        this.csxDepth++;\n        return id.length + 1;\n      } else if (csxTag = this.atCSXTag()) {\n        if (this.chunk.slice(0, 2) === '/>') {\n          this.pair('/>');\n          this.token(']', ']', 0, 2);\n          this.token('CALL_END', ')', 0, 2);\n          this.csxDepth--;\n          return 2;\n        } else if (firstChar === '{') {\n          if (prevChar === ':') {\n            token = this.token('(', '(');\n            this.csxObjAttribute[this.csxDepth] = false;\n          } else {\n            token = this.token('{', '{');\n            this.csxObjAttribute[this.csxDepth] = true;\n          }\n          this.ends.push({\n            tag: '}',\n            origin: token\n          });\n          return 1;\n        } else if (firstChar === '>') {\n          // Ignore terminators inside a tag.\n          this.pair('/>'); // As if the current tag was self-closing.\n          origin = this.token(']', ']');\n          this.token(',', ',');\n          ({\n            tokens,\n            index: end\n          } = this.matchWithInterpolations(INSIDE_CSX, '>', '</', CSX_INTERPOLATION));\n          this.mergeInterpolationTokens(tokens, {\n            delimiter: '\"'\n          }, (value, i) => {\n            return this.formatString(value, {\n              delimiter: '>'\n            });\n          });\n          match = CSX_IDENTIFIER.exec(this.chunk.slice(end)) || CSX_FRAGMENT_IDENTIFIER.exec(this.chunk.slice(end));\n          if (!match || match[1] !== csxTag.name) {\n            this.error(`expected corresponding CSX closing tag for ${csxTag.name}`, csxTag.origin[2]);\n          }\n          afterTag = end + csxTag.name.length;\n          if (this.chunk[afterTag] !== '>') {\n            this.error(\"missing closing > after tag name\", {\n              offset: afterTag,\n              length: 1\n            });\n          }\n          // +1 for the closing `>`.\n          this.token('CALL_END', ')', end, csxTag.name.length + 1);\n          this.csxDepth--;\n          return afterTag + 1;\n        } else {\n          return 0;\n        }\n      } else if (this.atCSXTag(1)) {\n        if (firstChar === '}') {\n          this.pair(firstChar);\n          if (this.csxObjAttribute[this.csxDepth]) {\n            this.token('}', '}');\n            this.csxObjAttribute[this.csxDepth] = false;\n          } else {\n            this.token(')', ')');\n          }\n          this.token(',', ',');\n          return 1;\n        } else {\n          return 0;\n        }\n      } else {\n        return 0;\n      }\n    }\n\n    atCSXTag(depth = 0) {\n      var i, last, ref;\n      if (this.csxDepth === 0) {\n        return false;\n      }\n      i = this.ends.length - 1;\n      while (((ref = this.ends[i]) != null ? ref.tag : void 0) === 'OUTDENT' || depth-- > 0) { // Ignore indents.\n        i--;\n      }\n      last = this.ends[i];\n      return (last != null ? last.tag : void 0) === '/>' && last;\n    }\n\n    // We treat all other single characters as a token. E.g.: `( ) , . !`\n    // Multi-character operators are also literal tokens, so that Jison can assign\n    // the proper order of operations. There are some symbols that we tag specially\n    // here. `;` and newlines are both treated as a `TERMINATOR`, we distinguish\n    // parentheses that indicate a method call from regular parentheses, and so on.\n    literalToken() {\n      var match, message, origin, prev, ref, ref1, ref2, ref3, ref4, skipToken, tag, token, value;\n      if (match = OPERATOR.exec(this.chunk)) {\n        [value] = match;\n        if (CODE.test(value)) {\n          this.tagParameters();\n        }\n      } else {\n        value = this.chunk.charAt(0);\n      }\n      tag = value;\n      prev = this.prev();\n      if (prev && indexOf.call(['=', ...COMPOUND_ASSIGN], value) >= 0) {\n        skipToken = false;\n        if (value === '=' && ((ref = prev[1]) === '||' || ref === '&&') && !prev.spaced) {\n          prev[0] = 'COMPOUND_ASSIGN';\n          prev[1] += '=';\n          prev = this.tokens[this.tokens.length - 2];\n          skipToken = true;\n        }\n        if (prev && prev[0] !== 'PROPERTY') {\n          origin = (ref1 = prev.origin) != null ? ref1 : prev;\n          message = isUnassignable(prev[1], origin[1]);\n          if (message) {\n            this.error(message, origin[2]);\n          }\n        }\n        if (skipToken) {\n          return value.length;\n        }\n      }\n      if (value === '{' && this.seenImport) {\n        this.importSpecifierList = true;\n      } else if (this.importSpecifierList && value === '}') {\n        this.importSpecifierList = false;\n      } else if (value === '{' && (prev != null ? prev[0] : void 0) === 'EXPORT') {\n        this.exportSpecifierList = true;\n      } else if (this.exportSpecifierList && value === '}') {\n        this.exportSpecifierList = false;\n      }\n      if (value === ';') {\n        if (ref2 = prev != null ? prev[0] : void 0, indexOf.call(['=', ...UNFINISHED], ref2) >= 0) {\n          this.error('unexpected ;');\n        }\n        this.seenFor = this.seenImport = this.seenExport = false;\n        tag = 'TERMINATOR';\n      } else if (value === '*' && (prev != null ? prev[0] : void 0) === 'EXPORT') {\n        tag = 'EXPORT_ALL';\n      } else if (indexOf.call(MATH, value) >= 0) {\n        tag = 'MATH';\n      } else if (indexOf.call(COMPARE, value) >= 0) {\n        tag = 'COMPARE';\n      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {\n        tag = 'COMPOUND_ASSIGN';\n      } else if (indexOf.call(UNARY, value) >= 0) {\n        tag = 'UNARY';\n      } else if (indexOf.call(UNARY_MATH, value) >= 0) {\n        tag = 'UNARY_MATH';\n      } else if (indexOf.call(SHIFT, value) >= 0) {\n        tag = 'SHIFT';\n      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {\n        tag = 'BIN?';\n      } else if (prev) {\n        if (value === '(' && !prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) {\n          if (prev[0] === '?') {\n            prev[0] = 'FUNC_EXIST';\n          }\n          tag = 'CALL_START';\n        } else if (value === '[' && (((ref4 = prev[0], indexOf.call(INDEXABLE, ref4) >= 0) && !prev.spaced) || (prev[0] === '::'))) { // `.prototype` canât be a method you can call.\n          tag = 'INDEX_START';\n          switch (prev[0]) {\n            case '?':\n              prev[0] = 'INDEX_SOAK';\n          }\n        }\n      }\n      token = this.makeToken(tag, value);\n      switch (value) {\n        case '(':\n        case '{':\n        case '[':\n          this.ends.push({\n            tag: INVERSES[value],\n            origin: token\n          });\n          break;\n        case ')':\n        case '}':\n        case ']':\n          this.pair(value);\n      }\n      this.tokens.push(this.makeToken(tag, value));\n      return value.length;\n    }\n\n    // Token Manipulators\n    // ------------------\n\n    // A source of ambiguity in our grammar used to be parameter lists in function\n    // definitions versus argument lists in function calls. Walk backwards, tagging\n    // parameters specially in order to make things easier for the parser.\n    tagParameters() {\n      var i, paramEndToken, stack, tok, tokens;\n      if (this.tag() !== ')') {\n        return this;\n      }\n      stack = [];\n      ({tokens} = this);\n      i = tokens.length;\n      paramEndToken = tokens[--i];\n      paramEndToken[0] = 'PARAM_END';\n      while (tok = tokens[--i]) {\n        switch (tok[0]) {\n          case ')':\n            stack.push(tok);\n            break;\n          case '(':\n          case 'CALL_START':\n            if (stack.length) {\n              stack.pop();\n            } else if (tok[0] === '(') {\n              tok[0] = 'PARAM_START';\n              return this;\n            } else {\n              paramEndToken[0] = 'CALL_END';\n              return this;\n            }\n        }\n      }\n      return this;\n    }\n\n    // Close up all remaining open blocks at the end of the file.\n    closeIndentation() {\n      return this.outdentToken(this.indent);\n    }\n\n    // Match the contents of a delimited token and expand variables and expressions\n    // inside it using Ruby-like notation for substitution of arbitrary\n    // expressions.\n\n    //     \"Hello #{name.capitalize()}.\"\n\n    // If it encounters an interpolation, this method will recursively create a new\n    // Lexer and tokenize until the `{` of `#{` is balanced with a `}`.\n\n    //  - `regex` matches the contents of a token (but not `delimiter`, and not\n    //    `#{` if interpolations are desired).\n    //  - `delimiter` is the delimiter of the token. Examples are `'`, `\"`, `'''`,\n    //    `\"\"\"` and `///`.\n    //  - `closingDelimiter` is different from `delimiter` only in CSX\n    //  - `interpolators` matches the start of an interpolation, for CSX it's both\n    //    `{` and `<` (i.e. nested CSX tag)\n\n    // This method allows us to have strings within interpolations within strings,\n    // ad infinitum.\n    matchWithInterpolations(regex, delimiter, closingDelimiter, interpolators) {\n      var braceInterpolator, close, column, firstToken, index, interpolationOffset, interpolator, lastToken, line, match, nested, offsetInChunk, open, ref, ref1, rest, str, strPart, tokens;\n      if (closingDelimiter == null) {\n        closingDelimiter = delimiter;\n      }\n      if (interpolators == null) {\n        interpolators = /^#\\{/;\n      }\n      tokens = [];\n      offsetInChunk = delimiter.length;\n      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {\n        return null;\n      }\n      str = this.chunk.slice(offsetInChunk);\n      while (true) {\n        [strPart] = regex.exec(str);\n        this.validateEscapes(strPart, {\n          isRegex: delimiter.charAt(0) === '/',\n          offsetInChunk\n        });\n        // Push a fake `'NEOSTRING'` token, which will get turned into a real string later.\n        tokens.push(this.makeToken('NEOSTRING', strPart, offsetInChunk));\n        str = str.slice(strPart.length);\n        offsetInChunk += strPart.length;\n        if (!(match = interpolators.exec(str))) {\n          break;\n        }\n        [interpolator] = match;\n        // To remove the `#` in `#{`.\n        interpolationOffset = interpolator.length - 1;\n        [line, column] = this.getLineAndColumnFromChunk(offsetInChunk + interpolationOffset);\n        rest = str.slice(interpolationOffset);\n        ({\n          tokens: nested,\n          index\n        } = new Lexer().tokenize(rest, {\n          line: line,\n          column: column,\n          untilBalanced: true\n        }));\n        // Account for the `#` in `#{`.\n        index += interpolationOffset;\n        braceInterpolator = str[index - 1] === '}';\n        if (braceInterpolator) {\n          // Turn the leading and trailing `{` and `}` into parentheses. Unnecessary\n          // parentheses will be removed later.\n          [open] = nested, [close] = slice.call(nested, -1);\n          open[0] = open[1] = '(';\n          close[0] = close[1] = ')';\n          close.origin = ['', 'end of interpolation', close[2]];\n        }\n        if (((ref = nested[1]) != null ? ref[0] : void 0) === 'TERMINATOR') {\n          // Remove leading `'TERMINATOR'` (if any).\n          nested.splice(1, 1);\n        }\n        if (((ref1 = nested[nested.length - 3]) != null ? ref1[0] : void 0) === 'INDENT' && nested[nested.length - 2][0] === 'OUTDENT') {\n          // Remove trailing `'INDENT'/'OUTDENT'` pair (if any).\n          nested.splice(-3, 2);\n        }\n        if (!braceInterpolator) {\n          // We are not using `{` and `}`, so wrap the interpolated tokens instead.\n          open = this.makeToken('(', '(', offsetInChunk, 0);\n          close = this.makeToken(')', ')', offsetInChunk + index, 0);\n          nested = [open, ...nested, close];\n        }\n        // Push a fake `'TOKENS'` token, which will get turned into real tokens later.\n        tokens.push(['TOKENS', nested]);\n        str = str.slice(index);\n        offsetInChunk += index;\n      }\n      if (str.slice(0, closingDelimiter.length) !== closingDelimiter) {\n        this.error(`missing ${closingDelimiter}`, {\n          length: delimiter.length\n        });\n      }\n      [firstToken] = tokens, [lastToken] = slice.call(tokens, -1);\n      firstToken[2].first_column -= delimiter.length;\n      if (lastToken[1].substr(-1) === '\\n') {\n        lastToken[2].last_line += 1;\n        lastToken[2].last_column = closingDelimiter.length - 1;\n      } else {\n        lastToken[2].last_column += closingDelimiter.length;\n      }\n      if (lastToken[1].length === 0) {\n        lastToken[2].last_column -= 1;\n      }\n      return {\n        tokens,\n        index: offsetInChunk + closingDelimiter.length\n      };\n    }\n\n    // Merge the array `tokens` of the fake token types `'TOKENS'` and `'NEOSTRING'`\n    // (as returned by `matchWithInterpolations`) into the token stream. The value\n    // of `'NEOSTRING'`s are converted using `fn` and turned into strings using\n    // `options` first.\n    mergeInterpolationTokens(tokens, options, fn) {\n      var converted, firstEmptyStringIndex, firstIndex, i, j, k, lastToken, len, len1, locationToken, lparen, placeholderToken, plusToken, rparen, tag, token, tokensToPush, val, value;\n      if (tokens.length > 1) {\n        lparen = this.token('STRING_START', '(', 0, 0);\n      }\n      firstIndex = this.tokens.length;\n      for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n        token = tokens[i];\n        [tag, value] = token;\n        switch (tag) {\n          case 'TOKENS':\n            if (value.length === 2) {\n              if (!(value[0].comments || value[1].comments)) {\n                // Optimize out empty interpolations (an empty pair of parentheses).\n                continue;\n              }\n              // There are comments (and nothing else) in this interpolation.\n              if (this.csxDepth === 0) {\n                // This is an interpolated string, not a CSX tag; and for whatever\n                // reason `` `a${/*test*/}b` `` is invalid JS. So compile to\n                // `` `a${/*test*/''}b` `` instead.\n                placeholderToken = this.makeToken('STRING', \"''\");\n              } else {\n                placeholderToken = this.makeToken('JS', '');\n              }\n              // Use the same location data as the first parenthesis.\n              placeholderToken[2] = value[0][2];\n              for (k = 0, len1 = value.length; k < len1; k++) {\n                val = value[k];\n                if (!val.comments) {\n                  continue;\n                }\n                if (placeholderToken.comments == null) {\n                  placeholderToken.comments = [];\n                }\n                placeholderToken.comments.push(...val.comments);\n              }\n              value.splice(1, 0, placeholderToken);\n            }\n            // Push all the tokens in the fake `'TOKENS'` token. These already have\n            // sane location data.\n            locationToken = value[0];\n            tokensToPush = value;\n            break;\n          case 'NEOSTRING':\n            // Convert `'NEOSTRING'` into `'STRING'`.\n            converted = fn.call(this, token[1], i);\n            // Optimize out empty strings. We ensure that the tokens stream always\n            // starts with a string token, though, to make sure that the result\n            // really is a string.\n            if (converted.length === 0) {\n              if (i === 0) {\n                firstEmptyStringIndex = this.tokens.length;\n              } else {\n                continue;\n              }\n            }\n            // However, there is one case where we can optimize away a starting\n            // empty string.\n            if (i === 2 && (firstEmptyStringIndex != null)) {\n              this.tokens.splice(firstEmptyStringIndex, 2); // Remove empty string and the plus.\n            }\n            token[0] = 'STRING';\n            token[1] = this.makeDelimitedLiteral(converted, options);\n            locationToken = token;\n            tokensToPush = [token];\n        }\n        if (this.tokens.length > firstIndex) {\n          // Create a 0-length `+` token.\n          plusToken = this.token('+', '+');\n          plusToken[2] = {\n            first_line: locationToken[2].first_line,\n            first_column: locationToken[2].first_column,\n            last_line: locationToken[2].first_line,\n            last_column: locationToken[2].first_column\n          };\n        }\n        this.tokens.push(...tokensToPush);\n      }\n      if (lparen) {\n        [lastToken] = slice.call(tokens, -1);\n        lparen.origin = [\n          'STRING',\n          null,\n          {\n            first_line: lparen[2].first_line,\n            first_column: lparen[2].first_column,\n            last_line: lastToken[2].last_line,\n            last_column: lastToken[2].last_column\n          }\n        ];\n        lparen[2] = lparen.origin[2];\n        rparen = this.token('STRING_END', ')');\n        return rparen[2] = {\n          first_line: lastToken[2].last_line,\n          first_column: lastToken[2].last_column,\n          last_line: lastToken[2].last_line,\n          last_column: lastToken[2].last_column\n        };\n      }\n    }\n\n    // Pairs up a closing token, ensuring that all listed pairs of tokens are\n    // correctly balanced throughout the course of the token stream.\n    pair(tag) {\n      var lastIndent, prev, ref, ref1, wanted;\n      ref = this.ends, [prev] = slice.call(ref, -1);\n      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {\n        if ('OUTDENT' !== wanted) {\n          this.error(`unmatched ${tag}`);\n        }\n        // Auto-close `INDENT` to support syntax like this:\n\n        //     el.click((event) ->\n        //       el.hide())\n\n        ref1 = this.indents, [lastIndent] = slice.call(ref1, -1);\n        this.outdentToken(lastIndent, true);\n        return this.pair(tag);\n      }\n      return this.ends.pop();\n    }\n\n    // Helpers\n    // -------\n\n    // Returns the line and column number from an offset into the current chunk.\n\n    // `offset` is a number of characters into `@chunk`.\n    getLineAndColumnFromChunk(offset) {\n      var column, lastLine, lineCount, ref, string;\n      if (offset === 0) {\n        return [this.chunkLine, this.chunkColumn];\n      }\n      if (offset >= this.chunk.length) {\n        string = this.chunk;\n      } else {\n        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);\n      }\n      lineCount = count(string, '\\n');\n      column = this.chunkColumn;\n      if (lineCount > 0) {\n        ref = string.split('\\n'), [lastLine] = slice.call(ref, -1);\n        column = lastLine.length;\n      } else {\n        column += string.length;\n      }\n      return [this.chunkLine + lineCount, column];\n    }\n\n    // Same as `token`, except this just returns the token without adding it\n    // to the results.\n    makeToken(tag, value, offsetInChunk = 0, length = value.length, origin) {\n      var lastCharacter, locationData, token;\n      locationData = {};\n      [locationData.first_line, locationData.first_column] = this.getLineAndColumnFromChunk(offsetInChunk);\n      // Use length - 1 for the final offset - weâre supplying the last_line and the last_column,\n      // so if last_column == first_column, then weâre looking at a character of length 1.\n      lastCharacter = length > 0 ? length - 1 : 0;\n      [locationData.last_line, locationData.last_column] = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter);\n      token = [tag, value, locationData];\n      if (origin) {\n        token.origin = origin;\n      }\n      return token;\n    }\n\n    // Add a token to the results.\n    // `offset` is the offset into the current `@chunk` where the token starts.\n    // `length` is the length of the token in the `@chunk`, after the offset.  If\n    // not specified, the length of `value` will be used.\n\n    // Returns the new token.\n    token(tag, value, offsetInChunk, length, origin) {\n      var token;\n      token = this.makeToken(tag, value, offsetInChunk, length, origin);\n      this.tokens.push(token);\n      return token;\n    }\n\n    // Peek at the last tag in the token stream.\n    tag() {\n      var ref, token;\n      ref = this.tokens, [token] = slice.call(ref, -1);\n      return token != null ? token[0] : void 0;\n    }\n\n    // Peek at the last value in the token stream.\n    value(useOrigin = false) {\n      var ref, ref1, token;\n      ref = this.tokens, [token] = slice.call(ref, -1);\n      if (useOrigin && ((token != null ? token.origin : void 0) != null)) {\n        return (ref1 = token.origin) != null ? ref1[1] : void 0;\n      } else {\n        return token != null ? token[1] : void 0;\n      }\n    }\n\n    // Get the previous token in the token stream.\n    prev() {\n      return this.tokens[this.tokens.length - 1];\n    }\n\n    // Are we in the midst of an unfinished expression?\n    unfinished() {\n      var ref;\n      return LINE_CONTINUER.test(this.chunk) || (ref = this.tag(), indexOf.call(UNFINISHED, ref) >= 0);\n    }\n\n    formatString(str, options) {\n      return this.replaceUnicodeCodePointEscapes(str.replace(STRING_OMIT, '$1'), options);\n    }\n\n    formatHeregex(str, options) {\n      return this.formatRegex(str.replace(HEREGEX_OMIT, '$1$2'), merge(options, {\n        delimiter: '///'\n      }));\n    }\n\n    formatRegex(str, options) {\n      return this.replaceUnicodeCodePointEscapes(str, options);\n    }\n\n    unicodeCodePointToUnicodeEscapes(codePoint) {\n      var high, low, toUnicodeEscape;\n      toUnicodeEscape = function(val) {\n        var str;\n        str = val.toString(16);\n        return `\\\\u${repeat('0', 4 - str.length)}${str}`;\n      };\n      if (codePoint < 0x10000) {\n        return toUnicodeEscape(codePoint);\n      }\n      // surrogate pair\n      high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n      low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n      return `${toUnicodeEscape(high)}${toUnicodeEscape(low)}`;\n    }\n\n    // Replace `\\u{...}` with `\\uxxxx[\\uxxxx]` in regexes without `u` flag\n    replaceUnicodeCodePointEscapes(str, options) {\n      var shouldReplace;\n      shouldReplace = (options.flags != null) && indexOf.call(options.flags, 'u') < 0;\n      return str.replace(UNICODE_CODE_POINT_ESCAPE, (match, escapedBackslash, codePointHex, offset) => {\n        var codePointDecimal;\n        if (escapedBackslash) {\n          return escapedBackslash;\n        }\n        codePointDecimal = parseInt(codePointHex, 16);\n        if (codePointDecimal > 0x10ffff) {\n          this.error(\"unicode code point escapes greater than \\\\u{10ffff} are not allowed\", {\n            offset: offset + options.delimiter.length,\n            length: codePointHex.length + 4\n          });\n        }\n        if (!shouldReplace) {\n          return match;\n        }\n        return this.unicodeCodePointToUnicodeEscapes(codePointDecimal);\n      });\n    }\n\n    // Validates escapes in strings and regexes.\n    validateEscapes(str, options = {}) {\n      var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref, unicode, unicodeCodePoint;\n      invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;\n      match = invalidEscapeRegex.exec(str);\n      if (!match) {\n        return;\n      }\n      match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];\n      message = octal ? \"octal escape sequences are not allowed\" : \"invalid escape sequence\";\n      invalidEscape = `\\\\${octal || hex || unicodeCodePoint || unicode}`;\n      return this.error(`${message} ${invalidEscape}`, {\n        offset: ((ref = options.offsetInChunk) != null ? ref : 0) + match.index + before.length,\n        length: invalidEscape.length\n      });\n    }\n\n    // Constructs a string or regex by escaping certain characters.\n    makeDelimitedLiteral(body, options = {}) {\n      var regex;\n      if (body === '' && options.delimiter === '/') {\n        body = '(?:)';\n      }\n      regex = RegExp(`(\\\\\\\\\\\\\\\\)|(\\\\\\\\0(?=[1-7]))|\\\\\\\\?(${options.delimiter // Escaped backslash.\n      // Null character mistaken as octal escape.\n      // (Possibly escaped) delimiter.\n      // (Possibly escaped) newlines.\n      // Other escapes.\n})|\\\\\\\\?(?:(\\\\n)|(\\\\r)|(\\\\u2028)|(\\\\u2029))|(\\\\\\\\.)`, \"g\");\n      body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) {\n        switch (false) {\n          // Ignore escaped backslashes.\n          case !backslash:\n            if (options.double) {\n              return backslash + backslash;\n            } else {\n              return backslash;\n            }\n          case !nul:\n            return '\\\\x00';\n          case !delimiter:\n            return `\\\\${delimiter}`;\n          case !lf:\n            return '\\\\n';\n          case !cr:\n            return '\\\\r';\n          case !ls:\n            return '\\\\u2028';\n          case !ps:\n            return '\\\\u2029';\n          case !other:\n            if (options.double) {\n              return `\\\\${other}`;\n            } else {\n              return other;\n            }\n        }\n      });\n      return `${options.delimiter}${body}${options.delimiter}`;\n    }\n\n    suppressSemicolons() {\n      var ref, ref1, results;\n      results = [];\n      while (this.value() === ';') {\n        this.tokens.pop();\n        if (ref = (ref1 = this.prev()) != null ? ref1[0] : void 0, indexOf.call(['=', ...UNFINISHED], ref) >= 0) {\n          results.push(this.error('unexpected ;'));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    }\n\n    // Throws an error at either a given offset from the current chunk or at the\n    // location of a token (`token[2]`).\n    error(message, options = {}) {\n      var first_column, first_line, location, ref, ref1;\n      location = 'first_line' in options ? options : ([first_line, first_column] = this.getLineAndColumnFromChunk((ref = options.offset) != null ? ref : 0), {\n        first_line,\n        first_column,\n        last_column: first_column + ((ref1 = options.length) != null ? ref1 : 1) - 1\n      });\n      return throwSyntaxError(message, location);\n    }\n\n  };\n\n  // Helper functions\n  // ----------------\n  isUnassignable = function(name, displayName = name) {\n    switch (false) {\n      case indexOf.call([...JS_KEYWORDS, ...COFFEE_KEYWORDS], name) < 0:\n        return `keyword '${displayName}' can't be assigned`;\n      case indexOf.call(STRICT_PROSCRIBED, name) < 0:\n        return `'${displayName}' can't be assigned`;\n      case indexOf.call(RESERVED, name) < 0:\n        return `reserved word '${displayName}' can't be assigned`;\n      default:\n        return false;\n    }\n  };\n\n  exports.isUnassignable = isUnassignable;\n\n  // `from` isnât a CoffeeScript keyword, but it behaves like one in `import` and\n  // `export` statements (handled above) and in the declaration line of a `for`\n  // loop. Try to detect when `from` is a variable identifier and when it is this\n  // âsometimesâ keyword.\n  isForFrom = function(prev) {\n    var ref;\n    if (prev[0] === 'IDENTIFIER') {\n      // `for i from from`, `for from from iterable`\n      if (prev[1] === 'from') {\n        prev[1][0] = 'IDENTIFIER';\n        true;\n      }\n      // `for i from iterable`\n      return true;\n    // `for fromâ¦`\n    } else if (prev[0] === 'FOR') {\n      return false;\n    // `for {from}â¦`, `for [from]â¦`, `for {a, from}â¦`, `for {a: from}â¦`\n    } else if ((ref = prev[1]) === '{' || ref === '[' || ref === ',' || ref === ':') {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  // Constants\n  // ---------\n\n  // Keywords that CoffeeScript shares in common with JavaScript.\n  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'await', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];\n\n  // CoffeeScript-only keywords.\n  COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];\n\n  COFFEE_ALIAS_MAP = {\n    and: '&&',\n    or: '||',\n    is: '==',\n    isnt: '!=',\n    not: '!',\n    yes: 'true',\n    no: 'false',\n    on: 'true',\n    off: 'false'\n  };\n\n  COFFEE_ALIASES = (function() {\n    var results;\n    results = [];\n    for (key in COFFEE_ALIAS_MAP) {\n      results.push(key);\n    }\n    return results;\n  })();\n\n  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);\n\n  // The list of keywords that are reserved by JavaScript, but not used, or are\n  // used by CoffeeScript internally. We throw an error when these are encountered,\n  // to avoid having a JavaScript error at runtime.\n  RESERVED = ['case', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];\n\n  STRICT_PROSCRIBED = ['arguments', 'eval'];\n\n  // The superset of both JavaScript keywords and reserved words, none of which may\n  // be used as identifiers or properties.\n  exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);\n\n  // The character code of the nasty Microsoft madness otherwise known as the BOM.\n  BOM = 65279;\n\n  // Token matching regexes.\n  IDENTIFIER = /^(?!\\d)((?:(?!\\s)[$\\w\\x7f-\\uffff])+)([^\\n\\S]*:(?!:))?/; // Is this a property name?\n\n  CSX_IDENTIFIER = /^(?![\\d<])((?:(?!\\s)[\\.\\-$\\w\\x7f-\\uffff])+)/; // Must not start with `<`.\n  // Like `IDENTIFIER`, but includes `-`s and `.`s.\n\n  // Fragment: <></>\n  CSX_FRAGMENT_IDENTIFIER = /^()>/; // Ends immediately with `>`.\n\n  CSX_ATTRIBUTE = /^(?!\\d)((?:(?!\\s)[\\-$\\w\\x7f-\\uffff])+)([^\\S]*=(?!=))?/; // Like `IDENTIFIER`, but includes `-`s.\n  // Is this an attribute with a value?\n\n  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n  // octal\n  // hex\n  // decimal\n\n  OPERATOR = /^(?:[-=]>|[-+*\\/%<>&|^!?=]=|>>>=?|([-+:])\\1|([&|<>*\\/%])\\2=?|\\?(\\.|::)|\\.{2,3})/; // function\n  // compound assign / compare\n  // zero-fill right shift\n  // doubles\n  // logic / shift / power / floor division / modulo\n  // soak access\n  // range or splat\n\n  WHITESPACE = /^[^\\n\\S]+/;\n\n  COMMENT = /^\\s*###([^#][\\s\\S]*?)(?:###[^\\n\\S]*|###$)|^(?:\\s*#(?!##[^#]).*)+/;\n\n  CODE = /^[-=]>/;\n\n  MULTI_DENT = /^(?:\\n[^\\n\\S]*)+/;\n\n  JSTOKEN = /^`(?!``)((?:[^`\\\\]|\\\\[\\s\\S])*)`/;\n\n  HERE_JSTOKEN = /^```((?:[^`\\\\]|\\\\[\\s\\S]|`(?!``))*)```/;\n\n  // String-matching-regexes.\n  STRING_START = /^(?:'''|\"\"\"|'|\")/;\n\n  STRING_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S])*/;\n\n  STRING_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\\#(?!\\{))*/;\n\n  HEREDOC_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S]|'(?!''))*/;\n\n  HEREDOC_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\"(?!\"\")|\\#(?!\\{))*/;\n\n  INSIDE_CSX = /^(?:[^\\{<])*/; // Start of CoffeeScript interpolation. // Similar to `HEREDOC_DOUBLE` but there is no escaping.\n  // Maybe CSX tag (`<` not allowed even if bare).\n\n  CSX_INTERPOLATION = /^(?:\\{|<(?!\\/))/; // CoffeeScript interpolation.\n  // CSX opening tag.\n\n  STRING_OMIT = /((?:\\\\\\\\)+)|\\\\[^\\S\\n]*\\n\\s*/g; // Consume (and preserve) an even number of backslashes.\n  // Remove escaped newlines.\n\n  SIMPLE_STRING_OMIT = /\\s*\\n\\s*/g;\n\n  HEREDOC_INDENT = /\\n+([^\\n\\S]*)(?=\\S)/g;\n\n  // Regex-matching-regexes.\n  REGEX = /^\\/(?!\\/)((?:[^[\\/\\n\\\\]|\\\\[^\\n]|\\[(?:\\\\[^\\n]|[^\\]\\n\\\\])*\\])*)(\\/)?/; // Every other thing.\n  // Anything but newlines escaped.\n  // Character class.\n\n  REGEX_FLAGS = /^\\w*/;\n\n  VALID_FLAGS = /^(?!.*(.).*\\1)[gimsuy]*$/;\n\n  // Match any character, except those that need special handling below.\n  // Match `\\` followed by any character.\n  // Match any `/` except `///`.\n  // Match `#` which is not part of interpolation, e.g. `#{}`.\n  // Comments consume everything until the end of the line, including `///`.\n  HEREGEX = /^(?:[^\\\\\\/#\\s]|\\\\[\\s\\S]|\\/(?!\\/\\/)|\\#(?!\\{)|\\s+(?:#(?!\\{).*)?)*/;\n\n  HEREGEX_OMIT = /((?:\\\\\\\\)+)|\\\\(\\s)|\\s+(?:#.*)?/g; // Consume (and preserve) an even number of backslashes.\n  // Preserve escaped whitespace.\n  // Remove whitespace and comments.\n\n  REGEX_ILLEGAL = /^(\\/|\\/{3}\\s*)(\\*)/;\n\n  POSSIBLY_DIVISION = /^\\/=?\\s/;\n\n  // Other regexes.\n  HERECOMMENT_ILLEGAL = /\\*\\//;\n\n  LINE_CONTINUER = /^\\s*(?:,|\\??\\.(?![.\\d])|\\??::)/;\n\n  STRING_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7]|[1-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/; // Make sure the escape isnât escaped.\n  // octal escape\n  // hex escape\n  // unicode code point escape\n  // unicode escape\n\n  REGEX_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/; // Make sure the escape isnât escaped.\n  // octal escape\n  // hex escape\n  // unicode code point escape\n  // unicode escape\n\n  UNICODE_CODE_POINT_ESCAPE = /(\\\\\\\\)|\\\\u\\{([\\da-fA-F]+)\\}/g; // Make sure the escape isnât escaped.\n\n  LEADING_BLANK_LINE = /^[^\\n\\S]*\\n/;\n\n  TRAILING_BLANK_LINE = /\\n[^\\n\\S]*$/;\n\n  TRAILING_SPACES = /\\s+$/;\n\n  // Compound assignment tokens.\n  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];\n\n  // Unary tokens.\n  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];\n\n  UNARY_MATH = ['!', '~'];\n\n  // Bit-shifting tokens.\n  SHIFT = ['<<', '>>', '>>>'];\n\n  // Comparison tokens.\n  COMPARE = ['==', '!=', '<', '>', '<=', '>='];\n\n  // Mathematical tokens.\n  MATH = ['*', '/', '%', '//', '%%'];\n\n  // Relational tokens that are negatable with `not` prefix.\n  RELATION = ['IN', 'OF', 'INSTANCEOF'];\n\n  // Boolean tokens.\n  BOOL = ['TRUE', 'FALSE'];\n\n  // Tokens which could legitimately be invoked or indexed. An opening\n  // parentheses or bracket following these tokens will be recorded as the start\n  // of a function invocation or indexing operation.\n  CALLABLE = ['IDENTIFIER', 'PROPERTY', ')', ']', '?', '@', 'THIS', 'SUPER'];\n\n  INDEXABLE = CALLABLE.concat(['NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);\n\n  // Tokens which can be the left-hand side of a less-than comparison, i.e. `a<b`.\n  COMPARABLE_LEFT_SIDE = ['IDENTIFIER', ')', ']', 'NUMBER'];\n\n  // Tokens which a regular expression will never immediately follow (except spaced\n  // CALLABLEs in some cases), but which a division operator can.\n\n  // See: http://www-archive.mozilla.org/js/language/js20-2002-04/rationale/syntax.html#regular-expressions\n  NOT_REGEX = INDEXABLE.concat(['++', '--']);\n\n  // Tokens that, when immediately preceding a `WHEN`, indicate that the `WHEN`\n  // occurs at the start of a line. We disambiguate these from trailing whens to\n  // avoid an ambiguity in the grammar.\n  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];\n\n  // Additional indent in front of these is ignored.\n  INDENTABLE_CLOSERS = [')', '}', ']'];\n\n  // Tokens that, when appearing at the end of a line, suppress a following TERMINATOR/INDENT token\n  UNFINISHED = ['\\\\', '.', '?.', '?::', 'UNARY', 'MATH', 'UNARY_MATH', '+', '-', '**', 'SHIFT', 'RELATION', 'COMPARE', '&', '^', '|', '&&', '||', 'BIN?', 'EXTENDS'];\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.262Z",
		"atimeMs": 1551857503262,
		"isfile": true
	},
	"filename": "lib/coffeescript/nodes.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // `nodes.coffee` contains all of the node classes for the syntax tree. Most\n  // nodes are created as the result of actions in the [grammar](grammar.html),\n  // but some are created by other nodes as a method of code generation. To convert\n  // the syntax tree into a string of JavaScript code, call `compile()` on the root.\n  var Access, Arr, Assign, AwaitReturn, Base, Block, BooleanLiteral, CSXTag, Call, Class, Code, CodeFragment, ComputedPropertyName, Elision, ExecutableClassBody, Existence, Expansion, ExportAllDeclaration, ExportDeclaration, ExportDefaultDeclaration, ExportNamedDeclaration, ExportSpecifier, ExportSpecifierList, Extends, For, FuncGlyph, HereComment, HoistTarget, IdentifierLiteral, If, ImportClause, ImportDeclaration, ImportDefaultSpecifier, ImportNamespaceSpecifier, ImportSpecifier, ImportSpecifierList, In, Index, InfinityLiteral, JS_FORBIDDEN, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, LineComment, Literal, ModuleDeclaration, ModuleSpecifier, ModuleSpecifierList, NEGATE, NO, NaNLiteral, NullLiteral, NumberLiteral, Obj, Op, Param, Parens, PassthroughLiteral, PropertyName, Range, RegexLiteral, RegexWithInterpolations, Return, SIMPLENUM, Scope, Slice, Splat, StatementLiteral, StringLiteral, StringWithInterpolations, Super, SuperCall, Switch, TAB, THIS, TaggedTemplateCall, ThisLiteral, Throw, Try, UTILITIES, UndefinedLiteral, Value, While, YES, YieldReturn, addDataToNode, attachCommentsToNode, compact, del, ends, extend, flatten, fragmentsToText, hasLineComments, indentInitial, isLiteralArguments, isLiteralThis, isUnassignable, locationDataToString, merge, moveComments, multident, shouldCacheOrIsAssignable, some, starts, throwSyntaxError, unfoldSoak, unshiftAfterComments, utility,\n    indexOf = [].indexOf,\n    splice = [].splice,\n    slice1 = [].slice;\n\n  Error.stackTraceLimit = 2e308;\n\n  ({Scope} = require('./scope'));\n\n  ({isUnassignable, JS_FORBIDDEN} = require('./lexer'));\n\n  // Import the helpers we plan to use.\n  ({compact, flatten, extend, merge, del, starts, ends, some, addDataToNode, attachCommentsToNode, locationDataToString, throwSyntaxError} = require('./helpers'));\n\n  // Functions required by parser.\n  exports.extend = extend;\n\n  exports.addDataToNode = addDataToNode;\n\n  // Constant functions for nodes that donât need customization.\n  YES = function() {\n    return true;\n  };\n\n  NO = function() {\n    return false;\n  };\n\n  THIS = function() {\n    return this;\n  };\n\n  NEGATE = function() {\n    this.negated = !this.negated;\n    return this;\n  };\n\n  //### CodeFragment\n\n  // The various nodes defined below all compile to a collection of **CodeFragment** objects.\n  // A CodeFragments is a block of generated code, and the location in the source file where the code\n  // came from. CodeFragments can be assembled together into working code just by catting together\n  // all the CodeFragments' `code` snippets, in order.\n  exports.CodeFragment = CodeFragment = class CodeFragment {\n    constructor(parent, code) {\n      var ref1;\n      this.code = `${code}`;\n      this.type = (parent != null ? (ref1 = parent.constructor) != null ? ref1.name : void 0 : void 0) || 'unknown';\n      this.locationData = parent != null ? parent.locationData : void 0;\n      this.comments = parent != null ? parent.comments : void 0;\n    }\n\n    toString() {\n      // This is only intended for debugging.\n      return `${this.code}${(this.locationData ? \": \" + locationDataToString(this.locationData) : '')}`;\n    }\n\n  };\n\n  // Convert an array of CodeFragments into a string.\n  fragmentsToText = function(fragments) {\n    var fragment;\n    return ((function() {\n      var j, len1, results;\n      results = [];\n      for (j = 0, len1 = fragments.length; j < len1; j++) {\n        fragment = fragments[j];\n        results.push(fragment.code);\n      }\n      return results;\n    })()).join('');\n  };\n\n  //### Base\n\n  // The **Base** is the abstract base class for all nodes in the syntax tree.\n  // Each subclass implements the `compileNode` method, which performs the\n  // code generation for that node. To compile a node to JavaScript,\n  // call `compile` on it, which wraps `compileNode` in some generic extra smarts,\n  // to know when the generated code needs to be wrapped up in a closure.\n  // An options hash is passed and cloned throughout, containing information about\n  // the environment from higher in the tree (such as if a returned value is\n  // being requested by the surrounding function), information about the current\n  // scope, and indentation level.\n  exports.Base = Base = (function() {\n    class Base {\n      compile(o, lvl) {\n        return fragmentsToText(this.compileToFragments(o, lvl));\n      }\n\n      // Occasionally a node is compiled multiple times, for example to get the name\n      // of a variable to add to scope tracking. When we know that a âprematureâ\n      // compilation wonât result in comments being output, set those comments aside\n      // so that theyâre preserved for a later `compile` call that will result in\n      // the comments being included in the output.\n      compileWithoutComments(o, lvl, method = 'compile') {\n        var fragments, unwrapped;\n        if (this.comments) {\n          this.ignoreTheseCommentsTemporarily = this.comments;\n          delete this.comments;\n        }\n        unwrapped = this.unwrapAll();\n        if (unwrapped.comments) {\n          unwrapped.ignoreTheseCommentsTemporarily = unwrapped.comments;\n          delete unwrapped.comments;\n        }\n        fragments = this[method](o, lvl);\n        if (this.ignoreTheseCommentsTemporarily) {\n          this.comments = this.ignoreTheseCommentsTemporarily;\n          delete this.ignoreTheseCommentsTemporarily;\n        }\n        if (unwrapped.ignoreTheseCommentsTemporarily) {\n          unwrapped.comments = unwrapped.ignoreTheseCommentsTemporarily;\n          delete unwrapped.ignoreTheseCommentsTemporarily;\n        }\n        return fragments;\n      }\n\n      compileNodeWithoutComments(o, lvl) {\n        return this.compileWithoutComments(o, lvl, 'compileNode');\n      }\n\n      // Common logic for determining whether to wrap this node in a closure before\n      // compiling it, or to compile directly. We need to wrap if this node is a\n      // *statement*, and it's not a *pureStatement*, and we're not at\n      // the top level of a block (which would be unnecessary), and we haven't\n      // already been asked to return the result (because statements know how to\n      // return results).\n      compileToFragments(o, lvl) {\n        var fragments, node;\n        o = extend({}, o);\n        if (lvl) {\n          o.level = lvl;\n        }\n        node = this.unfoldSoak(o) || this;\n        node.tab = o.indent;\n        fragments = o.level === LEVEL_TOP || !node.isStatement(o) ? node.compileNode(o) : node.compileClosure(o);\n        this.compileCommentFragments(o, node, fragments);\n        return fragments;\n      }\n\n      compileToFragmentsWithoutComments(o, lvl) {\n        return this.compileWithoutComments(o, lvl, 'compileToFragments');\n      }\n\n      // Statements converted into expressions via closure-wrapping share a scope\n      // object with their parent closure, to preserve the expected lexical scope.\n      compileClosure(o) {\n        var args, argumentsNode, func, jumpNode, meth, parts, ref1, ref2;\n        if (jumpNode = this.jumps()) {\n          jumpNode.error('cannot use a pure statement in an expression');\n        }\n        o.sharedScope = true;\n        func = new Code([], Block.wrap([this]));\n        args = [];\n        if (this.contains((function(node) {\n          return node instanceof SuperCall;\n        }))) {\n          func.bound = true;\n        } else if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {\n          args = [new ThisLiteral];\n          if (argumentsNode) {\n            meth = 'apply';\n            args.push(new IdentifierLiteral('arguments'));\n          } else {\n            meth = 'call';\n          }\n          func = new Value(func, [new Access(new PropertyName(meth))]);\n        }\n        parts = (new Call(func, args)).compileNode(o);\n        switch (false) {\n          case !(func.isGenerator || ((ref1 = func.base) != null ? ref1.isGenerator : void 0)):\n            parts.unshift(this.makeCode(\"(yield* \"));\n            parts.push(this.makeCode(\")\"));\n            break;\n          case !(func.isAsync || ((ref2 = func.base) != null ? ref2.isAsync : void 0)):\n            parts.unshift(this.makeCode(\"(await \"));\n            parts.push(this.makeCode(\")\"));\n        }\n        return parts;\n      }\n\n      compileCommentFragments(o, node, fragments) {\n        var base1, base2, comment, commentFragment, j, len1, ref1, unshiftCommentFragment;\n        if (!node.comments) {\n          return fragments;\n        }\n        // This is where comments, that are attached to nodes as a `comments`\n        // property, become `CodeFragment`s. âInline block comments,â e.g.\n        // `/* */`-delimited comments that are interspersed within code on a line,\n        // are added to the current `fragments` stream. All other fragments are\n        // attached as properties to the nearest preceding or following fragment,\n        // to remain stowaways until they get properly output in `compileComments`\n        // later on.\n        unshiftCommentFragment = function(commentFragment) {\n          var precedingFragment;\n          if (commentFragment.unshift) {\n            // Find the first non-comment fragment and insert `commentFragment`\n            // before it.\n            return unshiftAfterComments(fragments, commentFragment);\n          } else {\n            if (fragments.length !== 0) {\n              precedingFragment = fragments[fragments.length - 1];\n              if (commentFragment.newLine && precedingFragment.code !== '' && !/\\n\\s*$/.test(precedingFragment.code)) {\n                commentFragment.code = `\\n${commentFragment.code}`;\n              }\n            }\n            return fragments.push(commentFragment);\n          }\n        };\n        ref1 = node.comments;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          comment = ref1[j];\n          if (!(indexOf.call(this.compiledComments, comment) < 0)) {\n            continue;\n          }\n          this.compiledComments.push(comment); // Donât output this comment twice.\n          // For block/here comments, denoted by `###`, that are inline comments\n          // like `1 + ### comment ### 2`, create fragments and insert them into\n          // the fragments array.\n          // Otherwise attach comment fragments to their closest fragment for now,\n          // so they can be inserted into the output later after all the newlines\n          // have been added.\n          if (comment.here) { // Block comment, delimited by `###`.\n            commentFragment = new HereComment(comment).compileNode(o); // Line comment, delimited by `#`.\n          } else {\n            commentFragment = new LineComment(comment).compileNode(o);\n          }\n          if ((commentFragment.isHereComment && !commentFragment.newLine) || node.includeCommentFragments()) {\n            // Inline block comments, like `1 + /* comment */ 2`, or a node whose\n            // `compileToFragments` method has logic for outputting comments.\n            unshiftCommentFragment(commentFragment);\n          } else {\n            if (fragments.length === 0) {\n              fragments.push(this.makeCode(''));\n            }\n            if (commentFragment.unshift) {\n              if ((base1 = fragments[0]).precedingComments == null) {\n                base1.precedingComments = [];\n              }\n              fragments[0].precedingComments.push(commentFragment);\n            } else {\n              if ((base2 = fragments[fragments.length - 1]).followingComments == null) {\n                base2.followingComments = [];\n              }\n              fragments[fragments.length - 1].followingComments.push(commentFragment);\n            }\n          }\n        }\n        return fragments;\n      }\n\n      // If the code generation wishes to use the result of a complex expression\n      // in multiple places, ensure that the expression is only ever evaluated once,\n      // by assigning it to a temporary variable. Pass a level to precompile.\n\n      // If `level` is passed, then returns `[val, ref]`, where `val` is the compiled value, and `ref`\n      // is the compiled reference. If `level` is not passed, this returns `[val, ref]` where\n      // the two values are raw nodes which have not been compiled.\n      cache(o, level, shouldCache) {\n        var complex, ref, sub;\n        complex = shouldCache != null ? shouldCache(this) : this.shouldCache();\n        if (complex) {\n          ref = new IdentifierLiteral(o.scope.freeVariable('ref'));\n          sub = new Assign(ref, this);\n          if (level) {\n            return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];\n          } else {\n            return [sub, ref];\n          }\n        } else {\n          ref = level ? this.compileToFragments(o, level) : this;\n          return [ref, ref];\n        }\n      }\n\n      // Occasionally it may be useful to make an expression behave as if it was 'hoisted', whereby the\n      // result of the expression is available before its location in the source, but the expression's\n      // variable scope corresponds the source position. This is used extensively to deal with executable\n      // class bodies in classes.\n\n      // Calling this method mutates the node, proxying the `compileNode` and `compileToFragments`\n      // methods to store their result for later replacing the `target` node, which is returned by the\n      // call.\n      hoist() {\n        var compileNode, compileToFragments, target;\n        this.hoisted = true;\n        target = new HoistTarget(this);\n        compileNode = this.compileNode;\n        compileToFragments = this.compileToFragments;\n        this.compileNode = function(o) {\n          return target.update(compileNode, o);\n        };\n        this.compileToFragments = function(o) {\n          return target.update(compileToFragments, o);\n        };\n        return target;\n      }\n\n      cacheToCodeFragments(cacheValues) {\n        return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];\n      }\n\n      // Construct a node that returns the current node's result.\n      // Note that this is overridden for smarter behavior for\n      // many statement nodes (e.g. If, For)...\n      makeReturn(res) {\n        var me;\n        me = this.unwrapAll();\n        if (res) {\n          return new Call(new Literal(`${res}.push`), [me]);\n        } else {\n          return new Return(me);\n        }\n      }\n\n      // Does this node, or any of its children, contain a node of a certain kind?\n      // Recursively traverses down the *children* nodes and returns the first one\n      // that verifies `pred`. Otherwise return undefined. `contains` does not cross\n      // scope boundaries.\n      contains(pred) {\n        var node;\n        node = void 0;\n        this.traverseChildren(false, function(n) {\n          if (pred(n)) {\n            node = n;\n            return false;\n          }\n        });\n        return node;\n      }\n\n      // Pull out the last node of a node list.\n      lastNode(list) {\n        if (list.length === 0) {\n          return null;\n        } else {\n          return list[list.length - 1];\n        }\n      }\n\n      // `toString` representation of the node, for inspecting the parse tree.\n      // This is what `coffee --nodes` prints out.\n      toString(idt = '', name = this.constructor.name) {\n        var tree;\n        tree = '\\n' + idt + name;\n        if (this.soak) {\n          tree += '?';\n        }\n        this.eachChild(function(node) {\n          return tree += node.toString(idt + TAB);\n        });\n        return tree;\n      }\n\n      // Passes each child to a function, breaking when the function returns `false`.\n      eachChild(func) {\n        var attr, child, j, k, len1, len2, ref1, ref2;\n        if (!this.children) {\n          return this;\n        }\n        ref1 = this.children;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          attr = ref1[j];\n          if (this[attr]) {\n            ref2 = flatten([this[attr]]);\n            for (k = 0, len2 = ref2.length; k < len2; k++) {\n              child = ref2[k];\n              if (func(child) === false) {\n                return this;\n              }\n            }\n          }\n        }\n        return this;\n      }\n\n      traverseChildren(crossScope, func) {\n        return this.eachChild(function(child) {\n          var recur;\n          recur = func(child);\n          if (recur !== false) {\n            return child.traverseChildren(crossScope, func);\n          }\n        });\n      }\n\n      // `replaceInContext` will traverse children looking for a node for which `match` returns\n      // true. Once found, the matching node will be replaced by the result of calling `replacement`.\n      replaceInContext(match, replacement) {\n        var attr, child, children, i, j, k, len1, len2, ref1, ref2;\n        if (!this.children) {\n          return false;\n        }\n        ref1 = this.children;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          attr = ref1[j];\n          if (children = this[attr]) {\n            if (Array.isArray(children)) {\n              for (i = k = 0, len2 = children.length; k < len2; i = ++k) {\n                child = children[i];\n                if (match(child)) {\n                  splice.apply(children, [i, i - i + 1].concat(ref2 = replacement(child, this))), ref2;\n                  return true;\n                } else {\n                  if (child.replaceInContext(match, replacement)) {\n                    return true;\n                  }\n                }\n              }\n            } else if (match(children)) {\n              this[attr] = replacement(children, this);\n              return true;\n            } else {\n              if (children.replaceInContext(match, replacement)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      invert() {\n        return new Op('!', this);\n      }\n\n      unwrapAll() {\n        var node;\n        node = this;\n        while (node !== (node = node.unwrap())) {\n          continue;\n        }\n        return node;\n      }\n\n      // For this node and all descendents, set the location data to `locationData`\n      // if the location data is not already set.\n      updateLocationDataIfMissing(locationData) {\n        if (this.locationData && !this.forceUpdateLocation) {\n          return this;\n        }\n        delete this.forceUpdateLocation;\n        this.locationData = locationData;\n        return this.eachChild(function(child) {\n          return child.updateLocationDataIfMissing(locationData);\n        });\n      }\n\n      // Throw a SyntaxError associated with this nodeâs location.\n      error(message) {\n        return throwSyntaxError(message, this.locationData);\n      }\n\n      makeCode(code) {\n        return new CodeFragment(this, code);\n      }\n\n      wrapInParentheses(fragments) {\n        return [this.makeCode('('), ...fragments, this.makeCode(')')];\n      }\n\n      wrapInBraces(fragments) {\n        return [this.makeCode('{'), ...fragments, this.makeCode('}')];\n      }\n\n      // `fragmentsList` is an array of arrays of fragments. Each array in fragmentsList will be\n      // concatenated together, with `joinStr` added in between each, to produce a final flat array\n      // of fragments.\n      joinFragmentArrays(fragmentsList, joinStr) {\n        var answer, fragments, i, j, len1;\n        answer = [];\n        for (i = j = 0, len1 = fragmentsList.length; j < len1; i = ++j) {\n          fragments = fragmentsList[i];\n          if (i) {\n            answer.push(this.makeCode(joinStr));\n          }\n          answer = answer.concat(fragments);\n        }\n        return answer;\n      }\n\n    };\n\n    // Default implementations of the common node properties and methods. Nodes\n    // will override these with custom logic, if needed.\n\n    // `children` are the properties to recurse into when tree walking. The\n    // `children` list *is* the structure of the AST. The `parent` pointer, and\n    // the pointer to the `children` are how you can traverse the tree.\n    Base.prototype.children = [];\n\n    // `isStatement` has to do with âeverything is an expressionâ. A few things\n    // canât be expressions, such as `break`. Things that `isStatement` returns\n    // `true` for are things that canât be used as expressions. There are some\n    // error messages that come from `nodes.coffee` due to statements ending up\n    // in expression position.\n    Base.prototype.isStatement = NO;\n\n    // Track comments that have been compiled into fragments, to avoid outputting\n    // them twice.\n    Base.prototype.compiledComments = [];\n\n    // `includeCommentFragments` lets `compileCommentFragments` know whether this node\n    // has special awareness of how to handle comments within its output.\n    Base.prototype.includeCommentFragments = NO;\n\n    // `jumps` tells you if an expression, or an internal part of an expression\n    // has a flow control construct (like `break`, or `continue`, or `return`,\n    // or `throw`) that jumps out of the normal flow of control and canât be\n    // used as a value. This is important because things like this make no sense;\n    // we have to disallow them.\n    Base.prototype.jumps = NO;\n\n    // If `node.shouldCache() is false`, it is safe to use `node` more than once.\n    // Otherwise you need to store the value of `node` in a variable and output\n    // that variable several times instead. Kind of like this: `5` need not be\n    // cached. `returnFive()`, however, could have side effects as a result of\n    // evaluating it more than once, and therefore we need to cache it. The\n    // parameter is named `shouldCache` rather than `mustCache` because there are\n    // also cases where we might not need to cache but where we want to, for\n    // example a long expression that may well be idempotent but we want to cache\n    // for brevity.\n    Base.prototype.shouldCache = YES;\n\n    Base.prototype.isChainable = NO;\n\n    Base.prototype.isAssignable = NO;\n\n    Base.prototype.isNumber = NO;\n\n    Base.prototype.unwrap = THIS;\n\n    Base.prototype.unfoldSoak = NO;\n\n    // Is this node used to assign a certain variable?\n    Base.prototype.assigns = NO;\n\n    return Base;\n\n  }).call(this);\n\n  //### HoistTarget\n\n  // A **HoistTargetNode** represents the output location in the node tree for a hoisted node.\n  // See Base#hoist.\n  exports.HoistTarget = HoistTarget = class HoistTarget extends Base {\n    // Expands hoisted fragments in the given array\n    static expand(fragments) {\n      var fragment, i, j, ref1;\n      for (i = j = fragments.length - 1; j >= 0; i = j += -1) {\n        fragment = fragments[i];\n        if (fragment.fragments) {\n          splice.apply(fragments, [i, i - i + 1].concat(ref1 = this.expand(fragment.fragments))), ref1;\n        }\n      }\n      return fragments;\n    }\n\n    constructor(source1) {\n      super();\n      this.source = source1;\n      // Holds presentational options to apply when the source node is compiled.\n      this.options = {};\n      // Placeholder fragments to be replaced by the source nodeâs compilation.\n      this.targetFragments = {\n        fragments: []\n      };\n    }\n\n    isStatement(o) {\n      return this.source.isStatement(o);\n    }\n\n    // Update the target fragments with the result of compiling the source.\n    // Calls the given compile function with the node and options (overriden with the target\n    // presentational options).\n    update(compile, o) {\n      return this.targetFragments.fragments = compile.call(this.source, merge(o, this.options));\n    }\n\n    // Copies the target indent and level, and returns the placeholder fragments\n    compileToFragments(o, level) {\n      this.options.indent = o.indent;\n      this.options.level = level != null ? level : o.level;\n      return [this.targetFragments];\n    }\n\n    compileNode(o) {\n      return this.compileToFragments(o);\n    }\n\n    compileClosure(o) {\n      return this.compileToFragments(o);\n    }\n\n  };\n\n  //### Block\n\n  // The block is the list of expressions that forms the body of an\n  // indented block of code -- the implementation of a function, a clause in an\n  // `if`, `switch`, or `try`, and so on...\n  exports.Block = Block = (function() {\n    class Block extends Base {\n      constructor(nodes) {\n        super();\n        this.expressions = compact(flatten(nodes || []));\n      }\n\n      // Tack an expression on to the end of this expression list.\n      push(node) {\n        this.expressions.push(node);\n        return this;\n      }\n\n      // Remove and return the last expression of this expression list.\n      pop() {\n        return this.expressions.pop();\n      }\n\n      // Add an expression at the beginning of this expression list.\n      unshift(node) {\n        this.expressions.unshift(node);\n        return this;\n      }\n\n      // If this Block consists of just a single node, unwrap it by pulling\n      // it back out.\n      unwrap() {\n        if (this.expressions.length === 1) {\n          return this.expressions[0];\n        } else {\n          return this;\n        }\n      }\n\n      // Is this an empty block of code?\n      isEmpty() {\n        return !this.expressions.length;\n      }\n\n      isStatement(o) {\n        var exp, j, len1, ref1;\n        ref1 = this.expressions;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          exp = ref1[j];\n          if (exp.isStatement(o)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      jumps(o) {\n        var exp, j, jumpNode, len1, ref1;\n        ref1 = this.expressions;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          exp = ref1[j];\n          if (jumpNode = exp.jumps(o)) {\n            return jumpNode;\n          }\n        }\n      }\n\n      // A Block node does not return its entire body, rather it\n      // ensures that the final expression is returned.\n      makeReturn(res) {\n        var expr, expressions, last, lastExp, len, penult, ref1;\n        len = this.expressions.length;\n        ref1 = this.expressions, [lastExp] = slice1.call(ref1, -1);\n        lastExp = (lastExp != null ? lastExp.unwrap() : void 0) || false;\n        // We also need to check that weâre not returning a CSX tag if thereâs an\n        // adjacent one at the same level; JSX doesnât allow that.\n        if (lastExp && lastExp instanceof Parens && lastExp.body.expressions.length > 1) {\n          ({\n            body: {expressions}\n          } = lastExp);\n          [penult, last] = slice1.call(expressions, -2);\n          penult = penult.unwrap();\n          last = last.unwrap();\n          if (penult instanceof Call && penult.csx && last instanceof Call && last.csx) {\n            expressions[expressions.length - 1].error('Adjacent JSX elements must be wrapped in an enclosing tag');\n          }\n        }\n        while (len--) {\n          expr = this.expressions[len];\n          this.expressions[len] = expr.makeReturn(res);\n          if (expr instanceof Return && !expr.expression) {\n            this.expressions.splice(len, 1);\n          }\n          break;\n        }\n        return this;\n      }\n\n      // A **Block** is the only node that can serve as the root.\n      compileToFragments(o = {}, level) {\n        if (o.scope) {\n          return super.compileToFragments(o, level);\n        } else {\n          return this.compileRoot(o);\n        }\n      }\n\n      // Compile all expressions within the **Block** body. If we need to return\n      // the result, and itâs an expression, simply return it. If itâs a statement,\n      // ask the statement to do so.\n      compileNode(o) {\n        var answer, compiledNodes, fragments, index, j, lastFragment, len1, node, ref1, top;\n        this.tab = o.indent;\n        top = o.level === LEVEL_TOP;\n        compiledNodes = [];\n        ref1 = this.expressions;\n        for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {\n          node = ref1[index];\n          if (node.hoisted) {\n            // This is a hoisted expression.\n            // We want to compile this and ignore the result.\n            node.compileToFragments(o);\n            continue;\n          }\n          node = node.unfoldSoak(o) || node;\n          if (node instanceof Block) {\n            // This is a nested block. We donât do anything special here like\n            // enclose it in a new scope; we just compile the statements in this\n            // block along with our own.\n            compiledNodes.push(node.compileNode(o));\n          } else if (top) {\n            node.front = true;\n            fragments = node.compileToFragments(o);\n            if (!node.isStatement(o)) {\n              fragments = indentInitial(fragments, this);\n              [lastFragment] = slice1.call(fragments, -1);\n              if (!(lastFragment.code === '' || lastFragment.isComment)) {\n                fragments.push(this.makeCode(';'));\n              }\n            }\n            compiledNodes.push(fragments);\n          } else {\n            compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));\n          }\n        }\n        if (top) {\n          if (this.spaced) {\n            return [].concat(this.joinFragmentArrays(compiledNodes, '\\n\\n'), this.makeCode('\\n'));\n          } else {\n            return this.joinFragmentArrays(compiledNodes, '\\n');\n          }\n        }\n        if (compiledNodes.length) {\n          answer = this.joinFragmentArrays(compiledNodes, ', ');\n        } else {\n          answer = [this.makeCode('void 0')];\n        }\n        if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {\n          return this.wrapInParentheses(answer);\n        } else {\n          return answer;\n        }\n      }\n\n      // If we happen to be the top-level **Block**, wrap everything in a safety\n      // closure, unless requested not to. It would be better not to generate them\n      // in the first place, but for now, clean up obvious double-parentheses.\n      compileRoot(o) {\n        var fragments, j, len1, name, ref1, ref2;\n        o.indent = o.bare ? '' : TAB;\n        o.level = LEVEL_TOP;\n        this.spaced = true;\n        o.scope = new Scope(null, this, null, (ref1 = o.referencedVars) != null ? ref1 : []);\n        ref2 = o.locals || [];\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          name = ref2[j];\n          // Mark given local variables in the root scope as parameters so they donât\n          // end up being declared on this block.\n          o.scope.parameter(name);\n        }\n        fragments = this.compileWithDeclarations(o);\n        HoistTarget.expand(fragments);\n        fragments = this.compileComments(fragments);\n        if (o.bare) {\n          return fragments;\n        }\n        return [].concat(this.makeCode(\"(function() {\\n\"), fragments, this.makeCode(\"\\n}).call(this);\\n\"));\n      }\n\n      // Compile the expressions body for the contents of a function, with\n      // declarations of all inner variables pushed up to the top.\n      compileWithDeclarations(o) {\n        var assigns, declaredVariable, declaredVariables, declaredVariablesIndex, declars, exp, fragments, i, j, k, len1, len2, post, ref1, rest, scope, spaced;\n        fragments = [];\n        post = [];\n        ref1 = this.expressions;\n        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {\n          exp = ref1[i];\n          exp = exp.unwrap();\n          if (!(exp instanceof Literal)) {\n            break;\n          }\n        }\n        o = merge(o, {\n          level: LEVEL_TOP\n        });\n        if (i) {\n          rest = this.expressions.splice(i, 9e9);\n          [spaced, this.spaced] = [this.spaced, false];\n          [fragments, this.spaced] = [this.compileNode(o), spaced];\n          this.expressions = rest;\n        }\n        post = this.compileNode(o);\n        ({scope} = o);\n        if (scope.expressions === this) {\n          declars = o.scope.hasDeclarations();\n          assigns = scope.hasAssignments;\n          if (declars || assigns) {\n            if (i) {\n              fragments.push(this.makeCode('\\n'));\n            }\n            fragments.push(this.makeCode(`${this.tab}var `));\n            if (declars) {\n              declaredVariables = scope.declaredVariables();\n              for (declaredVariablesIndex = k = 0, len2 = declaredVariables.length; k < len2; declaredVariablesIndex = ++k) {\n                declaredVariable = declaredVariables[declaredVariablesIndex];\n                fragments.push(this.makeCode(declaredVariable));\n                if (Object.prototype.hasOwnProperty.call(o.scope.comments, declaredVariable)) {\n                  fragments.push(...o.scope.comments[declaredVariable]);\n                }\n                if (declaredVariablesIndex !== declaredVariables.length - 1) {\n                  fragments.push(this.makeCode(', '));\n                }\n              }\n            }\n            if (assigns) {\n              if (declars) {\n                fragments.push(this.makeCode(`,\\n${this.tab + TAB}`));\n              }\n              fragments.push(this.makeCode(scope.assignedVariables().join(`,\\n${this.tab + TAB}`)));\n            }\n            fragments.push(this.makeCode(`;\\n${(this.spaced ? '\\n' : '')}`));\n          } else if (fragments.length && post.length) {\n            fragments.push(this.makeCode(\"\\n\"));\n          }\n        }\n        return fragments.concat(post);\n      }\n\n      compileComments(fragments) {\n        var code, commentFragment, fragment, fragmentIndent, fragmentIndex, indent, j, k, l, len1, len2, len3, newLineIndex, onNextLine, p, pastFragment, pastFragmentIndex, q, ref1, ref2, ref3, ref4, trail, upcomingFragment, upcomingFragmentIndex;\n        for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {\n          fragment = fragments[fragmentIndex];\n          // Insert comments into the output at the next or previous newline.\n          // If there are no newlines at which to place comments, create them.\n          if (fragment.precedingComments) {\n            // Determine the indentation level of the fragment that we are about\n            // to insert comments before, and use that indentation level for our\n            // inserted comments. At this point, the fragmentsâ `code` property\n            // is the generated output JavaScript, and CoffeeScript always\n            // generates output indented by two spaces; so all we need to do is\n            // search for a `code` property that begins with at least two spaces.\n            fragmentIndent = '';\n            ref1 = fragments.slice(0, (fragmentIndex + 1));\n            for (k = ref1.length - 1; k >= 0; k += -1) {\n              pastFragment = ref1[k];\n              indent = /^ {2,}/m.exec(pastFragment.code);\n              if (indent) {\n                fragmentIndent = indent[0];\n                break;\n              } else if (indexOf.call(pastFragment.code, '\\n') >= 0) {\n                break;\n              }\n            }\n            code = `\\n${fragmentIndent}` + ((function() {\n              var l, len2, ref2, results;\n              ref2 = fragment.precedingComments;\n              results = [];\n              for (l = 0, len2 = ref2.length; l < len2; l++) {\n                commentFragment = ref2[l];\n                if (commentFragment.isHereComment && commentFragment.multiline) {\n                  results.push(multident(commentFragment.code, fragmentIndent, false));\n                } else {\n                  results.push(commentFragment.code);\n                }\n              }\n              return results;\n            })()).join(`\\n${fragmentIndent}`).replace(/^(\\s*)$/gm, '');\n            ref2 = fragments.slice(0, (fragmentIndex + 1));\n            for (pastFragmentIndex = l = ref2.length - 1; l >= 0; pastFragmentIndex = l += -1) {\n              pastFragment = ref2[pastFragmentIndex];\n              newLineIndex = pastFragment.code.lastIndexOf('\\n');\n              if (newLineIndex === -1) {\n                // Keep searching previous fragments until we canât go back any\n                // further, either because there are no fragments left or weâve\n                // discovered that weâre in a code block that is interpolated\n                // inside a string.\n                if (pastFragmentIndex === 0) {\n                  pastFragment.code = '\\n' + pastFragment.code;\n                  newLineIndex = 0;\n                } else if (pastFragment.isStringWithInterpolations && pastFragment.code === '{') {\n                  code = code.slice(1) + '\\n'; // Move newline to end.\n                  newLineIndex = 1;\n                } else {\n                  continue;\n                }\n              }\n              delete fragment.precedingComments;\n              pastFragment.code = pastFragment.code.slice(0, newLineIndex) + code + pastFragment.code.slice(newLineIndex);\n              break;\n            }\n          }\n          // Yes, this is awfully similar to the previous `if` block, but if you\n          // look closely youâll find lots of tiny differences that make this\n          // confusing if it were abstracted into a function that both blocks share.\n          if (fragment.followingComments) {\n            // Does the first trailing comment follow at the end of a line of code,\n            // like `; // Comment`, or does it start a new line after a line of code?\n            trail = fragment.followingComments[0].trail;\n            fragmentIndent = '';\n            // Find the indent of the next line of code, if we have any non-trailing\n            // comments to output. We need to first find the next newline, as these\n            // comments will be output after that; and then the indent of the line\n            // that follows the next newline.\n            if (!(trail && fragment.followingComments.length === 1)) {\n              onNextLine = false;\n              ref3 = fragments.slice(fragmentIndex);\n              for (p = 0, len2 = ref3.length; p < len2; p++) {\n                upcomingFragment = ref3[p];\n                if (!onNextLine) {\n                  if (indexOf.call(upcomingFragment.code, '\\n') >= 0) {\n                    onNextLine = true;\n                  } else {\n                    continue;\n                  }\n                } else {\n                  indent = /^ {2,}/m.exec(upcomingFragment.code);\n                  if (indent) {\n                    fragmentIndent = indent[0];\n                    break;\n                  } else if (indexOf.call(upcomingFragment.code, '\\n') >= 0) {\n                    break;\n                  }\n                }\n              }\n            }\n            // Is this comment following the indent inserted by bare mode?\n            // If so, thereâs no need to indent this further.\n            code = fragmentIndex === 1 && /^\\s+$/.test(fragments[0].code) ? '' : trail ? ' ' : `\\n${fragmentIndent}`;\n            // Assemble properly indented comments.\n            code += ((function() {\n              var len3, q, ref4, results;\n              ref4 = fragment.followingComments;\n              results = [];\n              for (q = 0, len3 = ref4.length; q < len3; q++) {\n                commentFragment = ref4[q];\n                if (commentFragment.isHereComment && commentFragment.multiline) {\n                  results.push(multident(commentFragment.code, fragmentIndent, false));\n                } else {\n                  results.push(commentFragment.code);\n                }\n              }\n              return results;\n            })()).join(`\\n${fragmentIndent}`).replace(/^(\\s*)$/gm, '');\n            ref4 = fragments.slice(fragmentIndex);\n            for (upcomingFragmentIndex = q = 0, len3 = ref4.length; q < len3; upcomingFragmentIndex = ++q) {\n              upcomingFragment = ref4[upcomingFragmentIndex];\n              newLineIndex = upcomingFragment.code.indexOf('\\n');\n              if (newLineIndex === -1) {\n                // Keep searching upcoming fragments until we canât go any\n                // further, either because there are no fragments left or weâve\n                // discovered that weâre in a code block that is interpolated\n                // inside a string.\n                if (upcomingFragmentIndex === fragments.length - 1) {\n                  upcomingFragment.code = upcomingFragment.code + '\\n';\n                  newLineIndex = upcomingFragment.code.length;\n                } else if (upcomingFragment.isStringWithInterpolations && upcomingFragment.code === '}') {\n                  code = `${code}\\n`;\n                  newLineIndex = 0;\n                } else {\n                  continue;\n                }\n              }\n              delete fragment.followingComments;\n              if (upcomingFragment.code === '\\n') {\n                // Avoid inserting extra blank lines.\n                code = code.replace(/^\\n/, '');\n              }\n              upcomingFragment.code = upcomingFragment.code.slice(0, newLineIndex) + code + upcomingFragment.code.slice(newLineIndex);\n              break;\n            }\n          }\n        }\n        return fragments;\n      }\n\n      // Wrap up the given nodes as a **Block**, unless it already happens\n      // to be one.\n      static wrap(nodes) {\n        if (nodes.length === 1 && nodes[0] instanceof Block) {\n          return nodes[0];\n        }\n        return new Block(nodes);\n      }\n\n    };\n\n    Block.prototype.children = ['expressions'];\n\n    return Block;\n\n  }).call(this);\n\n  //### Literal\n\n  // `Literal` is a base class for static values that can be passed through\n  // directly into JavaScript without translation, such as: strings, numbers,\n  // `true`, `false`, `null`...\n  exports.Literal = Literal = (function() {\n    class Literal extends Base {\n      constructor(value1) {\n        super();\n        this.value = value1;\n      }\n\n      assigns(name) {\n        return name === this.value;\n      }\n\n      compileNode(o) {\n        return [this.makeCode(this.value)];\n      }\n\n      toString() {\n        // This is only intended for debugging.\n        return ` ${(this.isStatement() ? super.toString() : this.constructor.name)}: ${this.value}`;\n      }\n\n    };\n\n    Literal.prototype.shouldCache = NO;\n\n    return Literal;\n\n  }).call(this);\n\n  exports.NumberLiteral = NumberLiteral = class NumberLiteral extends Literal {};\n\n  exports.InfinityLiteral = InfinityLiteral = class InfinityLiteral extends NumberLiteral {\n    compileNode() {\n      return [this.makeCode('2e308')];\n    }\n\n  };\n\n  exports.NaNLiteral = NaNLiteral = class NaNLiteral extends NumberLiteral {\n    constructor() {\n      super('NaN');\n    }\n\n    compileNode(o) {\n      var code;\n      code = [this.makeCode('0/0')];\n      if (o.level >= LEVEL_OP) {\n        return this.wrapInParentheses(code);\n      } else {\n        return code;\n      }\n    }\n\n  };\n\n  exports.StringLiteral = StringLiteral = class StringLiteral extends Literal {\n    compileNode(o) {\n      var res;\n      return res = this.csx ? [this.makeCode(this.unquote(true, true))] : super.compileNode();\n    }\n\n    unquote(doubleQuote = false, newLine = false) {\n      var unquoted;\n      unquoted = this.value.slice(1, -1);\n      if (doubleQuote) {\n        unquoted = unquoted.replace(/\\\\\"/g, '\"');\n      }\n      if (newLine) {\n        unquoted = unquoted.replace(/\\\\n/g, '\\n');\n      }\n      return unquoted;\n    }\n\n  };\n\n  exports.RegexLiteral = RegexLiteral = class RegexLiteral extends Literal {};\n\n  exports.PassthroughLiteral = PassthroughLiteral = class PassthroughLiteral extends Literal {};\n\n  exports.IdentifierLiteral = IdentifierLiteral = (function() {\n    class IdentifierLiteral extends Literal {\n      eachName(iterator) {\n        return iterator(this);\n      }\n\n    };\n\n    IdentifierLiteral.prototype.isAssignable = YES;\n\n    return IdentifierLiteral;\n\n  }).call(this);\n\n  exports.CSXTag = CSXTag = class CSXTag extends IdentifierLiteral {};\n\n  exports.PropertyName = PropertyName = (function() {\n    class PropertyName extends Literal {};\n\n    PropertyName.prototype.isAssignable = YES;\n\n    return PropertyName;\n\n  }).call(this);\n\n  exports.ComputedPropertyName = ComputedPropertyName = class ComputedPropertyName extends PropertyName {\n    compileNode(o) {\n      return [this.makeCode('['), ...this.value.compileToFragments(o, LEVEL_LIST), this.makeCode(']')];\n    }\n\n  };\n\n  exports.StatementLiteral = StatementLiteral = (function() {\n    class StatementLiteral extends Literal {\n      jumps(o) {\n        if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {\n          return this;\n        }\n        if (this.value === 'continue' && !(o != null ? o.loop : void 0)) {\n          return this;\n        }\n      }\n\n      compileNode(o) {\n        return [this.makeCode(`${this.tab}${this.value};`)];\n      }\n\n    };\n\n    StatementLiteral.prototype.isStatement = YES;\n\n    StatementLiteral.prototype.makeReturn = THIS;\n\n    return StatementLiteral;\n\n  }).call(this);\n\n  exports.ThisLiteral = ThisLiteral = class ThisLiteral extends Literal {\n    constructor() {\n      super('this');\n    }\n\n    compileNode(o) {\n      var code, ref1;\n      code = ((ref1 = o.scope.method) != null ? ref1.bound : void 0) ? o.scope.method.context : this.value;\n      return [this.makeCode(code)];\n    }\n\n  };\n\n  exports.UndefinedLiteral = UndefinedLiteral = class UndefinedLiteral extends Literal {\n    constructor() {\n      super('undefined');\n    }\n\n    compileNode(o) {\n      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];\n    }\n\n  };\n\n  exports.NullLiteral = NullLiteral = class NullLiteral extends Literal {\n    constructor() {\n      super('null');\n    }\n\n  };\n\n  exports.BooleanLiteral = BooleanLiteral = class BooleanLiteral extends Literal {};\n\n  //### Return\n\n  // A `return` is a *pureStatement*âwrapping it in a closure wouldnât make sense.\n  exports.Return = Return = (function() {\n    class Return extends Base {\n      constructor(expression1) {\n        super();\n        this.expression = expression1;\n      }\n\n      compileToFragments(o, level) {\n        var expr, ref1;\n        expr = (ref1 = this.expression) != null ? ref1.makeReturn() : void 0;\n        if (expr && !(expr instanceof Return)) {\n          return expr.compileToFragments(o, level);\n        } else {\n          return super.compileToFragments(o, level);\n        }\n      }\n\n      compileNode(o) {\n        var answer, fragment, j, len1;\n        answer = [];\n        // TODO: If we call `expression.compile()` here twice, weâll sometimes\n        // get back different results!\n        if (this.expression) {\n          answer = this.expression.compileToFragments(o, LEVEL_PAREN);\n          unshiftAfterComments(answer, this.makeCode(`${this.tab}return `));\n// Since the `return` got indented by `@tab`, preceding comments that are\n// multiline need to be indented.\n          for (j = 0, len1 = answer.length; j < len1; j++) {\n            fragment = answer[j];\n            if (fragment.isHereComment && indexOf.call(fragment.code, '\\n') >= 0) {\n              fragment.code = multident(fragment.code, this.tab);\n            } else if (fragment.isLineComment) {\n              fragment.code = `${this.tab}${fragment.code}`;\n            } else {\n              break;\n            }\n          }\n        } else {\n          answer.push(this.makeCode(`${this.tab}return`));\n        }\n        answer.push(this.makeCode(';'));\n        return answer;\n      }\n\n    };\n\n    Return.prototype.children = ['expression'];\n\n    Return.prototype.isStatement = YES;\n\n    Return.prototype.makeReturn = THIS;\n\n    Return.prototype.jumps = THIS;\n\n    return Return;\n\n  }).call(this);\n\n  // `yield return` works exactly like `return`, except that it turns the function\n  // into a generator.\n  exports.YieldReturn = YieldReturn = class YieldReturn extends Return {\n    compileNode(o) {\n      if (o.scope.parent == null) {\n        this.error('yield can only occur inside functions');\n      }\n      return super.compileNode(o);\n    }\n\n  };\n\n  exports.AwaitReturn = AwaitReturn = class AwaitReturn extends Return {\n    compileNode(o) {\n      if (o.scope.parent == null) {\n        this.error('await can only occur inside functions');\n      }\n      return super.compileNode(o);\n    }\n\n  };\n\n  //### Value\n\n  // A value, variable or literal or parenthesized, indexed or dotted into,\n  // or vanilla.\n  exports.Value = Value = (function() {\n    class Value extends Base {\n      constructor(base, props, tag, isDefaultValue = false) {\n        var ref1, ref2;\n        super();\n        if (!props && base instanceof Value) {\n          return base;\n        }\n        this.base = base;\n        this.properties = props || [];\n        if (tag) {\n          this[tag] = true;\n        }\n        this.isDefaultValue = isDefaultValue;\n        // If this is a `@foo =` assignment, if there are comments on `@` move them\n        // to be on `foo`.\n        if (((ref1 = this.base) != null ? ref1.comments : void 0) && this.base instanceof ThisLiteral && (((ref2 = this.properties[0]) != null ? ref2.name : void 0) != null)) {\n          moveComments(this.base, this.properties[0].name);\n        }\n      }\n\n      // Add a property (or *properties* ) `Access` to the list.\n      add(props) {\n        this.properties = this.properties.concat(props);\n        this.forceUpdateLocation = true;\n        return this;\n      }\n\n      hasProperties() {\n        return this.properties.length !== 0;\n      }\n\n      bareLiteral(type) {\n        return !this.properties.length && this.base instanceof type;\n      }\n\n      // Some boolean checks for the benefit of other nodes.\n      isArray() {\n        return this.bareLiteral(Arr);\n      }\n\n      isRange() {\n        return this.bareLiteral(Range);\n      }\n\n      shouldCache() {\n        return this.hasProperties() || this.base.shouldCache();\n      }\n\n      isAssignable() {\n        return this.hasProperties() || this.base.isAssignable();\n      }\n\n      isNumber() {\n        return this.bareLiteral(NumberLiteral);\n      }\n\n      isString() {\n        return this.bareLiteral(StringLiteral);\n      }\n\n      isRegex() {\n        return this.bareLiteral(RegexLiteral);\n      }\n\n      isUndefined() {\n        return this.bareLiteral(UndefinedLiteral);\n      }\n\n      isNull() {\n        return this.bareLiteral(NullLiteral);\n      }\n\n      isBoolean() {\n        return this.bareLiteral(BooleanLiteral);\n      }\n\n      isAtomic() {\n        var j, len1, node, ref1;\n        ref1 = this.properties.concat(this.base);\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          node = ref1[j];\n          if (node.soak || node instanceof Call) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      isNotCallable() {\n        return this.isNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject() || this.isUndefined() || this.isNull() || this.isBoolean();\n      }\n\n      isStatement(o) {\n        return !this.properties.length && this.base.isStatement(o);\n      }\n\n      assigns(name) {\n        return !this.properties.length && this.base.assigns(name);\n      }\n\n      jumps(o) {\n        return !this.properties.length && this.base.jumps(o);\n      }\n\n      isObject(onlyGenerated) {\n        if (this.properties.length) {\n          return false;\n        }\n        return (this.base instanceof Obj) && (!onlyGenerated || this.base.generated);\n      }\n\n      isElision() {\n        if (!(this.base instanceof Arr)) {\n          return false;\n        }\n        return this.base.hasElision();\n      }\n\n      isSplice() {\n        var lastProp, ref1;\n        ref1 = this.properties, [lastProp] = slice1.call(ref1, -1);\n        return lastProp instanceof Slice;\n      }\n\n      looksStatic(className) {\n        var ref1;\n        return (this.this || this.base instanceof ThisLiteral || this.base.value === className) && this.properties.length === 1 && ((ref1 = this.properties[0].name) != null ? ref1.value : void 0) !== 'prototype';\n      }\n\n      // The value can be unwrapped as its inner node, if there are no attached\n      // properties.\n      unwrap() {\n        if (this.properties.length) {\n          return this;\n        } else {\n          return this.base;\n        }\n      }\n\n      // A reference has base part (`this` value) and name part.\n      // We cache them separately for compiling complex expressions.\n      // `a()[b()] ?= c` -> `(_base = a())[_name = b()] ? _base[_name] = c`\n      cacheReference(o) {\n        var base, bref, name, nref, ref1;\n        ref1 = this.properties, [name] = slice1.call(ref1, -1);\n        if (this.properties.length < 2 && !this.base.shouldCache() && !(name != null ? name.shouldCache() : void 0)) {\n          return [this, this]; // `a` `a.b`\n        }\n        base = new Value(this.base, this.properties.slice(0, -1));\n        if (base.shouldCache()) { // `a().b`\n          bref = new IdentifierLiteral(o.scope.freeVariable('base'));\n          base = new Value(new Parens(new Assign(bref, base)));\n        }\n        if (!name) { // `a()`\n          return [base, bref];\n        }\n        if (name.shouldCache()) { // `a[b()]`\n          nref = new IdentifierLiteral(o.scope.freeVariable('name'));\n          name = new Index(new Assign(nref, name.index));\n          nref = new Index(nref);\n        }\n        return [base.add(name), new Value(bref || base.base, [nref || name])];\n      }\n\n      // We compile a value to JavaScript by compiling and joining each property.\n      // Things get much more interesting if the chain of properties has *soak*\n      // operators `?.` interspersed. Then we have to take care not to accidentally\n      // evaluate anything twice when building the soak chain.\n      compileNode(o) {\n        var fragments, j, len1, prop, props;\n        this.checkNewTarget(o);\n        this.base.front = this.front;\n        props = this.properties;\n        if (props.length && (this.base.cached != null)) {\n          // Cached fragments enable correct order of the compilation,\n          // and reuse of variables in the scope.\n          // Example:\n          // `a(x = 5).b(-> x = 6)` should compile in the same order as\n          // `a(x = 5); b(-> x = 6)`\n          // (see issue #4437, https://github.com/jashkenas/coffeescript/issues/4437)\n          fragments = this.base.cached;\n        } else {\n          fragments = this.base.compileToFragments(o, (props.length ? LEVEL_ACCESS : null));\n        }\n        if (props.length && SIMPLENUM.test(fragmentsToText(fragments))) {\n          fragments.push(this.makeCode('.'));\n        }\n        for (j = 0, len1 = props.length; j < len1; j++) {\n          prop = props[j];\n          fragments.push(...(prop.compileToFragments(o)));\n        }\n        return fragments;\n      }\n\n      checkNewTarget(o) {\n        if (!(this.base instanceof IdentifierLiteral && this.base.value === 'new' && this.properties.length)) {\n          return;\n        }\n        if (this.properties[0] instanceof Access && this.properties[0].name.value === 'target') {\n          if (o.scope.parent == null) {\n            return this.error(\"new.target can only occur inside functions\");\n          }\n        } else {\n          return this.error(\"the only valid meta property for new is new.target\");\n        }\n      }\n\n      // Unfold a soak into an `If`: `a?.b` -> `a.b if a?`\n      unfoldSoak(o) {\n        return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (() => {\n          var fst, i, ifn, j, len1, prop, ref, ref1, snd;\n          ifn = this.base.unfoldSoak(o);\n          if (ifn) {\n            ifn.body.properties.push(...this.properties);\n            return ifn;\n          }\n          ref1 = this.properties;\n          for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {\n            prop = ref1[i];\n            if (!prop.soak) {\n              continue;\n            }\n            prop.soak = false;\n            fst = new Value(this.base, this.properties.slice(0, i));\n            snd = new Value(this.base, this.properties.slice(i));\n            if (fst.shouldCache()) {\n              ref = new IdentifierLiteral(o.scope.freeVariable('ref'));\n              fst = new Parens(new Assign(ref, fst));\n              snd.base = ref;\n            }\n            return new If(new Existence(fst), snd, {\n              soak: true\n            });\n          }\n          return false;\n        })();\n      }\n\n      eachName(iterator) {\n        if (this.hasProperties()) {\n          return iterator(this);\n        } else if (this.base.isAssignable()) {\n          return this.base.eachName(iterator);\n        } else {\n          return this.error('tried to assign to unassignable value');\n        }\n      }\n\n    };\n\n    Value.prototype.children = ['base', 'properties'];\n\n    return Value;\n\n  }).call(this);\n\n  //### HereComment\n\n  // Comment delimited by `###` (becoming `/* */`).\n  exports.HereComment = HereComment = class HereComment extends Base {\n    constructor({\n        content: content1,\n        newLine: newLine1,\n        unshift\n      }) {\n      super();\n      this.content = content1;\n      this.newLine = newLine1;\n      this.unshift = unshift;\n    }\n\n    compileNode(o) {\n      var fragment, hasLeadingMarks, j, largestIndent, leadingWhitespace, len1, line, multiline, ref1;\n      multiline = indexOf.call(this.content, '\\n') >= 0;\n      hasLeadingMarks = /\\n\\s*[#|\\*]/.test(this.content);\n      if (hasLeadingMarks) {\n        this.content = this.content.replace(/^([ \\t]*)#(?=\\s)/gm, ' *');\n      }\n      // Unindent multiline comments. They will be reindented later.\n      if (multiline) {\n        largestIndent = '';\n        ref1 = this.content.split('\\n');\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          line = ref1[j];\n          leadingWhitespace = /^\\s*/.exec(line)[0];\n          if (leadingWhitespace.length > largestIndent.length) {\n            largestIndent = leadingWhitespace;\n          }\n        }\n        this.content = this.content.replace(RegExp(`^(${leadingWhitespace})`, \"gm\"), '');\n      }\n      this.content = `/*${this.content}${(hasLeadingMarks ? ' ' : '')}*/`;\n      fragment = this.makeCode(this.content);\n      fragment.newLine = this.newLine;\n      fragment.unshift = this.unshift;\n      fragment.multiline = multiline;\n      // Donât rely on `fragment.type`, which can break when the compiler is minified.\n      fragment.isComment = fragment.isHereComment = true;\n      return fragment;\n    }\n\n  };\n\n  //### LineComment\n\n  // Comment running from `#` to the end of a line (becoming `//`).\n  exports.LineComment = LineComment = class LineComment extends Base {\n    constructor({\n        content: content1,\n        newLine: newLine1,\n        unshift\n      }) {\n      super();\n      this.content = content1;\n      this.newLine = newLine1;\n      this.unshift = unshift;\n    }\n\n    compileNode(o) {\n      var fragment;\n      fragment = this.makeCode(/^\\s*$/.test(this.content) ? '' : `//${this.content}`);\n      fragment.newLine = this.newLine;\n      fragment.unshift = this.unshift;\n      fragment.trail = !this.newLine && !this.unshift;\n      // Donât rely on `fragment.type`, which can break when the compiler is minified.\n      fragment.isComment = fragment.isLineComment = true;\n      return fragment;\n    }\n\n  };\n\n  //### Call\n\n  // Node for a function invocation.\n  exports.Call = Call = (function() {\n    class Call extends Base {\n      constructor(variable1, args1 = [], soak1, token1) {\n        var ref1;\n        super();\n        this.variable = variable1;\n        this.args = args1;\n        this.soak = soak1;\n        this.token = token1;\n        this.isNew = false;\n        if (this.variable instanceof Value && this.variable.isNotCallable()) {\n          this.variable.error(\"literal is not a function\");\n        }\n        this.csx = this.variable.base instanceof CSXTag;\n        // `@variable` never gets output as a result of this node getting created as\n        // part of `RegexWithInterpolations`, so for that case move any comments to\n        // the `args` property that gets passed into `RegexWithInterpolations` via\n        // the grammar.\n        if (((ref1 = this.variable.base) != null ? ref1.value : void 0) === 'RegExp' && this.args.length !== 0) {\n          moveComments(this.variable, this.args[0]);\n        }\n      }\n\n      // When setting the location, we sometimes need to update the start location to\n      // account for a newly-discovered `new` operator to the left of us. This\n      // expands the range on the left, but not the right.\n      updateLocationDataIfMissing(locationData) {\n        var base, ref1;\n        if (this.locationData && this.needsUpdatedStartLocation) {\n          this.locationData.first_line = locationData.first_line;\n          this.locationData.first_column = locationData.first_column;\n          base = ((ref1 = this.variable) != null ? ref1.base : void 0) || this.variable;\n          if (base.needsUpdatedStartLocation) {\n            this.variable.locationData.first_line = locationData.first_line;\n            this.variable.locationData.first_column = locationData.first_column;\n            base.updateLocationDataIfMissing(locationData);\n          }\n          delete this.needsUpdatedStartLocation;\n        }\n        return super.updateLocationDataIfMissing(locationData);\n      }\n\n      // Tag this invocation as creating a new instance.\n      newInstance() {\n        var base, ref1;\n        base = ((ref1 = this.variable) != null ? ref1.base : void 0) || this.variable;\n        if (base instanceof Call && !base.isNew) {\n          base.newInstance();\n        } else {\n          this.isNew = true;\n        }\n        this.needsUpdatedStartLocation = true;\n        return this;\n      }\n\n      // Soaked chained invocations unfold into if/else ternary structures.\n      unfoldSoak(o) {\n        var call, ifn, j, left, len1, list, ref1, rite;\n        if (this.soak) {\n          if (this.variable instanceof Super) {\n            left = new Literal(this.variable.compile(o));\n            rite = new Value(left);\n            if (this.variable.accessor == null) {\n              this.variable.error(\"Unsupported reference to 'super'\");\n            }\n          } else {\n            if (ifn = unfoldSoak(o, this, 'variable')) {\n              return ifn;\n            }\n            [left, rite] = new Value(this.variable).cacheReference(o);\n          }\n          rite = new Call(rite, this.args);\n          rite.isNew = this.isNew;\n          left = new Literal(`typeof ${left.compile(o)} === \"function\"`);\n          return new If(left, new Value(rite), {\n            soak: true\n          });\n        }\n        call = this;\n        list = [];\n        while (true) {\n          if (call.variable instanceof Call) {\n            list.push(call);\n            call = call.variable;\n            continue;\n          }\n          if (!(call.variable instanceof Value)) {\n            break;\n          }\n          list.push(call);\n          if (!((call = call.variable.base) instanceof Call)) {\n            break;\n          }\n        }\n        ref1 = list.reverse();\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          call = ref1[j];\n          if (ifn) {\n            if (call.variable instanceof Call) {\n              call.variable = ifn;\n            } else {\n              call.variable.base = ifn;\n            }\n          }\n          ifn = unfoldSoak(o, call, 'variable');\n        }\n        return ifn;\n      }\n\n      // Compile a vanilla function call.\n      compileNode(o) {\n        var arg, argCode, argIndex, cache, compiledArgs, fragments, j, len1, ref1, ref2, ref3, ref4, varAccess;\n        if (this.csx) {\n          return this.compileCSX(o);\n        }\n        if ((ref1 = this.variable) != null) {\n          ref1.front = this.front;\n        }\n        compiledArgs = [];\n        // If variable is `Accessor` fragments are cached and used later\n        // in `Value::compileNode` to ensure correct order of the compilation,\n        // and reuse of variables in the scope.\n        // Example:\n        // `a(x = 5).b(-> x = 6)` should compile in the same order as\n        // `a(x = 5); b(-> x = 6)`\n        // (see issue #4437, https://github.com/jashkenas/coffeescript/issues/4437)\n        varAccess = ((ref2 = this.variable) != null ? (ref3 = ref2.properties) != null ? ref3[0] : void 0 : void 0) instanceof Access;\n        argCode = (function() {\n          var j, len1, ref4, results;\n          ref4 = this.args || [];\n          results = [];\n          for (j = 0, len1 = ref4.length; j < len1; j++) {\n            arg = ref4[j];\n            if (arg instanceof Code) {\n              results.push(arg);\n            }\n          }\n          return results;\n        }).call(this);\n        if (argCode.length > 0 && varAccess && !this.variable.base.cached) {\n          [cache] = this.variable.base.cache(o, LEVEL_ACCESS, function() {\n            return false;\n          });\n          this.variable.base.cached = cache;\n        }\n        ref4 = this.args;\n        for (argIndex = j = 0, len1 = ref4.length; j < len1; argIndex = ++j) {\n          arg = ref4[argIndex];\n          if (argIndex) {\n            compiledArgs.push(this.makeCode(\", \"));\n          }\n          compiledArgs.push(...(arg.compileToFragments(o, LEVEL_LIST)));\n        }\n        fragments = [];\n        if (this.isNew) {\n          if (this.variable instanceof Super) {\n            this.variable.error(\"Unsupported reference to 'super'\");\n          }\n          fragments.push(this.makeCode('new '));\n        }\n        fragments.push(...this.variable.compileToFragments(o, LEVEL_ACCESS));\n        fragments.push(this.makeCode('('), ...compiledArgs, this.makeCode(')'));\n        return fragments;\n      }\n\n      compileCSX(o) {\n        var attr, attrProps, attributes, content, fragments, j, len1, obj, ref1, tag;\n        [attributes, content] = this.args;\n        attributes.base.csx = true;\n        if (content != null) {\n          content.base.csx = true;\n        }\n        fragments = [this.makeCode('<')];\n        fragments.push(...(tag = this.variable.compileToFragments(o, LEVEL_ACCESS)));\n        if (attributes.base instanceof Arr) {\n          ref1 = attributes.base.objects;\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            obj = ref1[j];\n            attr = obj.base;\n            attrProps = (attr != null ? attr.properties : void 0) || [];\n            // Catch invalid CSX attributes: <div {a:\"b\", props} {props} \"value\" />\n            if (!(attr instanceof Obj || attr instanceof IdentifierLiteral) || (attr instanceof Obj && !attr.generated && (attrProps.length > 1 || !(attrProps[0] instanceof Splat)))) {\n              obj.error(\"Unexpected token. Allowed CSX attributes are: id=\\\"val\\\", src={source}, {props...} or attribute.\");\n            }\n            if (obj.base instanceof Obj) {\n              obj.base.csx = true;\n            }\n            fragments.push(this.makeCode(' '));\n            fragments.push(...obj.compileToFragments(o, LEVEL_PAREN));\n          }\n        }\n        if (content) {\n          fragments.push(this.makeCode('>'));\n          fragments.push(...content.compileNode(o, LEVEL_LIST));\n          fragments.push(...[this.makeCode('</'), ...tag, this.makeCode('>')]);\n        } else {\n          fragments.push(this.makeCode(' />'));\n        }\n        return fragments;\n      }\n\n    };\n\n    Call.prototype.children = ['variable', 'args'];\n\n    return Call;\n\n  }).call(this);\n\n  //### Super\n\n  // Takes care of converting `super()` calls into calls against the prototype's\n  // function of the same name.\n  // When `expressions` are set the call will be compiled in such a way that the\n  // expressions are evaluated without altering the return value of the `SuperCall`\n  // expression.\n  exports.SuperCall = SuperCall = (function() {\n    class SuperCall extends Call {\n      isStatement(o) {\n        var ref1;\n        return ((ref1 = this.expressions) != null ? ref1.length : void 0) && o.level === LEVEL_TOP;\n      }\n\n      compileNode(o) {\n        var ref, ref1, replacement, superCall;\n        if (!((ref1 = this.expressions) != null ? ref1.length : void 0)) {\n          return super.compileNode(o);\n        }\n        superCall = new Literal(fragmentsToText(super.compileNode(o)));\n        replacement = new Block(this.expressions.slice());\n        if (o.level > LEVEL_TOP) {\n          // If we might be in an expression we need to cache and return the result\n          [superCall, ref] = superCall.cache(o, null, YES);\n          replacement.push(ref);\n        }\n        replacement.unshift(superCall);\n        return replacement.compileToFragments(o, o.level === LEVEL_TOP ? o.level : LEVEL_LIST);\n      }\n\n    };\n\n    SuperCall.prototype.children = Call.prototype.children.concat(['expressions']);\n\n    return SuperCall;\n\n  }).call(this);\n\n  exports.Super = Super = (function() {\n    class Super extends Base {\n      constructor(accessor) {\n        super();\n        this.accessor = accessor;\n      }\n\n      compileNode(o) {\n        var fragments, method, name, nref, ref1, ref2, salvagedComments, variable;\n        method = o.scope.namedMethod();\n        if (!(method != null ? method.isMethod : void 0)) {\n          this.error('cannot use super outside of an instance method');\n        }\n        if (!((method.ctor != null) || (this.accessor != null))) {\n          ({name, variable} = method);\n          if (name.shouldCache() || (name instanceof Index && name.index.isAssignable())) {\n            nref = new IdentifierLiteral(o.scope.parent.freeVariable('name'));\n            name.index = new Assign(nref, name.index);\n          }\n          this.accessor = nref != null ? new Index(nref) : name;\n        }\n        if ((ref1 = this.accessor) != null ? (ref2 = ref1.name) != null ? ref2.comments : void 0 : void 0) {\n          // A `super()` call gets compiled to e.g. `super.method()`, which means\n          // the `method` property name gets compiled for the first time here, and\n          // again when the `method:` property of the class gets compiled. Since\n          // this compilation happens first, comments attached to `method:` would\n          // get incorrectly output near `super.method()`, when we want them to\n          // get output on the second pass when `method:` is output. So set them\n          // aside during this compilation pass, and put them back on the object so\n          // that theyâre there for the later compilation.\n          salvagedComments = this.accessor.name.comments;\n          delete this.accessor.name.comments;\n        }\n        fragments = (new Value(new Literal('super'), this.accessor ? [this.accessor] : [])).compileToFragments(o);\n        if (salvagedComments) {\n          attachCommentsToNode(salvagedComments, this.accessor.name);\n        }\n        return fragments;\n      }\n\n    };\n\n    Super.prototype.children = ['accessor'];\n\n    return Super;\n\n  }).call(this);\n\n  //### RegexWithInterpolations\n\n  // Regexes with interpolations are in fact just a variation of a `Call` (a\n  // `RegExp()` call to be precise) with a `StringWithInterpolations` inside.\n  exports.RegexWithInterpolations = RegexWithInterpolations = class RegexWithInterpolations extends Call {\n    constructor(args = []) {\n      super(new Value(new IdentifierLiteral('RegExp')), args, false);\n    }\n\n  };\n\n  //### TaggedTemplateCall\n  exports.TaggedTemplateCall = TaggedTemplateCall = class TaggedTemplateCall extends Call {\n    constructor(variable, arg, soak) {\n      if (arg instanceof StringLiteral) {\n        arg = new StringWithInterpolations(Block.wrap([new Value(arg)]));\n      }\n      super(variable, [arg], soak);\n    }\n\n    compileNode(o) {\n      return this.variable.compileToFragments(o, LEVEL_ACCESS).concat(this.args[0].compileToFragments(o, LEVEL_LIST));\n    }\n\n  };\n\n  //### Extends\n\n  // Node to extend an object's prototype with an ancestor object.\n  // After `goog.inherits` from the\n  // [Closure Library](https://github.com/google/closure-library/blob/master/closure/goog/base.js).\n  exports.Extends = Extends = (function() {\n    class Extends extends Base {\n      constructor(child1, parent1) {\n        super();\n        this.child = child1;\n        this.parent = parent1;\n      }\n\n      // Hooks one constructor into another's prototype chain.\n      compileToFragments(o) {\n        return new Call(new Value(new Literal(utility('extend', o))), [this.child, this.parent]).compileToFragments(o);\n      }\n\n    };\n\n    Extends.prototype.children = ['child', 'parent'];\n\n    return Extends;\n\n  }).call(this);\n\n  //### Access\n\n  // A `.` access into a property of a value, or the `::` shorthand for\n  // an access into the object's prototype.\n  exports.Access = Access = (function() {\n    class Access extends Base {\n      constructor(name1, tag) {\n        super();\n        this.name = name1;\n        this.soak = tag === 'soak';\n      }\n\n      compileToFragments(o) {\n        var name, node;\n        name = this.name.compileToFragments(o);\n        node = this.name.unwrap();\n        if (node instanceof PropertyName) {\n          return [this.makeCode('.'), ...name];\n        } else {\n          return [this.makeCode('['), ...name, this.makeCode(']')];\n        }\n      }\n\n    };\n\n    Access.prototype.children = ['name'];\n\n    Access.prototype.shouldCache = NO;\n\n    return Access;\n\n  }).call(this);\n\n  //### Index\n\n  // A `[ ... ]` indexed access into an array or object.\n  exports.Index = Index = (function() {\n    class Index extends Base {\n      constructor(index1) {\n        super();\n        this.index = index1;\n      }\n\n      compileToFragments(o) {\n        return [].concat(this.makeCode(\"[\"), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode(\"]\"));\n      }\n\n      shouldCache() {\n        return this.index.shouldCache();\n      }\n\n    };\n\n    Index.prototype.children = ['index'];\n\n    return Index;\n\n  }).call(this);\n\n  //### Range\n\n  // A range literal. Ranges can be used to extract portions (slices) of arrays,\n  // to specify a range for comprehensions, or as a value, to be expanded into the\n  // corresponding array of integers at runtime.\n  exports.Range = Range = (function() {\n    class Range extends Base {\n      constructor(from1, to1, tag) {\n        super();\n        this.from = from1;\n        this.to = to1;\n        this.exclusive = tag === 'exclusive';\n        this.equals = this.exclusive ? '' : '=';\n      }\n\n      // Compiles the range's source variables -- where it starts and where it ends.\n      // But only if they need to be cached to avoid double evaluation.\n      compileVariables(o) {\n        var shouldCache, step;\n        o = merge(o, {\n          top: true\n        });\n        shouldCache = del(o, 'shouldCache');\n        [this.fromC, this.fromVar] = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST, shouldCache));\n        [this.toC, this.toVar] = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST, shouldCache));\n        if (step = del(o, 'step')) {\n          [this.step, this.stepVar] = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST, shouldCache));\n        }\n        this.fromNum = this.from.isNumber() ? Number(this.fromVar) : null;\n        this.toNum = this.to.isNumber() ? Number(this.toVar) : null;\n        return this.stepNum = (step != null ? step.isNumber() : void 0) ? Number(this.stepVar) : null;\n      }\n\n      // When compiled normally, the range returns the contents of the *for loop*\n      // needed to iterate over the values in the range. Used by comprehensions.\n      compileNode(o) {\n        var cond, condPart, from, gt, idx, idxName, known, lowerBound, lt, namedIndex, ref1, ref2, stepCond, stepNotZero, stepPart, to, upperBound, varPart;\n        if (!this.fromVar) {\n          this.compileVariables(o);\n        }\n        if (!o.index) {\n          return this.compileArray(o);\n        }\n        // Set up endpoints.\n        known = (this.fromNum != null) && (this.toNum != null);\n        idx = del(o, 'index');\n        idxName = del(o, 'name');\n        namedIndex = idxName && idxName !== idx;\n        varPart = known && !namedIndex ? `var ${idx} = ${this.fromC}` : `${idx} = ${this.fromC}`;\n        if (this.toC !== this.toVar) {\n          varPart += `, ${this.toC}`;\n        }\n        if (this.step !== this.stepVar) {\n          varPart += `, ${this.step}`;\n        }\n        [lt, gt] = [`${idx} <${this.equals}`, `${idx} >${this.equals}`];\n        // Generate the condition.\n        [from, to] = [this.fromNum, this.toNum];\n        // Always check if the `step` isn't zero to avoid the infinite loop.\n        stepNotZero = `${(ref1 = this.stepNum) != null ? ref1 : this.stepVar} !== 0`;\n        stepCond = `${(ref2 = this.stepNum) != null ? ref2 : this.stepVar} > 0`;\n        lowerBound = `${lt} ${(known ? to : this.toVar)}`;\n        upperBound = `${gt} ${(known ? to : this.toVar)}`;\n        condPart = this.step != null ? (this.stepNum != null) && this.stepNum !== 0 ? this.stepNum > 0 ? `${lowerBound}` : `${upperBound}` : `${stepNotZero} && (${stepCond} ? ${lowerBound} : ${upperBound})` : known ? `${(from <= to ? lt : gt)} ${to}` : `(${this.fromVar} <= ${this.toVar} ? ${lowerBound} : ${upperBound})`;\n        cond = this.stepVar ? `${this.stepVar} > 0` : `${this.fromVar} <= ${this.toVar}`;\n        // Generate the step.\n        stepPart = this.stepVar ? `${idx} += ${this.stepVar}` : known ? namedIndex ? from <= to ? `++${idx}` : `--${idx}` : from <= to ? `${idx}++` : `${idx}--` : namedIndex ? `${cond} ? ++${idx} : --${idx}` : `${cond} ? ${idx}++ : ${idx}--`;\n        if (namedIndex) {\n          varPart = `${idxName} = ${varPart}`;\n        }\n        if (namedIndex) {\n          stepPart = `${idxName} = ${stepPart}`;\n        }\n        // The final loop body.\n        return [this.makeCode(`${varPart}; ${condPart}; ${stepPart}`)];\n      }\n\n      // When used as a value, expand the range into the equivalent array.\n      compileArray(o) {\n        var args, body, cond, hasArgs, i, idt, known, post, pre, range, ref1, ref2, result, vars;\n        known = (this.fromNum != null) && (this.toNum != null);\n        if (known && Math.abs(this.fromNum - this.toNum) <= 20) {\n          range = (function() {\n            var results = [];\n            for (var j = ref1 = this.fromNum, ref2 = this.toNum; ref1 <= ref2 ? j <= ref2 : j >= ref2; ref1 <= ref2 ? j++ : j--){ results.push(j); }\n            return results;\n          }).apply(this);\n          if (this.exclusive) {\n            range.pop();\n          }\n          return [this.makeCode(`[${range.join(', ')}]`)];\n        }\n        idt = this.tab + TAB;\n        i = o.scope.freeVariable('i', {\n          single: true,\n          reserve: false\n        });\n        result = o.scope.freeVariable('results', {\n          reserve: false\n        });\n        pre = `\\n${idt}var ${result} = [];`;\n        if (known) {\n          o.index = i;\n          body = fragmentsToText(this.compileNode(o));\n        } else {\n          vars = `${i} = ${this.fromC}` + (this.toC !== this.toVar ? `, ${this.toC}` : '');\n          cond = `${this.fromVar} <= ${this.toVar}`;\n          body = `var ${vars}; ${cond} ? ${i} <${this.equals} ${this.toVar} : ${i} >${this.equals} ${this.toVar}; ${cond} ? ${i}++ : ${i}--`;\n        }\n        post = `{ ${result}.push(${i}); }\\n${idt}return ${result};\\n${o.indent}`;\n        hasArgs = function(node) {\n          return node != null ? node.contains(isLiteralArguments) : void 0;\n        };\n        if (hasArgs(this.from) || hasArgs(this.to)) {\n          args = ', arguments';\n        }\n        return [this.makeCode(`(function() {${pre}\\n${idt}for (${body})${post}}).apply(this${args != null ? args : ''})`)];\n      }\n\n    };\n\n    Range.prototype.children = ['from', 'to'];\n\n    return Range;\n\n  }).call(this);\n\n  //### Slice\n\n  // An array slice literal. Unlike JavaScript's `Array#slice`, the second parameter\n  // specifies the index of the end of the slice, just as the first parameter\n  // is the index of the beginning.\n  exports.Slice = Slice = (function() {\n    class Slice extends Base {\n      constructor(range1) {\n        super();\n        this.range = range1;\n      }\n\n      // We have to be careful when trying to slice through the end of the array,\n      // `9e9` is used because not all implementations respect `undefined` or `1/0`.\n      // `9e9` should be safe because `9e9` > `2**32`, the max array length.\n      compileNode(o) {\n        var compiled, compiledText, from, fromCompiled, to, toStr;\n        ({to, from} = this.range);\n        // Handle an expression in the property access, e.g. `a[!b in c..]`.\n        if (from != null ? from.shouldCache() : void 0) {\n          from = new Value(new Parens(from));\n        }\n        if (to != null ? to.shouldCache() : void 0) {\n          to = new Value(new Parens(to));\n        }\n        fromCompiled = (from != null ? from.compileToFragments(o, LEVEL_PAREN) : void 0) || [this.makeCode('0')];\n        if (to) {\n          compiled = to.compileToFragments(o, LEVEL_PAREN);\n          compiledText = fragmentsToText(compiled);\n          if (!(!this.range.exclusive && +compiledText === -1)) {\n            toStr = ', ' + (this.range.exclusive ? compiledText : to.isNumber() ? `${+compiledText + 1}` : (compiled = to.compileToFragments(o, LEVEL_ACCESS), `+${fragmentsToText(compiled)} + 1 || 9e9`));\n          }\n        }\n        return [this.makeCode(`.slice(${fragmentsToText(fromCompiled)}${toStr || ''})`)];\n      }\n\n    };\n\n    Slice.prototype.children = ['range'];\n\n    return Slice;\n\n  }).call(this);\n\n  //### Obj\n\n  // An object literal, nothing fancy.\n  exports.Obj = Obj = (function() {\n    class Obj extends Base {\n      constructor(props, generated = false, lhs1 = false) {\n        super();\n        this.generated = generated;\n        this.lhs = lhs1;\n        this.objects = this.properties = props || [];\n      }\n\n      isAssignable() {\n        var j, len1, message, prop, ref1, ref2;\n        ref1 = this.properties;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          prop = ref1[j];\n          // Check for reserved words.\n          message = isUnassignable(prop.unwrapAll().value);\n          if (message) {\n            prop.error(message);\n          }\n          if (prop instanceof Assign && prop.context === 'object' && !(((ref2 = prop.value) != null ? ref2.base : void 0) instanceof Arr)) {\n            prop = prop.value;\n          }\n          if (!prop.isAssignable()) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      shouldCache() {\n        return !this.isAssignable();\n      }\n\n      // Check if object contains splat.\n      hasSplat() {\n        var j, len1, prop, ref1;\n        ref1 = this.properties;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          prop = ref1[j];\n          if (prop instanceof Splat) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // Move rest property to the end of the list.\n      // `{a, rest..., b} = obj` -> `{a, b, rest...} = obj`\n      // `foo = ({a, rest..., b}) ->` -> `foo = {a, b, rest...}) ->`\n      reorderProperties() {\n        var i, prop, props, splatProp, splatProps;\n        props = this.properties;\n        splatProps = (function() {\n          var j, len1, results;\n          results = [];\n          for (i = j = 0, len1 = props.length; j < len1; i = ++j) {\n            prop = props[i];\n            if (prop instanceof Splat) {\n              results.push(i);\n            }\n          }\n          return results;\n        })();\n        if ((splatProps != null ? splatProps.length : void 0) > 1) {\n          props[splatProps[1]].error(\"multiple spread elements are disallowed\");\n        }\n        splatProp = props.splice(splatProps[0], 1);\n        return this.objects = this.properties = [].concat(props, splatProp);\n      }\n\n      compileNode(o) {\n        var answer, i, idt, indent, isCompact, j, join, k, key, l, lastNode, len1, len2, len3, len4, node, p, prop, props, ref1, unwrappedVal, value;\n        if (this.hasSplat() && this.lhs) {\n          this.reorderProperties();\n        }\n        props = this.properties;\n        if (this.generated) {\n          for (j = 0, len1 = props.length; j < len1; j++) {\n            node = props[j];\n            if (node instanceof Value) {\n              node.error('cannot have an implicit value in an implicit object');\n            }\n          }\n        }\n        idt = o.indent += TAB;\n        lastNode = this.lastNode(this.properties);\n        if (this.csx) {\n          // CSX attributes <div id=\"val\" attr={aaa} {props...} />\n          return this.compileCSXAttributes(o);\n        }\n        // If this object is the left-hand side of an assignment, all its children\n        // are too.\n        if (this.lhs) {\n          for (k = 0, len2 = props.length; k < len2; k++) {\n            prop = props[k];\n            if (!(prop instanceof Assign)) {\n              continue;\n            }\n            ({value} = prop);\n            unwrappedVal = value.unwrapAll();\n            if (unwrappedVal instanceof Arr || unwrappedVal instanceof Obj) {\n              unwrappedVal.lhs = true;\n            } else if (unwrappedVal instanceof Assign) {\n              unwrappedVal.nestedLhs = true;\n            }\n          }\n        }\n        isCompact = true;\n        ref1 = this.properties;\n        for (l = 0, len3 = ref1.length; l < len3; l++) {\n          prop = ref1[l];\n          if (prop instanceof Assign && prop.context === 'object') {\n            isCompact = false;\n          }\n        }\n        answer = [];\n        answer.push(this.makeCode(isCompact ? '' : '\\n'));\n        for (i = p = 0, len4 = props.length; p < len4; i = ++p) {\n          prop = props[i];\n          join = i === props.length - 1 ? '' : isCompact ? ', ' : prop === lastNode ? '\\n' : ',\\n';\n          indent = isCompact ? '' : idt;\n          key = prop instanceof Assign && prop.context === 'object' ? prop.variable : prop instanceof Assign ? (!this.lhs ? prop.operatorToken.error(`unexpected ${prop.operatorToken.value}`) : void 0, prop.variable) : prop;\n          if (key instanceof Value && key.hasProperties()) {\n            if (prop.context === 'object' || !key.this) {\n              key.error('invalid object key');\n            }\n            key = key.properties[0].name;\n            prop = new Assign(key, prop, 'object');\n          }\n          if (key === prop) {\n            if (prop.shouldCache()) {\n              [key, value] = prop.base.cache(o);\n              if (key instanceof IdentifierLiteral) {\n                key = new PropertyName(key.value);\n              }\n              prop = new Assign(key, value, 'object');\n            } else if (key instanceof Value && key.base instanceof ComputedPropertyName) {\n              // `{ [foo()] }` output as `{ [ref = foo()]: ref }`.\n              if (prop.base.value.shouldCache()) {\n                [key, value] = prop.base.value.cache(o);\n                if (key instanceof IdentifierLiteral) {\n                  key = new ComputedPropertyName(key.value);\n                }\n                prop = new Assign(key, value, 'object');\n              } else {\n                // `{ [expression] }` output as `{ [expression]: expression }`.\n                prop = new Assign(key, prop.base.value, 'object');\n              }\n            } else if (!(typeof prop.bareLiteral === \"function\" ? prop.bareLiteral(IdentifierLiteral) : void 0) && !(prop instanceof Splat)) {\n              prop = new Assign(prop, prop, 'object');\n            }\n          }\n          if (indent) {\n            answer.push(this.makeCode(indent));\n          }\n          answer.push(...prop.compileToFragments(o, LEVEL_TOP));\n          if (join) {\n            answer.push(this.makeCode(join));\n          }\n        }\n        answer.push(this.makeCode(isCompact ? '' : `\\n${this.tab}`));\n        answer = this.wrapInBraces(answer);\n        if (this.front) {\n          return this.wrapInParentheses(answer);\n        } else {\n          return answer;\n        }\n      }\n\n      assigns(name) {\n        var j, len1, prop, ref1;\n        ref1 = this.properties;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          prop = ref1[j];\n          if (prop.assigns(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      eachName(iterator) {\n        var j, len1, prop, ref1, results;\n        ref1 = this.properties;\n        results = [];\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          prop = ref1[j];\n          if (prop instanceof Assign && prop.context === 'object') {\n            prop = prop.value;\n          }\n          prop = prop.unwrapAll();\n          if (prop.eachName != null) {\n            results.push(prop.eachName(iterator));\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      }\n\n      compileCSXAttributes(o) {\n        var answer, i, j, join, len1, prop, props;\n        props = this.properties;\n        answer = [];\n        for (i = j = 0, len1 = props.length; j < len1; i = ++j) {\n          prop = props[i];\n          prop.csx = true;\n          join = i === props.length - 1 ? '' : ' ';\n          if (prop instanceof Splat) {\n            prop = new Literal(`{${prop.compile(o)}}`);\n          }\n          answer.push(...prop.compileToFragments(o, LEVEL_TOP));\n          answer.push(this.makeCode(join));\n        }\n        if (this.front) {\n          return this.wrapInParentheses(answer);\n        } else {\n          return answer;\n        }\n      }\n\n    };\n\n    Obj.prototype.children = ['properties'];\n\n    return Obj;\n\n  }).call(this);\n\n  //### Arr\n\n  // An array literal.\n  exports.Arr = Arr = (function() {\n    class Arr extends Base {\n      constructor(objs, lhs1 = false) {\n        super();\n        this.lhs = lhs1;\n        this.objects = objs || [];\n      }\n\n      hasElision() {\n        var j, len1, obj, ref1;\n        ref1 = this.objects;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          obj = ref1[j];\n          if (obj instanceof Elision) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      isAssignable() {\n        var i, j, len1, obj, ref1;\n        if (!this.objects.length) {\n          return false;\n        }\n        ref1 = this.objects;\n        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {\n          obj = ref1[i];\n          if (obj instanceof Splat && i + 1 !== this.objects.length) {\n            return false;\n          }\n          if (!(obj.isAssignable() && (!obj.isAtomic || obj.isAtomic()))) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      shouldCache() {\n        return !this.isAssignable();\n      }\n\n      compileNode(o) {\n        var answer, compiledObjs, fragment, fragmentIndex, fragmentIsElision, fragments, includesLineCommentsOnNonFirstElement, index, j, k, l, len1, len2, len3, len4, len5, obj, objIndex, olen, p, passedElision, q, ref1, unwrappedObj;\n        if (!this.objects.length) {\n          return [this.makeCode('[]')];\n        }\n        o.indent += TAB;\n        fragmentIsElision = function(fragment) {\n          return fragmentsToText(fragment).trim() === ',';\n        };\n        // Detect if `Elisions` at the beginning of the array are processed (e.g. [, , , a]).\n        passedElision = false;\n        answer = [];\n        ref1 = this.objects;\n        for (objIndex = j = 0, len1 = ref1.length; j < len1; objIndex = ++j) {\n          obj = ref1[objIndex];\n          unwrappedObj = obj.unwrapAll();\n          // Let `compileCommentFragments` know to intersperse block comments\n          // into the fragments created when compiling this array.\n          if (unwrappedObj.comments && unwrappedObj.comments.filter(function(comment) {\n            return !comment.here;\n          }).length === 0) {\n            unwrappedObj.includeCommentFragments = YES;\n          }\n          // If this array is the left-hand side of an assignment, all its children\n          // are too.\n          if (this.lhs) {\n            if (unwrappedObj instanceof Arr || unwrappedObj instanceof Obj) {\n              unwrappedObj.lhs = true;\n            }\n          }\n        }\n        compiledObjs = (function() {\n          var k, len2, ref2, results;\n          ref2 = this.objects;\n          results = [];\n          for (k = 0, len2 = ref2.length; k < len2; k++) {\n            obj = ref2[k];\n            results.push(obj.compileToFragments(o, LEVEL_LIST));\n          }\n          return results;\n        }).call(this);\n        olen = compiledObjs.length;\n        // If `compiledObjs` includes newlines, we will output this as a multiline\n        // array (i.e. with a newline and indentation after the `[`). If an element\n        // contains line comments, that should also trigger multiline output since\n        // by definition line comments will introduce newlines into our output.\n        // The exception is if only the first element has line comments; in that\n        // case, output as the compact form if we otherwise would have, so that the\n        // first elementâs line comments get output before or after the array.\n        includesLineCommentsOnNonFirstElement = false;\n        for (index = k = 0, len2 = compiledObjs.length; k < len2; index = ++k) {\n          fragments = compiledObjs[index];\n          for (l = 0, len3 = fragments.length; l < len3; l++) {\n            fragment = fragments[l];\n            if (fragment.isHereComment) {\n              fragment.code = fragment.code.trim();\n            } else if (index !== 0 && includesLineCommentsOnNonFirstElement === false && hasLineComments(fragment)) {\n              includesLineCommentsOnNonFirstElement = true;\n            }\n          }\n          // Add ', ' if all `Elisions` from the beginning of the array are processed (e.g. [, , , a]) and\n          // element isn't `Elision` or last element is `Elision` (e.g. [a,,b,,])\n          if (index !== 0 && passedElision && (!fragmentIsElision(fragments) || index === olen - 1)) {\n            answer.push(this.makeCode(', '));\n          }\n          passedElision = passedElision || !fragmentIsElision(fragments);\n          answer.push(...fragments);\n        }\n        if (includesLineCommentsOnNonFirstElement || indexOf.call(fragmentsToText(answer), '\\n') >= 0) {\n          for (fragmentIndex = p = 0, len4 = answer.length; p < len4; fragmentIndex = ++p) {\n            fragment = answer[fragmentIndex];\n            if (fragment.isHereComment) {\n              fragment.code = `${multident(fragment.code, o.indent, false)}\\n${o.indent}`;\n            } else if (fragment.code === ', ' && !(fragment != null ? fragment.isElision : void 0)) {\n              fragment.code = `,\\n${o.indent}`;\n            }\n          }\n          answer.unshift(this.makeCode(`[\\n${o.indent}`));\n          answer.push(this.makeCode(`\\n${this.tab}]`));\n        } else {\n          for (q = 0, len5 = answer.length; q < len5; q++) {\n            fragment = answer[q];\n            if (fragment.isHereComment) {\n              fragment.code = `${fragment.code} `;\n            }\n          }\n          answer.unshift(this.makeCode('['));\n          answer.push(this.makeCode(']'));\n        }\n        return answer;\n      }\n\n      assigns(name) {\n        var j, len1, obj, ref1;\n        ref1 = this.objects;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          obj = ref1[j];\n          if (obj.assigns(name)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      eachName(iterator) {\n        var j, len1, obj, ref1, results;\n        ref1 = this.objects;\n        results = [];\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          obj = ref1[j];\n          obj = obj.unwrapAll();\n          results.push(obj.eachName(iterator));\n        }\n        return results;\n      }\n\n    };\n\n    Arr.prototype.children = ['objects'];\n\n    return Arr;\n\n  }).call(this);\n\n  //### Class\n\n  // The CoffeeScript class definition.\n  // Initialize a **Class** with its name, an optional superclass, and a body.\n  exports.Class = Class = (function() {\n    class Class extends Base {\n      constructor(variable1, parent1, body1 = new Block) {\n        super();\n        this.variable = variable1;\n        this.parent = parent1;\n        this.body = body1;\n      }\n\n      compileNode(o) {\n        var executableBody, node, parentName;\n        this.name = this.determineName();\n        executableBody = this.walkBody();\n        if (this.parent instanceof Value && !this.parent.hasProperties()) {\n          // Special handling to allow `class expr.A extends A` declarations\n          parentName = this.parent.base.value;\n        }\n        this.hasNameClash = (this.name != null) && this.name === parentName;\n        node = this;\n        if (executableBody || this.hasNameClash) {\n          node = new ExecutableClassBody(node, executableBody);\n        } else if ((this.name == null) && o.level === LEVEL_TOP) {\n          // Anonymous classes are only valid in expressions\n          node = new Parens(node);\n        }\n        if (this.boundMethods.length && this.parent) {\n          if (this.variable == null) {\n            this.variable = new IdentifierLiteral(o.scope.freeVariable('_class'));\n          }\n          if (this.variableRef == null) {\n            [this.variable, this.variableRef] = this.variable.cache(o);\n          }\n        }\n        if (this.variable) {\n          node = new Assign(this.variable, node, null, {moduleDeclaration: this.moduleDeclaration});\n        }\n        this.compileNode = this.compileClassDeclaration;\n        try {\n          return node.compileToFragments(o);\n        } finally {\n          delete this.compileNode;\n        }\n      }\n\n      compileClassDeclaration(o) {\n        var ref1, ref2, result;\n        if (this.externalCtor || this.boundMethods.length) {\n          if (this.ctor == null) {\n            this.ctor = this.makeDefaultConstructor();\n          }\n        }\n        if ((ref1 = this.ctor) != null) {\n          ref1.noReturn = true;\n        }\n        if (this.boundMethods.length) {\n          this.proxyBoundMethods();\n        }\n        o.indent += TAB;\n        result = [];\n        result.push(this.makeCode(\"class \"));\n        if (this.name) {\n          result.push(this.makeCode(this.name));\n        }\n        if (((ref2 = this.variable) != null ? ref2.comments : void 0) != null) {\n          this.compileCommentFragments(o, this.variable, result);\n        }\n        if (this.name) {\n          result.push(this.makeCode(' '));\n        }\n        if (this.parent) {\n          result.push(this.makeCode('extends '), ...this.parent.compileToFragments(o), this.makeCode(' '));\n        }\n        result.push(this.makeCode('{'));\n        if (!this.body.isEmpty()) {\n          this.body.spaced = true;\n          result.push(this.makeCode('\\n'));\n          result.push(...this.body.compileToFragments(o, LEVEL_TOP));\n          result.push(this.makeCode(`\\n${this.tab}`));\n        }\n        result.push(this.makeCode('}'));\n        return result;\n      }\n\n      // Figure out the appropriate name for this class\n      determineName() {\n        var message, name, node, ref1, tail;\n        if (!this.variable) {\n          return null;\n        }\n        ref1 = this.variable.properties, [tail] = slice1.call(ref1, -1);\n        node = tail ? tail instanceof Access && tail.name : this.variable.base;\n        if (!(node instanceof IdentifierLiteral || node instanceof PropertyName)) {\n          return null;\n        }\n        name = node.value;\n        if (!tail) {\n          message = isUnassignable(name);\n          if (message) {\n            this.variable.error(message);\n          }\n        }\n        if (indexOf.call(JS_FORBIDDEN, name) >= 0) {\n          return `_${name}`;\n        } else {\n          return name;\n        }\n      }\n\n      walkBody() {\n        var assign, end, executableBody, expression, expressions, exprs, i, initializer, initializerExpression, j, k, len1, len2, method, properties, pushSlice, ref1, start;\n        this.ctor = null;\n        this.boundMethods = [];\n        executableBody = null;\n        initializer = [];\n        ({expressions} = this.body);\n        i = 0;\n        ref1 = expressions.slice();\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          expression = ref1[j];\n          if (expression instanceof Value && expression.isObject(true)) {\n            ({properties} = expression.base);\n            exprs = [];\n            end = 0;\n            start = 0;\n            pushSlice = function() {\n              if (end > start) {\n                return exprs.push(new Value(new Obj(properties.slice(start, end), true)));\n              }\n            };\n            while (assign = properties[end]) {\n              if (initializerExpression = this.addInitializerExpression(assign)) {\n                pushSlice();\n                exprs.push(initializerExpression);\n                initializer.push(initializerExpression);\n                start = end + 1;\n              }\n              end++;\n            }\n            pushSlice();\n            splice.apply(expressions, [i, i - i + 1].concat(exprs)), exprs;\n            i += exprs.length;\n          } else {\n            if (initializerExpression = this.addInitializerExpression(expression)) {\n              initializer.push(initializerExpression);\n              expressions[i] = initializerExpression;\n            }\n            i += 1;\n          }\n        }\n        for (k = 0, len2 = initializer.length; k < len2; k++) {\n          method = initializer[k];\n          if (method instanceof Code) {\n            if (method.ctor) {\n              if (this.ctor) {\n                method.error('Cannot define more than one constructor in a class');\n              }\n              this.ctor = method;\n            } else if (method.isStatic && method.bound) {\n              method.context = this.name;\n            } else if (method.bound) {\n              this.boundMethods.push(method);\n            }\n          }\n        }\n        if (initializer.length !== expressions.length) {\n          this.body.expressions = (function() {\n            var l, len3, results;\n            results = [];\n            for (l = 0, len3 = initializer.length; l < len3; l++) {\n              expression = initializer[l];\n              results.push(expression.hoist());\n            }\n            return results;\n          })();\n          return new Block(expressions);\n        }\n      }\n\n      // Add an expression to the class initializer\n\n      // This is the key method for determining whether an expression in a class\n      // body should appear in the initializer or the executable body. If the given\n      // `node` is valid in a class body the method will return a (new, modified,\n      // or identical) node for inclusion in the class initializer, otherwise\n      // nothing will be returned and the node will appear in the executable body.\n\n      // At time of writing, only methods (instance and static) are valid in ES\n      // class initializers. As new ES class features (such as class fields) reach\n      // Stage 4, this method will need to be updated to support them. We\n      // additionally allow `PassthroughLiteral`s (backticked expressions) in the\n      // initializer as an escape hatch for ES features that are not implemented\n      // (e.g. getters and setters defined via the `get` and `set` keywords as\n      // opposed to the `Object.defineProperty` method).\n      addInitializerExpression(node) {\n        if (node.unwrapAll() instanceof PassthroughLiteral) {\n          return node;\n        } else if (this.validInitializerMethod(node)) {\n          return this.addInitializerMethod(node);\n        } else {\n          return null;\n        }\n      }\n\n      // Checks if the given node is a valid ES class initializer method.\n      validInitializerMethod(node) {\n        if (!(node instanceof Assign && node.value instanceof Code)) {\n          return false;\n        }\n        if (node.context === 'object' && !node.variable.hasProperties()) {\n          return true;\n        }\n        return node.variable.looksStatic(this.name) && (this.name || !node.value.bound);\n      }\n\n      // Returns a configured class initializer method\n      addInitializerMethod(assign) {\n        var method, methodName, variable;\n        ({\n          variable,\n          value: method\n        } = assign);\n        method.isMethod = true;\n        method.isStatic = variable.looksStatic(this.name);\n        if (method.isStatic) {\n          method.name = variable.properties[0];\n        } else {\n          methodName = variable.base;\n          method.name = new (methodName.shouldCache() ? Index : Access)(methodName);\n          method.name.updateLocationDataIfMissing(methodName.locationData);\n          if (methodName.value === 'constructor') {\n            method.ctor = (this.parent ? 'derived' : 'base');\n          }\n          if (method.bound && method.ctor) {\n            method.error('Cannot define a constructor as a bound (fat arrow) function');\n          }\n        }\n        return method;\n      }\n\n      makeDefaultConstructor() {\n        var applyArgs, applyCtor, ctor;\n        ctor = this.addInitializerMethod(new Assign(new Value(new PropertyName('constructor')), new Code));\n        this.body.unshift(ctor);\n        if (this.parent) {\n          ctor.body.push(new SuperCall(new Super, [new Splat(new IdentifierLiteral('arguments'))]));\n        }\n        if (this.externalCtor) {\n          applyCtor = new Value(this.externalCtor, [new Access(new PropertyName('apply'))]);\n          applyArgs = [new ThisLiteral, new IdentifierLiteral('arguments')];\n          ctor.body.push(new Call(applyCtor, applyArgs));\n          ctor.body.makeReturn();\n        }\n        return ctor;\n      }\n\n      proxyBoundMethods() {\n        var method, name;\n        this.ctor.thisAssignments = (function() {\n          var j, len1, ref1, results;\n          ref1 = this.boundMethods;\n          results = [];\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            method = ref1[j];\n            if (this.parent) {\n              method.classVariable = this.variableRef;\n            }\n            name = new Value(new ThisLiteral, [method.name]);\n            results.push(new Assign(name, new Call(new Value(name, [new Access(new PropertyName('bind'))]), [new ThisLiteral])));\n          }\n          return results;\n        }).call(this);\n        return null;\n      }\n\n    };\n\n    Class.prototype.children = ['variable', 'parent', 'body'];\n\n    return Class;\n\n  }).call(this);\n\n  exports.ExecutableClassBody = ExecutableClassBody = (function() {\n    class ExecutableClassBody extends Base {\n      constructor(_class, body1 = new Block) {\n        super();\n        this.class = _class;\n        this.body = body1;\n      }\n\n      compileNode(o) {\n        var args, argumentsNode, directives, externalCtor, ident, jumpNode, klass, params, parent, ref1, wrapper;\n        if (jumpNode = this.body.jumps()) {\n          jumpNode.error('Class bodies cannot contain pure statements');\n        }\n        if (argumentsNode = this.body.contains(isLiteralArguments)) {\n          argumentsNode.error(\"Class bodies shouldn't reference arguments\");\n        }\n        params = [];\n        args = [new ThisLiteral];\n        wrapper = new Code(params, this.body);\n        klass = new Parens(new Call(new Value(wrapper, [new Access(new PropertyName('call'))]), args));\n        this.body.spaced = true;\n        o.classScope = wrapper.makeScope(o.scope);\n        this.name = (ref1 = this.class.name) != null ? ref1 : o.classScope.freeVariable(this.defaultClassVariableName);\n        ident = new IdentifierLiteral(this.name);\n        directives = this.walkBody();\n        this.setContext();\n        if (this.class.hasNameClash) {\n          parent = new IdentifierLiteral(o.classScope.freeVariable('superClass'));\n          wrapper.params.push(new Param(parent));\n          args.push(this.class.parent);\n          this.class.parent = parent;\n        }\n        if (this.externalCtor) {\n          externalCtor = new IdentifierLiteral(o.classScope.freeVariable('ctor', {\n            reserve: false\n          }));\n          this.class.externalCtor = externalCtor;\n          this.externalCtor.variable.base = externalCtor;\n        }\n        if (this.name !== this.class.name) {\n          this.body.expressions.unshift(new Assign(new IdentifierLiteral(this.name), this.class));\n        } else {\n          this.body.expressions.unshift(this.class);\n        }\n        this.body.expressions.unshift(...directives);\n        this.body.push(ident);\n        return klass.compileToFragments(o);\n      }\n\n      // Traverse the class's children and:\n      // - Hoist valid ES properties into `@properties`\n      // - Hoist static assignments into `@properties`\n      // - Convert invalid ES properties into class or prototype assignments\n      walkBody() {\n        var directives, expr, index;\n        directives = [];\n        index = 0;\n        while (expr = this.body.expressions[index]) {\n          if (!(expr instanceof Value && expr.isString())) {\n            break;\n          }\n          if (expr.hoisted) {\n            index++;\n          } else {\n            directives.push(...this.body.expressions.splice(index, 1));\n          }\n        }\n        this.traverseChildren(false, (child) => {\n          var cont, i, j, len1, node, ref1;\n          if (child instanceof Class || child instanceof HoistTarget) {\n            return false;\n          }\n          cont = true;\n          if (child instanceof Block) {\n            ref1 = child.expressions;\n            for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {\n              node = ref1[i];\n              if (node instanceof Value && node.isObject(true)) {\n                cont = false;\n                child.expressions[i] = this.addProperties(node.base.properties);\n              } else if (node instanceof Assign && node.variable.looksStatic(this.name)) {\n                node.value.isStatic = true;\n              }\n            }\n            child.expressions = flatten(child.expressions);\n          }\n          return cont;\n        });\n        return directives;\n      }\n\n      setContext() {\n        return this.body.traverseChildren(false, (node) => {\n          if (node instanceof ThisLiteral) {\n            return node.value = this.name;\n          } else if (node instanceof Code && node.bound && node.isStatic) {\n            return node.context = this.name;\n          }\n        });\n      }\n\n      // Make class/prototype assignments for invalid ES properties\n      addProperties(assigns) {\n        var assign, base, name, prototype, result, value, variable;\n        result = (function() {\n          var j, len1, results;\n          results = [];\n          for (j = 0, len1 = assigns.length; j < len1; j++) {\n            assign = assigns[j];\n            variable = assign.variable;\n            base = variable != null ? variable.base : void 0;\n            value = assign.value;\n            delete assign.context;\n            if (base.value === 'constructor') {\n              if (value instanceof Code) {\n                base.error('constructors must be defined at the top level of a class body');\n              }\n              // The class scope is not available yet, so return the assignment to update later\n              assign = this.externalCtor = new Assign(new Value, value);\n            } else if (!assign.variable.this) {\n              name = new (base.shouldCache() ? Index : Access)(base);\n              prototype = new Access(new PropertyName('prototype'));\n              variable = new Value(new ThisLiteral(), [prototype, name]);\n              assign.variable = variable;\n            } else if (assign.value instanceof Code) {\n              assign.value.isStatic = true;\n            }\n            results.push(assign);\n          }\n          return results;\n        }).call(this);\n        return compact(result);\n      }\n\n    };\n\n    ExecutableClassBody.prototype.children = ['class', 'body'];\n\n    ExecutableClassBody.prototype.defaultClassVariableName = '_Class';\n\n    return ExecutableClassBody;\n\n  }).call(this);\n\n  //### Import and Export\n  exports.ModuleDeclaration = ModuleDeclaration = (function() {\n    class ModuleDeclaration extends Base {\n      constructor(clause, source1) {\n        super();\n        this.clause = clause;\n        this.source = source1;\n        this.checkSource();\n      }\n\n      checkSource() {\n        if ((this.source != null) && this.source instanceof StringWithInterpolations) {\n          return this.source.error('the name of the module to be imported from must be an uninterpolated string');\n        }\n      }\n\n      checkScope(o, moduleDeclarationType) {\n        if (o.indent.length !== 0) {\n          return this.error(`${moduleDeclarationType} statements must be at top-level scope`);\n        }\n      }\n\n    };\n\n    ModuleDeclaration.prototype.children = ['clause', 'source'];\n\n    ModuleDeclaration.prototype.isStatement = YES;\n\n    ModuleDeclaration.prototype.jumps = THIS;\n\n    ModuleDeclaration.prototype.makeReturn = THIS;\n\n    return ModuleDeclaration;\n\n  }).call(this);\n\n  exports.ImportDeclaration = ImportDeclaration = class ImportDeclaration extends ModuleDeclaration {\n    compileNode(o) {\n      var code, ref1;\n      this.checkScope(o, 'import');\n      o.importedSymbols = [];\n      code = [];\n      code.push(this.makeCode(`${this.tab}import `));\n      if (this.clause != null) {\n        code.push(...this.clause.compileNode(o));\n      }\n      if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {\n        if (this.clause !== null) {\n          code.push(this.makeCode(' from '));\n        }\n        code.push(this.makeCode(this.source.value));\n      }\n      code.push(this.makeCode(';'));\n      return code;\n    }\n\n  };\n\n  exports.ImportClause = ImportClause = (function() {\n    class ImportClause extends Base {\n      constructor(defaultBinding, namedImports) {\n        super();\n        this.defaultBinding = defaultBinding;\n        this.namedImports = namedImports;\n      }\n\n      compileNode(o) {\n        var code;\n        code = [];\n        if (this.defaultBinding != null) {\n          code.push(...this.defaultBinding.compileNode(o));\n          if (this.namedImports != null) {\n            code.push(this.makeCode(', '));\n          }\n        }\n        if (this.namedImports != null) {\n          code.push(...this.namedImports.compileNode(o));\n        }\n        return code;\n      }\n\n    };\n\n    ImportClause.prototype.children = ['defaultBinding', 'namedImports'];\n\n    return ImportClause;\n\n  }).call(this);\n\n  exports.ExportDeclaration = ExportDeclaration = class ExportDeclaration extends ModuleDeclaration {\n    compileNode(o) {\n      var code, ref1;\n      this.checkScope(o, 'export');\n      code = [];\n      code.push(this.makeCode(`${this.tab}export `));\n      if (this instanceof ExportDefaultDeclaration) {\n        code.push(this.makeCode('default '));\n      }\n      if (!(this instanceof ExportDefaultDeclaration) && (this.clause instanceof Assign || this.clause instanceof Class)) {\n        // Prevent exporting an anonymous class; all exported members must be named\n        if (this.clause instanceof Class && !this.clause.variable) {\n          this.clause.error('anonymous classes cannot be exported');\n        }\n        code.push(this.makeCode('var '));\n        this.clause.moduleDeclaration = 'export';\n      }\n      if ((this.clause.body != null) && this.clause.body instanceof Block) {\n        code = code.concat(this.clause.compileToFragments(o, LEVEL_TOP));\n      } else {\n        code = code.concat(this.clause.compileNode(o));\n      }\n      if (((ref1 = this.source) != null ? ref1.value : void 0) != null) {\n        code.push(this.makeCode(` from ${this.source.value}`));\n      }\n      code.push(this.makeCode(';'));\n      return code;\n    }\n\n  };\n\n  exports.ExportNamedDeclaration = ExportNamedDeclaration = class ExportNamedDeclaration extends ExportDeclaration {};\n\n  exports.ExportDefaultDeclaration = ExportDefaultDeclaration = class ExportDefaultDeclaration extends ExportDeclaration {};\n\n  exports.ExportAllDeclaration = ExportAllDeclaration = class ExportAllDeclaration extends ExportDeclaration {};\n\n  exports.ModuleSpecifierList = ModuleSpecifierList = (function() {\n    class ModuleSpecifierList extends Base {\n      constructor(specifiers) {\n        super();\n        this.specifiers = specifiers;\n      }\n\n      compileNode(o) {\n        var code, compiledList, fragments, index, j, len1, specifier;\n        code = [];\n        o.indent += TAB;\n        compiledList = (function() {\n          var j, len1, ref1, results;\n          ref1 = this.specifiers;\n          results = [];\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            specifier = ref1[j];\n            results.push(specifier.compileToFragments(o, LEVEL_LIST));\n          }\n          return results;\n        }).call(this);\n        if (this.specifiers.length !== 0) {\n          code.push(this.makeCode(`{\\n${o.indent}`));\n          for (index = j = 0, len1 = compiledList.length; j < len1; index = ++j) {\n            fragments = compiledList[index];\n            if (index) {\n              code.push(this.makeCode(`,\\n${o.indent}`));\n            }\n            code.push(...fragments);\n          }\n          code.push(this.makeCode(\"\\n}\"));\n        } else {\n          code.push(this.makeCode('{}'));\n        }\n        return code;\n      }\n\n    };\n\n    ModuleSpecifierList.prototype.children = ['specifiers'];\n\n    return ModuleSpecifierList;\n\n  }).call(this);\n\n  exports.ImportSpecifierList = ImportSpecifierList = class ImportSpecifierList extends ModuleSpecifierList {};\n\n  exports.ExportSpecifierList = ExportSpecifierList = class ExportSpecifierList extends ModuleSpecifierList {};\n\n  exports.ModuleSpecifier = ModuleSpecifier = (function() {\n    class ModuleSpecifier extends Base {\n      constructor(original, alias, moduleDeclarationType1) {\n        var ref1, ref2;\n        super();\n        this.original = original;\n        this.alias = alias;\n        this.moduleDeclarationType = moduleDeclarationType1;\n        if (this.original.comments || ((ref1 = this.alias) != null ? ref1.comments : void 0)) {\n          this.comments = [];\n          if (this.original.comments) {\n            this.comments.push(...this.original.comments);\n          }\n          if ((ref2 = this.alias) != null ? ref2.comments : void 0) {\n            this.comments.push(...this.alias.comments);\n          }\n        }\n        // The name of the variable entering the local scope\n        this.identifier = this.alias != null ? this.alias.value : this.original.value;\n      }\n\n      compileNode(o) {\n        var code;\n        o.scope.find(this.identifier, this.moduleDeclarationType);\n        code = [];\n        code.push(this.makeCode(this.original.value));\n        if (this.alias != null) {\n          code.push(this.makeCode(` as ${this.alias.value}`));\n        }\n        return code;\n      }\n\n    };\n\n    ModuleSpecifier.prototype.children = ['original', 'alias'];\n\n    return ModuleSpecifier;\n\n  }).call(this);\n\n  exports.ImportSpecifier = ImportSpecifier = class ImportSpecifier extends ModuleSpecifier {\n    constructor(imported, local) {\n      super(imported, local, 'import');\n    }\n\n    compileNode(o) {\n      var ref1;\n      // Per the spec, symbols canât be imported multiple times\n      // (e.g. `import { foo, foo } from 'lib'` is invalid)\n      if ((ref1 = this.identifier, indexOf.call(o.importedSymbols, ref1) >= 0) || o.scope.check(this.identifier)) {\n        this.error(`'${this.identifier}' has already been declared`);\n      } else {\n        o.importedSymbols.push(this.identifier);\n      }\n      return super.compileNode(o);\n    }\n\n  };\n\n  exports.ImportDefaultSpecifier = ImportDefaultSpecifier = class ImportDefaultSpecifier extends ImportSpecifier {};\n\n  exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier = class ImportNamespaceSpecifier extends ImportSpecifier {};\n\n  exports.ExportSpecifier = ExportSpecifier = class ExportSpecifier extends ModuleSpecifier {\n    constructor(local, exported) {\n      super(local, exported, 'export');\n    }\n\n  };\n\n  //### Assign\n\n  // The **Assign** is used to assign a local variable to value, or to set the\n  // property of an object -- including within object literals.\n  exports.Assign = Assign = (function() {\n    class Assign extends Base {\n      constructor(variable1, value1, context1, options = {}) {\n        super();\n        this.variable = variable1;\n        this.value = value1;\n        this.context = context1;\n        ({param: this.param, subpattern: this.subpattern, operatorToken: this.operatorToken, moduleDeclaration: this.moduleDeclaration} = options);\n      }\n\n      isStatement(o) {\n        return (o != null ? o.level : void 0) === LEVEL_TOP && (this.context != null) && (this.moduleDeclaration || indexOf.call(this.context, \"?\") >= 0);\n      }\n\n      checkAssignability(o, varBase) {\n        if (Object.prototype.hasOwnProperty.call(o.scope.positions, varBase.value) && o.scope.variables[o.scope.positions[varBase.value]].type === 'import') {\n          return varBase.error(`'${varBase.value}' is read-only`);\n        }\n      }\n\n      assigns(name) {\n        return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);\n      }\n\n      unfoldSoak(o) {\n        return unfoldSoak(o, this, 'variable');\n      }\n\n      // Compile an assignment, delegating to `compileDestructuring` or\n      // `compileSplice` if appropriate. Keep track of the name of the base object\n      // we've been assigned to, for correct internal references. If the variable\n      // has not been seen yet within the current scope, declare it.\n      compileNode(o) {\n        var answer, compiledName, isValue, name, properties, prototype, ref1, ref2, ref3, ref4, ref5, val, varBase;\n        isValue = this.variable instanceof Value;\n        if (isValue) {\n          // When compiling `@variable`, remember if it is part of a function parameter.\n          this.variable.param = this.param;\n          // If `@variable` is an array or an object, weâre destructuring;\n          // if itâs also `isAssignable()`, the destructuring syntax is supported\n          // in ES and we can output it as is; otherwise we `@compileDestructuring`\n          // and convert this ES-unsupported destructuring into acceptable output.\n          if (this.variable.isArray() || this.variable.isObject()) {\n            // This is the left-hand side of an assignment; let `Arr` and `Obj`\n            // know that, so that those nodes know that theyâre assignable as\n            // destructured variables.\n            this.variable.base.lhs = true;\n            if (!this.variable.isAssignable()) {\n              if (this.variable.isObject() && this.variable.base.hasSplat()) {\n                return this.compileObjectDestruct(o);\n              } else {\n                return this.compileDestructuring(o);\n              }\n            }\n          }\n          if (this.variable.isSplice()) {\n            return this.compileSplice(o);\n          }\n          if ((ref1 = this.context) === '||=' || ref1 === '&&=' || ref1 === '?=') {\n            return this.compileConditional(o);\n          }\n          if ((ref2 = this.context) === '//=' || ref2 === '%%=') {\n            return this.compileSpecialMath(o);\n          }\n        }\n        if (!this.context || this.context === '**=') {\n          varBase = this.variable.unwrapAll();\n          if (!varBase.isAssignable()) {\n            this.variable.error(`'${this.variable.compile(o)}' can't be assigned`);\n          }\n          varBase.eachName((name) => {\n            var commentFragments, commentsNode, message;\n            if (typeof name.hasProperties === \"function\" ? name.hasProperties() : void 0) {\n              return;\n            }\n            message = isUnassignable(name.value);\n            if (message) {\n              name.error(message);\n            }\n            // `moduleDeclaration` can be `'import'` or `'export'`.\n            this.checkAssignability(o, name);\n            if (this.moduleDeclaration) {\n              return o.scope.add(name.value, this.moduleDeclaration);\n            } else if (this.param) {\n              return o.scope.add(name.value, this.param === 'alwaysDeclare' ? 'var' : 'param');\n            } else {\n              o.scope.find(name.value);\n              // If this assignment identifier has one or more herecomments\n              // attached, output them as part of the declarations line (unless\n              // other herecomments are already staged there) for compatibility\n              // with Flow typing. Donât do this if this assignment is for a\n              // class, e.g. `ClassName = class ClassName {`, as Flow requires\n              // the comment to be between the class name and the `{`.\n              if (name.comments && !o.scope.comments[name.value] && !(this.value instanceof Class) && name.comments.every(function(comment) {\n                return comment.here && !comment.multiline;\n              })) {\n                commentsNode = new IdentifierLiteral(name.value);\n                commentsNode.comments = name.comments;\n                commentFragments = [];\n                this.compileCommentFragments(o, commentsNode, commentFragments);\n                return o.scope.comments[name.value] = commentFragments;\n              }\n            }\n          });\n        }\n        if (this.value instanceof Code) {\n          if (this.value.isStatic) {\n            this.value.name = this.variable.properties[0];\n          } else if (((ref3 = this.variable.properties) != null ? ref3.length : void 0) >= 2) {\n            ref4 = this.variable.properties, [...properties] = ref4, [prototype, name] = splice.call(properties, -2);\n            if (((ref5 = prototype.name) != null ? ref5.value : void 0) === 'prototype') {\n              this.value.name = name;\n            }\n          }\n        }\n        if (this.csx) {\n          this.value.base.csxAttribute = true;\n        }\n        val = this.value.compileToFragments(o, LEVEL_LIST);\n        compiledName = this.variable.compileToFragments(o, LEVEL_LIST);\n        if (this.context === 'object') {\n          if (this.variable.shouldCache()) {\n            compiledName.unshift(this.makeCode('['));\n            compiledName.push(this.makeCode(']'));\n          }\n          return compiledName.concat(this.makeCode(this.csx ? '=' : ': '), val);\n        }\n        answer = compiledName.concat(this.makeCode(` ${this.context || '='} `), val);\n        // Per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Assignment_without_declaration,\n        // if weâre destructuring without declaring, the destructuring assignment must be wrapped in parentheses.\n        // The assignment is wrapped in parentheses if 'o.level' has lower precedence than LEVEL_LIST (3)\n        // (i.e. LEVEL_COND (4), LEVEL_OP (5) or LEVEL_ACCESS (6)), or if we're destructuring object, e.g. {a,b} = obj.\n        if (o.level > LEVEL_LIST || isValue && this.variable.base instanceof Obj && !this.nestedLhs && !(this.param === true)) {\n          return this.wrapInParentheses(answer);\n        } else {\n          return answer;\n        }\n      }\n\n      // Object rest property is not assignable: `{{a}...}`\n      compileObjectDestruct(o) {\n        var assigns, props, refVal, splat, splatProp;\n        this.variable.base.reorderProperties();\n        ({\n          properties: props\n        } = this.variable.base);\n        [splat] = slice1.call(props, -1);\n        splatProp = splat.name;\n        assigns = [];\n        refVal = new Value(new IdentifierLiteral(o.scope.freeVariable('ref')));\n        props.splice(-1, 1, new Splat(refVal));\n        assigns.push(new Assign(new Value(new Obj(props)), this.value).compileToFragments(o, LEVEL_LIST));\n        assigns.push(new Assign(new Value(splatProp), refVal).compileToFragments(o, LEVEL_LIST));\n        return this.joinFragmentArrays(assigns, ', ');\n      }\n\n      // Brief implementation of recursive pattern matching, when assigning array or\n      // object literals to a value. Peeks at their properties to assign inner names.\n      compileDestructuring(o) {\n        var assignObjects, assigns, code, compSlice, compSplice, complexObjects, expIdx, expans, fragments, hasObjAssigns, i, isExpans, isSplat, leftObjs, loopObjects, obj, objIsUnassignable, objects, olen, processObjects, pushAssign, ref, refExp, restVar, rightObjs, slicer, splatVar, splatVarAssign, splatVarRef, splats, splatsAndExpans, top, value, vvar, vvarText;\n        top = o.level === LEVEL_TOP;\n        ({value} = this);\n        ({objects} = this.variable.base);\n        olen = objects.length;\n        // Special-case for `{} = a` and `[] = a` (empty patterns).\n        // Compile to simply `a`.\n        if (olen === 0) {\n          code = value.compileToFragments(o);\n          if (o.level >= LEVEL_OP) {\n            return this.wrapInParentheses(code);\n          } else {\n            return code;\n          }\n        }\n        [obj] = objects;\n        // Disallow `[...] = a` for some reason. (Could be equivalent to `[] = a`?)\n        if (olen === 1 && obj instanceof Expansion) {\n          obj.error('Destructuring assignment has no target');\n        }\n        // Count all `Splats`: [a, b, c..., d, e]\n        splats = (function() {\n          var j, len1, results;\n          results = [];\n          for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {\n            obj = objects[i];\n            if (obj instanceof Splat) {\n              results.push(i);\n            }\n          }\n          return results;\n        })();\n        // Count all `Expansions`: [a, b, ..., c, d]\n        expans = (function() {\n          var j, len1, results;\n          results = [];\n          for (i = j = 0, len1 = objects.length; j < len1; i = ++j) {\n            obj = objects[i];\n            if (obj instanceof Expansion) {\n              results.push(i);\n            }\n          }\n          return results;\n        })();\n        // Combine splats and expansions.\n        splatsAndExpans = [...splats, ...expans];\n        // Show error if there is more than one `Splat`, or `Expansion`.\n        // Examples: [a, b, c..., d, e, f...], [a, b, ..., c, d, ...], [a, b, ..., c, d, e...]\n        if (splatsAndExpans.length > 1) {\n          // Sort 'splatsAndExpans' so we can show error at first disallowed token.\n          objects[splatsAndExpans.sort()[1]].error(\"multiple splats/expansions are disallowed in an assignment\");\n        }\n        isSplat = (splats != null ? splats.length : void 0) > 0;\n        isExpans = (expans != null ? expans.length : void 0) > 0;\n        vvar = value.compileToFragments(o, LEVEL_LIST);\n        vvarText = fragmentsToText(vvar);\n        assigns = [];\n        pushAssign = (variable, val) => {\n          return assigns.push(new Assign(variable, val, null, {\n            param: this.param,\n            subpattern: true\n          }).compileToFragments(o, LEVEL_LIST));\n        };\n        if (isSplat) {\n          splatVar = objects[splats[0]].name.unwrap();\n          if (splatVar instanceof Arr || splatVar instanceof Obj) {\n            splatVarRef = new IdentifierLiteral(o.scope.freeVariable('ref'));\n            objects[splats[0]].name = splatVarRef;\n            splatVarAssign = function() {\n              return pushAssign(new Value(splatVar), splatVarRef);\n            };\n          }\n        }\n        // At this point, there are several things to destructure. So the `fn()` in\n        // `{a, b} = fn()` must be cached, for example. Make vvar into a simple\n        // variable if it isnât already.\n        if (!(value.unwrap() instanceof IdentifierLiteral) || this.variable.assigns(vvarText)) {\n          ref = o.scope.freeVariable('ref');\n          assigns.push([this.makeCode(ref + ' = '), ...vvar]);\n          vvar = [this.makeCode(ref)];\n          vvarText = ref;\n        }\n        slicer = function(type) {\n          return function(vvar, start, end = false) {\n            var args, slice;\n            if (!(vvar instanceof Value)) {\n              vvar = new IdentifierLiteral(vvar);\n            }\n            args = [vvar, new NumberLiteral(start)];\n            if (end) {\n              args.push(new NumberLiteral(end));\n            }\n            slice = new Value(new IdentifierLiteral(utility(type, o)), [new Access(new PropertyName('call'))]);\n            return new Value(new Call(slice, args));\n          };\n        };\n        // Helper which outputs `[].slice` code.\n        compSlice = slicer(\"slice\");\n        // Helper which outputs `[].splice` code.\n        compSplice = slicer(\"splice\");\n        // Check if `objects` array contains any instance of `Assign`, e.g. {a:1}.\n        hasObjAssigns = function(objs) {\n          var j, len1, results;\n          results = [];\n          for (i = j = 0, len1 = objs.length; j < len1; i = ++j) {\n            obj = objs[i];\n            if (obj instanceof Assign && obj.context === 'object') {\n              results.push(i);\n            }\n          }\n          return results;\n        };\n        // Check if `objects` array contains any unassignable object.\n        objIsUnassignable = function(objs) {\n          var j, len1;\n          for (j = 0, len1 = objs.length; j < len1; j++) {\n            obj = objs[j];\n            if (!obj.isAssignable()) {\n              return true;\n            }\n          }\n          return false;\n        };\n        // `objects` are complex when there is object assign ({a:1}),\n        // unassignable object, or just a single node.\n        complexObjects = function(objs) {\n          return hasObjAssigns(objs).length || objIsUnassignable(objs) || olen === 1;\n        };\n        // \"Complex\" `objects` are processed in a loop.\n        // Examples: [a, b, {c, r...}, d], [a, ..., {b, r...}, c, d]\n        loopObjects = (objs, vvar, vvarTxt) => {\n          var acc, idx, j, len1, message, results, vval;\n          results = [];\n          for (i = j = 0, len1 = objs.length; j < len1; i = ++j) {\n            obj = objs[i];\n            if (obj instanceof Elision) {\n              // `Elision` can be skipped.\n              continue;\n            }\n            // If `obj` is {a: 1}\n            if (obj instanceof Assign && obj.context === 'object') {\n              ({\n                variable: {\n                  base: idx\n                },\n                value: vvar\n              } = obj);\n              if (vvar instanceof Assign) {\n                ({\n                  variable: vvar\n                } = vvar);\n              }\n              idx = vvar.this ? vvar.properties[0].name : new PropertyName(vvar.unwrap().value);\n              acc = idx.unwrap() instanceof PropertyName;\n              vval = new Value(value, [new (acc ? Access : Index)(idx)]);\n            } else {\n              // `obj` is [a...], {a...} or a\n              vvar = (function() {\n                switch (false) {\n                  case !(obj instanceof Splat):\n                    return new Value(obj.name);\n                  default:\n                    return obj;\n                }\n              })();\n              vval = (function() {\n                switch (false) {\n                  case !(obj instanceof Splat):\n                    return compSlice(vvarTxt, i);\n                  default:\n                    return new Value(new Literal(vvarTxt), [new Index(new NumberLiteral(i))]);\n                }\n              })();\n            }\n            message = isUnassignable(vvar.unwrap().value);\n            if (message) {\n              vvar.error(message);\n            }\n            results.push(pushAssign(vvar, vval));\n          }\n          return results;\n        };\n        // \"Simple\" `objects` can be split and compiled to arrays, [a, b, c] = arr, [a, b, c...] = arr\n        assignObjects = (objs, vvar, vvarTxt) => {\n          var vval;\n          vvar = new Value(new Arr(objs, true));\n          vval = vvarTxt instanceof Value ? vvarTxt : new Value(new Literal(vvarTxt));\n          return pushAssign(vvar, vval);\n        };\n        processObjects = function(objs, vvar, vvarTxt) {\n          if (complexObjects(objs)) {\n            return loopObjects(objs, vvar, vvarTxt);\n          } else {\n            return assignObjects(objs, vvar, vvarTxt);\n          }\n        };\n        // In case there is `Splat` or `Expansion` in `objects`,\n        // we can split array in two simple subarrays.\n        // `Splat` [a, b, c..., d, e] can be split into  [a, b, c...] and [d, e].\n        // `Expansion` [a, b, ..., c, d] can be split into [a, b] and [c, d].\n        // Examples:\n        // a) `Splat`\n        //   CS: [a, b, c..., d, e] = arr\n        //   JS: [a, b, ...c] = arr, [d, e] = splice.call(c, -2)\n        // b) `Expansion`\n        //   CS: [a, b, ..., d, e] = arr\n        //   JS: [a, b] = arr, [d, e] = slice.call(arr, -2)\n        if (splatsAndExpans.length) {\n          expIdx = splatsAndExpans[0];\n          leftObjs = objects.slice(0, expIdx + (isSplat ? 1 : 0));\n          rightObjs = objects.slice(expIdx + 1);\n          if (leftObjs.length !== 0) {\n            processObjects(leftObjs, vvar, vvarText);\n          }\n          if (rightObjs.length !== 0) {\n            // Slice or splice `objects`.\n            refExp = (function() {\n              switch (false) {\n                case !isSplat:\n                  return compSplice(new Value(objects[expIdx].name), rightObjs.length * -1);\n                case !isExpans:\n                  return compSlice(vvarText, rightObjs.length * -1);\n              }\n            })();\n            if (complexObjects(rightObjs)) {\n              restVar = refExp;\n              refExp = o.scope.freeVariable('ref');\n              assigns.push([this.makeCode(refExp + ' = '), ...restVar.compileToFragments(o, LEVEL_LIST)]);\n            }\n            processObjects(rightObjs, vvar, refExp);\n          }\n        } else {\n          // There is no `Splat` or `Expansion` in `objects`.\n          processObjects(objects, vvar, vvarText);\n        }\n        if (typeof splatVarAssign === \"function\") {\n          splatVarAssign();\n        }\n        if (!(top || this.subpattern)) {\n          assigns.push(vvar);\n        }\n        fragments = this.joinFragmentArrays(assigns, ', ');\n        if (o.level < LEVEL_LIST) {\n          return fragments;\n        } else {\n          return this.wrapInParentheses(fragments);\n        }\n      }\n\n      // When compiling a conditional assignment, take care to ensure that the\n      // operands are only evaluated once, even though we have to reference them\n      // more than once.\n      compileConditional(o) {\n        var fragments, left, right;\n        [left, right] = this.variable.cacheReference(o);\n        // Disallow conditional assignment of undefined variables.\n        if (!left.properties.length && left.base instanceof Literal && !(left.base instanceof ThisLiteral) && !o.scope.check(left.base.value)) {\n          this.variable.error(`the variable \"${left.base.value}\" can't be assigned with ${this.context} because it has not been declared before`);\n        }\n        if (indexOf.call(this.context, \"?\") >= 0) {\n          o.isExistentialEquals = true;\n          return new If(new Existence(left), right, {\n            type: 'if'\n          }).addElse(new Assign(right, this.value, '=')).compileToFragments(o);\n        } else {\n          fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);\n          if (o.level <= LEVEL_LIST) {\n            return fragments;\n          } else {\n            return this.wrapInParentheses(fragments);\n          }\n        }\n      }\n\n      // Convert special math assignment operators like `a //= b` to the equivalent\n      // extended form `a = a ** b` and then compiles that.\n      compileSpecialMath(o) {\n        var left, right;\n        [left, right] = this.variable.cacheReference(o);\n        return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);\n      }\n\n      // Compile the assignment from an array splice literal, using JavaScript's\n      // `Array#splice` method.\n      compileSplice(o) {\n        var answer, exclusive, from, fromDecl, fromRef, name, to, unwrappedVar, valDef, valRef;\n        ({\n          range: {from, to, exclusive}\n        } = this.variable.properties.pop());\n        unwrappedVar = this.variable.unwrapAll();\n        if (unwrappedVar.comments) {\n          moveComments(unwrappedVar, this);\n          delete this.variable.comments;\n        }\n        name = this.variable.compile(o);\n        if (from) {\n          [fromDecl, fromRef] = this.cacheToCodeFragments(from.cache(o, LEVEL_OP));\n        } else {\n          fromDecl = fromRef = '0';\n        }\n        if (to) {\n          if ((from != null ? from.isNumber() : void 0) && to.isNumber()) {\n            to = to.compile(o) - fromRef;\n            if (!exclusive) {\n              to += 1;\n            }\n          } else {\n            to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;\n            if (!exclusive) {\n              to += ' + 1';\n            }\n          }\n        } else {\n          to = \"9e9\";\n        }\n        [valDef, valRef] = this.value.cache(o, LEVEL_LIST);\n        answer = [].concat(this.makeCode(`${utility('splice', o)}.apply(${name}, [${fromDecl}, ${to}].concat(`), valDef, this.makeCode(\")), \"), valRef);\n        if (o.level > LEVEL_TOP) {\n          return this.wrapInParentheses(answer);\n        } else {\n          return answer;\n        }\n      }\n\n      eachName(iterator) {\n        return this.variable.unwrapAll().eachName(iterator);\n      }\n\n    };\n\n    Assign.prototype.children = ['variable', 'value'];\n\n    Assign.prototype.isAssignable = YES;\n\n    return Assign;\n\n  }).call(this);\n\n  //### FuncGlyph\n  exports.FuncGlyph = FuncGlyph = class FuncGlyph extends Base {\n    constructor(glyph) {\n      super();\n      this.glyph = glyph;\n    }\n\n  };\n\n  //### Code\n\n  // A function definition. This is the only node that creates a new Scope.\n  // When for the purposes of walking the contents of a function body, the Code\n  // has no *children* -- they're within the inner scope.\n  exports.Code = Code = (function() {\n    class Code extends Base {\n      constructor(params, body, funcGlyph, paramStart) {\n        var ref1;\n        super();\n        this.funcGlyph = funcGlyph;\n        this.paramStart = paramStart;\n        this.params = params || [];\n        this.body = body || new Block;\n        this.bound = ((ref1 = this.funcGlyph) != null ? ref1.glyph : void 0) === '=>';\n        this.isGenerator = false;\n        this.isAsync = false;\n        this.isMethod = false;\n        this.body.traverseChildren(false, (node) => {\n          if ((node instanceof Op && node.isYield()) || node instanceof YieldReturn) {\n            this.isGenerator = true;\n          }\n          if ((node instanceof Op && node.isAwait()) || node instanceof AwaitReturn) {\n            this.isAsync = true;\n          }\n          if (node instanceof For && node.isAwait()) {\n            return this.isAsync = true;\n          }\n        });\n      }\n\n      isStatement() {\n        return this.isMethod;\n      }\n\n      makeScope(parentScope) {\n        return new Scope(parentScope, this.body, this);\n      }\n\n      // Compilation creates a new scope unless explicitly asked to share with the\n      // outer scope. Handles splat parameters in the parameter list by setting\n      // such parameters to be the final parameter in the function definition, as\n      // required per the ES2015 spec. If the CoffeeScript function definition had\n      // parameters after the splat, they are declared via expressions in the\n      // function body.\n      compileNode(o) {\n        var answer, body, boundMethodCheck, comment, condition, exprs, generatedVariables, haveBodyParam, haveSplatParam, i, ifTrue, j, k, l, len1, len2, len3, m, methodScope, modifiers, name, param, paramNames, paramToAddToScope, params, paramsAfterSplat, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, scopeVariablesCount, signature, splatParamName, thisAssignments, wasEmpty, yieldNode;\n        if (this.ctor) {\n          if (this.isAsync) {\n            this.name.error('Class constructor may not be async');\n          }\n          if (this.isGenerator) {\n            this.name.error('Class constructor may not be a generator');\n          }\n        }\n        if (this.bound) {\n          if ((ref1 = o.scope.method) != null ? ref1.bound : void 0) {\n            this.context = o.scope.method.context;\n          }\n          if (!this.context) {\n            this.context = 'this';\n          }\n        }\n        o.scope = del(o, 'classScope') || this.makeScope(o.scope);\n        o.scope.shared = del(o, 'sharedScope');\n        o.indent += TAB;\n        delete o.bare;\n        delete o.isExistentialEquals;\n        params = [];\n        exprs = [];\n        thisAssignments = (ref2 = (ref3 = this.thisAssignments) != null ? ref3.slice() : void 0) != null ? ref2 : [];\n        paramsAfterSplat = [];\n        haveSplatParam = false;\n        haveBodyParam = false;\n        // Check for duplicate parameters and separate `this` assignments.\n        paramNames = [];\n        this.eachParamName(function(name, node, param, obj) {\n          var replacement, target;\n          if (indexOf.call(paramNames, name) >= 0) {\n            node.error(`multiple parameters named '${name}'`);\n          }\n          paramNames.push(name);\n          if (node.this) {\n            name = node.properties[0].name.value;\n            if (indexOf.call(JS_FORBIDDEN, name) >= 0) {\n              name = `_${name}`;\n            }\n            target = new IdentifierLiteral(o.scope.freeVariable(name, {\n              reserve: false\n            }));\n            // `Param` is object destructuring with a default value: ({@prop = 1}) ->\n            // In a case when the variable name is already reserved, we have to assign\n            // a new variable name to the destructured variable: ({prop:prop1 = 1}) ->\n            replacement = param.name instanceof Obj && obj instanceof Assign && obj.operatorToken.value === '=' ? new Assign(new IdentifierLiteral(name), target, 'object') : target; //, operatorToken: new Literal ':'\n            param.renameParam(node, replacement);\n            return thisAssignments.push(new Assign(node, target));\n          }\n        });\n        ref4 = this.params;\n        // Parse the parameters, adding them to the list of parameters to put in the\n        // function definition; and dealing with splats or expansions, including\n        // adding expressions to the function body to declare all parameter\n        // variables that would have been after the splat/expansion parameter.\n        // If we encounter a parameter that needs to be declared in the function\n        // body for any reason, for example itâs destructured with `this`, also\n        // declare and assign all subsequent parameters in the function body so that\n        // any non-idempotent parameters are evaluated in the correct order.\n        for (i = j = 0, len1 = ref4.length; j < len1; i = ++j) {\n          param = ref4[i];\n          // Was `...` used with this parameter? (Only one such parameter is allowed\n          // per function.) Splat/expansion parameters cannot have default values,\n          // so we need not worry about that.\n          if (param.splat || param instanceof Expansion) {\n            if (haveSplatParam) {\n              param.error('only one splat or expansion parameter is allowed per function definition');\n            } else if (param instanceof Expansion && this.params.length === 1) {\n              param.error('an expansion parameter cannot be the only parameter in a function definition');\n            }\n            haveSplatParam = true;\n            if (param.splat) {\n              if (param.name instanceof Arr || param.name instanceof Obj) {\n                // Splat arrays are treated oddly by ES; deal with them the legacy\n                // way in the function body. TODO: Should this be handled in the\n                // function parameter list, and if so, how?\n                splatParamName = o.scope.freeVariable('arg');\n                params.push(ref = new Value(new IdentifierLiteral(splatParamName)));\n                exprs.push(new Assign(new Value(param.name), ref));\n              } else {\n                params.push(ref = param.asReference(o));\n                splatParamName = fragmentsToText(ref.compileNodeWithoutComments(o));\n              }\n              if (param.shouldCache()) {\n                exprs.push(new Assign(new Value(param.name), ref)); // `param` is an Expansion\n              }\n            } else {\n              splatParamName = o.scope.freeVariable('args');\n              params.push(new Value(new IdentifierLiteral(splatParamName)));\n            }\n            o.scope.parameter(splatParamName);\n          } else {\n            // Parse all other parameters; if a splat paramater has not yet been\n            // encountered, add these other parameters to the list to be output in\n            // the function definition.\n            if (param.shouldCache() || haveBodyParam) {\n              param.assignedInBody = true;\n              haveBodyParam = true;\n              // This parameter cannot be declared or assigned in the parameter\n              // list. So put a reference in the parameter list and add a statement\n              // to the function body assigning it, e.g.\n              // `(arg) => { var a = arg.a; }`, with a default value if it has one.\n              if (param.value != null) {\n                condition = new Op('===', param, new UndefinedLiteral);\n                ifTrue = new Assign(new Value(param.name), param.value);\n                exprs.push(new If(condition, ifTrue));\n              } else {\n                exprs.push(new Assign(new Value(param.name), param.asReference(o), null, {\n                  param: 'alwaysDeclare'\n                }));\n              }\n            }\n            // If this parameter comes before the splat or expansion, it will go\n            // in the function definition parameter list.\n            if (!haveSplatParam) {\n              // If this parameter has a default value, and it hasnât already been\n              // set by the `shouldCache()` block above, define it as a statement in\n              // the function body. This parameter comes after the splat parameter,\n              // so we canât define its default value in the parameter list.\n              if (param.shouldCache()) {\n                ref = param.asReference(o);\n              } else {\n                if ((param.value != null) && !param.assignedInBody) {\n                  ref = new Assign(new Value(param.name), param.value, null, {\n                    param: true\n                  });\n                } else {\n                  ref = param;\n                }\n              }\n              // Add this parameterâs reference(s) to the function scope.\n              if (param.name instanceof Arr || param.name instanceof Obj) {\n                // This parameter is destructured.\n                param.name.lhs = true;\n                if (!param.shouldCache()) {\n                  param.name.eachName(function(prop) {\n                    return o.scope.parameter(prop.value);\n                  });\n                }\n              } else {\n                // This compilation of the parameter is only to get its name to add\n                // to the scope name tracking; since the compilation output here\n                // isnât kept for eventual output, donât include comments in this\n                // compilation, so that they get output the ârealâ time this param\n                // is compiled.\n                paramToAddToScope = param.value != null ? param : ref;\n                o.scope.parameter(fragmentsToText(paramToAddToScope.compileToFragmentsWithoutComments(o)));\n              }\n              params.push(ref);\n            } else {\n              paramsAfterSplat.push(param);\n              // If this parameter had a default value, since itâs no longer in the\n              // function parameter list we need to assign its default value\n              // (if necessary) as an expression in the body.\n              if ((param.value != null) && !param.shouldCache()) {\n                condition = new Op('===', param, new UndefinedLiteral);\n                ifTrue = new Assign(new Value(param.name), param.value);\n                exprs.push(new If(condition, ifTrue));\n              }\n              if (((ref5 = param.name) != null ? ref5.value : void 0) != null) {\n                // Add this parameter to the scope, since it wouldnât have been added\n                // yet since it was skipped earlier.\n                o.scope.add(param.name.value, 'var', true);\n              }\n            }\n          }\n        }\n        // If there were parameters after the splat or expansion parameter, those\n        // parameters need to be assigned in the body of the function.\n        if (paramsAfterSplat.length !== 0) {\n          // Create a destructured assignment, e.g. `[a, b, c] = [args..., b, c]`\n          exprs.unshift(new Assign(new Value(new Arr([\n            new Splat(new IdentifierLiteral(splatParamName)),\n            ...((function() {\n              var k,\n            len2,\n            results;\n              results = [];\n              for (k = 0, len2 = paramsAfterSplat.length; k < len2; k++) {\n                param = paramsAfterSplat[k];\n                results.push(param.asReference(o));\n              }\n              return results;\n            })())\n          ])), new Value(new IdentifierLiteral(splatParamName))));\n        }\n        // Add new expressions to the function body\n        wasEmpty = this.body.isEmpty();\n        if (!this.expandCtorSuper(thisAssignments)) {\n          this.body.expressions.unshift(...thisAssignments);\n        }\n        this.body.expressions.unshift(...exprs);\n        if (this.isMethod && this.bound && !this.isStatic && this.classVariable) {\n          boundMethodCheck = new Value(new Literal(utility('boundMethodCheck', o)));\n          this.body.expressions.unshift(new Call(boundMethodCheck, [new Value(new ThisLiteral), this.classVariable]));\n        }\n        if (!(wasEmpty || this.noReturn)) {\n          this.body.makeReturn();\n        }\n        // JavaScript doesnât allow bound (`=>`) functions to also be generators.\n        // This is usually caught via `Op::compileContinuation`, but double-check:\n        if (this.bound && this.isGenerator) {\n          yieldNode = this.body.contains(function(node) {\n            return node instanceof Op && node.operator === 'yield';\n          });\n          (yieldNode || this).error('yield cannot occur inside bound (fat arrow) functions');\n        }\n        // Assemble the output\n        modifiers = [];\n        if (this.isMethod && this.isStatic) {\n          modifiers.push('static');\n        }\n        if (this.isAsync) {\n          modifiers.push('async');\n        }\n        if (!(this.isMethod || this.bound)) {\n          modifiers.push(`function${(this.isGenerator ? '*' : '')}`);\n        } else if (this.isGenerator) {\n          modifiers.push('*');\n        }\n        signature = [this.makeCode('(')];\n        // Block comments between a function name and `(` get output between\n        // `function` and `(`.\n        if (((ref6 = this.paramStart) != null ? ref6.comments : void 0) != null) {\n          this.compileCommentFragments(o, this.paramStart, signature);\n        }\n        for (i = k = 0, len2 = params.length; k < len2; i = ++k) {\n          param = params[i];\n          if (i !== 0) {\n            signature.push(this.makeCode(', '));\n          }\n          if (haveSplatParam && i === params.length - 1) {\n            signature.push(this.makeCode('...'));\n          }\n          // Compile this parameter, but if any generated variables get created\n          // (e.g. `ref`), shift those into the parent scope since we canât put a\n          // `var` line inside a function parameter list.\n          scopeVariablesCount = o.scope.variables.length;\n          signature.push(...param.compileToFragments(o));\n          if (scopeVariablesCount !== o.scope.variables.length) {\n            generatedVariables = o.scope.variables.splice(scopeVariablesCount);\n            o.scope.parent.variables.push(...generatedVariables);\n          }\n        }\n        signature.push(this.makeCode(')'));\n        // Block comments between `)` and `->`/`=>` get output between `)` and `{`.\n        if (((ref7 = this.funcGlyph) != null ? ref7.comments : void 0) != null) {\n          ref8 = this.funcGlyph.comments;\n          for (l = 0, len3 = ref8.length; l < len3; l++) {\n            comment = ref8[l];\n            comment.unshift = false;\n          }\n          this.compileCommentFragments(o, this.funcGlyph, signature);\n        }\n        if (!this.body.isEmpty()) {\n          body = this.body.compileWithDeclarations(o);\n        }\n        // We need to compile the body before method names to ensure `super`\n        // references are handled.\n        if (this.isMethod) {\n          [methodScope, o.scope] = [o.scope, o.scope.parent];\n          name = this.name.compileToFragments(o);\n          if (name[0].code === '.') {\n            name.shift();\n          }\n          o.scope = methodScope;\n        }\n        answer = this.joinFragmentArrays((function() {\n          var len4, p, results;\n          results = [];\n          for (p = 0, len4 = modifiers.length; p < len4; p++) {\n            m = modifiers[p];\n            results.push(this.makeCode(m));\n          }\n          return results;\n        }).call(this), ' ');\n        if (modifiers.length && name) {\n          answer.push(this.makeCode(' '));\n        }\n        if (name) {\n          answer.push(...name);\n        }\n        answer.push(...signature);\n        if (this.bound && !this.isMethod) {\n          answer.push(this.makeCode(' =>'));\n        }\n        answer.push(this.makeCode(' {'));\n        if (body != null ? body.length : void 0) {\n          answer.push(this.makeCode('\\n'), ...body, this.makeCode(`\\n${this.tab}`));\n        }\n        answer.push(this.makeCode('}'));\n        if (this.isMethod) {\n          return indentInitial(answer, this);\n        }\n        if (this.front || (o.level >= LEVEL_ACCESS)) {\n          return this.wrapInParentheses(answer);\n        } else {\n          return answer;\n        }\n      }\n\n      eachParamName(iterator) {\n        var j, len1, param, ref1, results;\n        ref1 = this.params;\n        results = [];\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          param = ref1[j];\n          results.push(param.eachName(iterator));\n        }\n        return results;\n      }\n\n      // Short-circuit `traverseChildren` method to prevent it from crossing scope\n      // boundaries unless `crossScope` is `true`.\n      traverseChildren(crossScope, func) {\n        if (crossScope) {\n          return super.traverseChildren(crossScope, func);\n        }\n      }\n\n      // Short-circuit `replaceInContext` method to prevent it from crossing context boundaries. Bound\n      // functions have the same context.\n      replaceInContext(child, replacement) {\n        if (this.bound) {\n          return super.replaceInContext(child, replacement);\n        } else {\n          return false;\n        }\n      }\n\n      expandCtorSuper(thisAssignments) {\n        var haveThisParam, param, ref1, seenSuper;\n        if (!this.ctor) {\n          return false;\n        }\n        this.eachSuperCall(Block.wrap(this.params), function(superCall) {\n          return superCall.error(\"'super' is not allowed in constructor parameter defaults\");\n        });\n        seenSuper = this.eachSuperCall(this.body, (superCall) => {\n          if (this.ctor === 'base') {\n            superCall.error(\"'super' is only allowed in derived class constructors\");\n          }\n          return superCall.expressions = thisAssignments;\n        });\n        haveThisParam = thisAssignments.length && thisAssignments.length !== ((ref1 = this.thisAssignments) != null ? ref1.length : void 0);\n        if (this.ctor === 'derived' && !seenSuper && haveThisParam) {\n          param = thisAssignments[0].variable;\n          param.error(\"Can't use @params in derived class constructors without calling super\");\n        }\n        return seenSuper;\n      }\n\n      // Find all super calls in the given context node;\n      // returns `true` if `iterator` is called.\n      eachSuperCall(context, iterator) {\n        var seenSuper;\n        seenSuper = false;\n        context.traverseChildren(true, (child) => {\n          var childArgs;\n          if (child instanceof SuperCall) {\n            // `super` in a constructor (the only `super` without an accessor)\n            // cannot be given an argument with a reference to `this`, as that would\n            // be referencing `this` before calling `super`.\n            if (!child.variable.accessor) {\n              childArgs = child.args.filter(function(arg) {\n                return !(arg instanceof Class) && (!(arg instanceof Code) || arg.bound);\n              });\n              Block.wrap(childArgs).traverseChildren(true, (node) => {\n                if (node.this) {\n                  return node.error(\"Can't call super with @params in derived class constructors\");\n                }\n              });\n            }\n            seenSuper = true;\n            iterator(child);\n          } else if (child instanceof ThisLiteral && this.ctor === 'derived' && !seenSuper) {\n            child.error(\"Can't reference 'this' before calling super in derived class constructors\");\n          }\n          // `super` has the same target in bound (arrow) functions, so check them too\n          return !(child instanceof SuperCall) && (!(child instanceof Code) || child.bound);\n        });\n        return seenSuper;\n      }\n\n    };\n\n    Code.prototype.children = ['params', 'body'];\n\n    Code.prototype.jumps = NO;\n\n    return Code;\n\n  }).call(this);\n\n  //### Param\n\n  // A parameter in a function definition. Beyond a typical JavaScript parameter,\n  // these parameters can also attach themselves to the context of the function,\n  // as well as be a splat, gathering up a group of parameters into an array.\n  exports.Param = Param = (function() {\n    class Param extends Base {\n      constructor(name1, value1, splat1) {\n        var message, token;\n        super();\n        this.name = name1;\n        this.value = value1;\n        this.splat = splat1;\n        message = isUnassignable(this.name.unwrapAll().value);\n        if (message) {\n          this.name.error(message);\n        }\n        if (this.name instanceof Obj && this.name.generated) {\n          token = this.name.objects[0].operatorToken;\n          token.error(`unexpected ${token.value}`);\n        }\n      }\n\n      compileToFragments(o) {\n        return this.name.compileToFragments(o, LEVEL_LIST);\n      }\n\n      compileToFragmentsWithoutComments(o) {\n        return this.name.compileToFragmentsWithoutComments(o, LEVEL_LIST);\n      }\n\n      asReference(o) {\n        var name, node;\n        if (this.reference) {\n          return this.reference;\n        }\n        node = this.name;\n        if (node.this) {\n          name = node.properties[0].name.value;\n          if (indexOf.call(JS_FORBIDDEN, name) >= 0) {\n            name = `_${name}`;\n          }\n          node = new IdentifierLiteral(o.scope.freeVariable(name));\n        } else if (node.shouldCache()) {\n          node = new IdentifierLiteral(o.scope.freeVariable('arg'));\n        }\n        node = new Value(node);\n        node.updateLocationDataIfMissing(this.locationData);\n        return this.reference = node;\n      }\n\n      shouldCache() {\n        return this.name.shouldCache();\n      }\n\n      // Iterates the name or names of a `Param`.\n      // In a sense, a destructured parameter represents multiple JS parameters. This\n      // method allows to iterate them all.\n      // The `iterator` function will be called as `iterator(name, node)` where\n      // `name` is the name of the parameter and `node` is the AST node corresponding\n      // to that name.\n      eachName(iterator, name = this.name) {\n        var atParam, j, len1, nObj, node, obj, ref1, ref2;\n        atParam = (obj, originalObj = null) => {\n          return iterator(`@${obj.properties[0].name.value}`, obj, this, originalObj);\n        };\n        if (name instanceof Literal) {\n          // * simple literals `foo`\n          return iterator(name.value, name, this);\n        }\n        if (name instanceof Value) {\n          // * at-params `@foo`\n          return atParam(name);\n        }\n        ref2 = (ref1 = name.objects) != null ? ref1 : [];\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          obj = ref2[j];\n          // Save original obj.\n          nObj = obj;\n          // * destructured parameter with default value\n          if (obj instanceof Assign && (obj.context == null)) {\n            obj = obj.variable;\n          }\n          // * assignments within destructured parameters `{foo:bar}`\n          if (obj instanceof Assign) {\n            // ... possibly with a default value\n            if (obj.value instanceof Assign) {\n              obj = obj.value.variable;\n            } else {\n              obj = obj.value;\n            }\n            this.eachName(iterator, obj.unwrap());\n          // * splats within destructured parameters `[xs...]`\n          } else if (obj instanceof Splat) {\n            node = obj.name.unwrap();\n            iterator(node.value, node, this);\n          } else if (obj instanceof Value) {\n            // * destructured parameters within destructured parameters `[{a}]`\n            if (obj.isArray() || obj.isObject()) {\n              this.eachName(iterator, obj.base);\n            // * at-params within destructured parameters `{@foo}`\n            } else if (obj.this) {\n              atParam(obj, nObj);\n            } else {\n              // * simple destructured parameters {foo}\n              iterator(obj.base.value, obj.base, this);\n            }\n          } else if (obj instanceof Elision) {\n            obj;\n          } else if (!(obj instanceof Expansion)) {\n            obj.error(`illegal parameter ${obj.compile()}`);\n          }\n        }\n      }\n\n      // Rename a param by replacing the given AST node for a name with a new node.\n      // This needs to ensure that the the source for object destructuring does not change.\n      renameParam(node, newNode) {\n        var isNode, replacement;\n        isNode = function(candidate) {\n          return candidate === node;\n        };\n        replacement = (node, parent) => {\n          var key;\n          if (parent instanceof Obj) {\n            key = node;\n            if (node.this) {\n              key = node.properties[0].name;\n            }\n            // No need to assign a new variable for the destructured variable if the variable isn't reserved.\n            // Examples:\n            // `({@foo}) ->`  should compile to `({foo}) { this.foo = foo}`\n            // `foo = 1; ({@foo}) ->` should compile to `foo = 1; ({foo:foo1}) { this.foo = foo1 }`\n            if (node.this && key.value === newNode.value) {\n              return new Value(newNode);\n            } else {\n              return new Assign(new Value(key), newNode, 'object');\n            }\n          } else {\n            return newNode;\n          }\n        };\n        return this.replaceInContext(isNode, replacement);\n      }\n\n    };\n\n    Param.prototype.children = ['name', 'value'];\n\n    return Param;\n\n  }).call(this);\n\n  //### Splat\n\n  // A splat, either as a parameter to a function, an argument to a call,\n  // or as part of a destructuring assignment.\n  exports.Splat = Splat = (function() {\n    class Splat extends Base {\n      constructor(name) {\n        super();\n        this.name = name.compile ? name : new Literal(name);\n      }\n\n      shouldCache() {\n        return false;\n      }\n\n      isAssignable() {\n        if (this.name instanceof Obj || this.name instanceof Parens) {\n          return false;\n        }\n        return this.name.isAssignable() && (!this.name.isAtomic || this.name.isAtomic());\n      }\n\n      assigns(name) {\n        return this.name.assigns(name);\n      }\n\n      compileNode(o) {\n        return [this.makeCode('...'), ...this.name.compileToFragments(o, LEVEL_OP)];\n      }\n\n      unwrap() {\n        return this.name;\n      }\n\n    };\n\n    Splat.prototype.children = ['name'];\n\n    return Splat;\n\n  }).call(this);\n\n  //### Expansion\n\n  // Used to skip values inside an array destructuring (pattern matching) or\n  // parameter list.\n  exports.Expansion = Expansion = (function() {\n    class Expansion extends Base {\n      compileNode(o) {\n        return this.error('Expansion must be used inside a destructuring assignment or parameter list');\n      }\n\n      asReference(o) {\n        return this;\n      }\n\n      eachName(iterator) {}\n\n    };\n\n    Expansion.prototype.shouldCache = NO;\n\n    return Expansion;\n\n  }).call(this);\n\n  //### Elision\n\n  // Array elision element (for example, [,a, , , b, , c, ,]).\n  exports.Elision = Elision = (function() {\n    class Elision extends Base {\n      compileToFragments(o, level) {\n        var fragment;\n        fragment = super.compileToFragments(o, level);\n        fragment.isElision = true;\n        return fragment;\n      }\n\n      compileNode(o) {\n        return [this.makeCode(', ')];\n      }\n\n      asReference(o) {\n        return this;\n      }\n\n      eachName(iterator) {}\n\n    };\n\n    Elision.prototype.isAssignable = YES;\n\n    Elision.prototype.shouldCache = NO;\n\n    return Elision;\n\n  }).call(this);\n\n  //### While\n\n  // A while loop, the only sort of low-level loop exposed by CoffeeScript. From\n  // it, all other loops can be manufactured. Useful in cases where you need more\n  // flexibility or more speed than a comprehension can provide.\n  exports.While = While = (function() {\n    class While extends Base {\n      constructor(condition, options) {\n        super();\n        this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;\n        this.guard = options != null ? options.guard : void 0;\n      }\n\n      makeReturn(res) {\n        if (res) {\n          return super.makeReturn(res);\n        } else {\n          this.returns = !this.jumps();\n          return this;\n        }\n      }\n\n      addBody(body1) {\n        this.body = body1;\n        return this;\n      }\n\n      jumps() {\n        var expressions, j, jumpNode, len1, node;\n        ({expressions} = this.body);\n        if (!expressions.length) {\n          return false;\n        }\n        for (j = 0, len1 = expressions.length; j < len1; j++) {\n          node = expressions[j];\n          if (jumpNode = node.jumps({\n            loop: true\n          })) {\n            return jumpNode;\n          }\n        }\n        return false;\n      }\n\n      // The main difference from a JavaScript *while* is that the CoffeeScript\n      // *while* can be used as a part of a larger expression -- while loops may\n      // return an array containing the computed result of each iteration.\n      compileNode(o) {\n        var answer, body, rvar, set;\n        o.indent += TAB;\n        set = '';\n        ({body} = this);\n        if (body.isEmpty()) {\n          body = this.makeCode('');\n        } else {\n          if (this.returns) {\n            body.makeReturn(rvar = o.scope.freeVariable('results'));\n            set = `${this.tab}${rvar} = [];\\n`;\n          }\n          if (this.guard) {\n            if (body.expressions.length > 1) {\n              body.expressions.unshift(new If((new Parens(this.guard)).invert(), new StatementLiteral(\"continue\")));\n            } else {\n              if (this.guard) {\n                body = Block.wrap([new If(this.guard, body)]);\n              }\n            }\n          }\n          body = [].concat(this.makeCode(\"\\n\"), body.compileToFragments(o, LEVEL_TOP), this.makeCode(`\\n${this.tab}`));\n        }\n        answer = [].concat(this.makeCode(set + this.tab + \"while (\"), this.condition.compileToFragments(o, LEVEL_PAREN), this.makeCode(\") {\"), body, this.makeCode(\"}\"));\n        if (this.returns) {\n          answer.push(this.makeCode(`\\n${this.tab}return ${rvar};`));\n        }\n        return answer;\n      }\n\n    };\n\n    While.prototype.children = ['condition', 'guard', 'body'];\n\n    While.prototype.isStatement = YES;\n\n    return While;\n\n  }).call(this);\n\n  //### Op\n\n  // Simple Arithmetic and logical operations. Performs some conversion from\n  // CoffeeScript operations into their JavaScript equivalents.\n  exports.Op = Op = (function() {\n    var CONVERSIONS, INVERSIONS;\n\n    class Op extends Base {\n      constructor(op, first, second, flip) {\n        var firstCall;\n        super();\n        if (op === 'in') {\n          return new In(first, second);\n        }\n        if (op === 'do') {\n          return Op.prototype.generateDo(first);\n        }\n        if (op === 'new') {\n          if ((firstCall = first.unwrap()) instanceof Call && !firstCall.do && !firstCall.isNew) {\n            return firstCall.newInstance();\n          }\n          if (first instanceof Code && first.bound || first.do) {\n            first = new Parens(first);\n          }\n        }\n        this.operator = CONVERSIONS[op] || op;\n        this.first = first;\n        this.second = second;\n        this.flip = !!flip;\n        return this;\n      }\n\n      isNumber() {\n        var ref1;\n        return this.isUnary() && ((ref1 = this.operator) === '+' || ref1 === '-') && this.first instanceof Value && this.first.isNumber();\n      }\n\n      isAwait() {\n        return this.operator === 'await';\n      }\n\n      isYield() {\n        var ref1;\n        return (ref1 = this.operator) === 'yield' || ref1 === 'yield*';\n      }\n\n      isUnary() {\n        return !this.second;\n      }\n\n      shouldCache() {\n        return !this.isNumber();\n      }\n\n      // Am I capable of\n      // [Python-style comparison chaining](https://docs.python.org/3/reference/expressions.html#not-in)?\n      isChainable() {\n        var ref1;\n        return (ref1 = this.operator) === '<' || ref1 === '>' || ref1 === '>=' || ref1 === '<=' || ref1 === '===' || ref1 === '!==';\n      }\n\n      invert() {\n        var allInvertable, curr, fst, op, ref1;\n        if (this.isChainable() && this.first.isChainable()) {\n          allInvertable = true;\n          curr = this;\n          while (curr && curr.operator) {\n            allInvertable && (allInvertable = curr.operator in INVERSIONS);\n            curr = curr.first;\n          }\n          if (!allInvertable) {\n            return new Parens(this).invert();\n          }\n          curr = this;\n          while (curr && curr.operator) {\n            curr.invert = !curr.invert;\n            curr.operator = INVERSIONS[curr.operator];\n            curr = curr.first;\n          }\n          return this;\n        } else if (op = INVERSIONS[this.operator]) {\n          this.operator = op;\n          if (this.first.unwrap() instanceof Op) {\n            this.first.invert();\n          }\n          return this;\n        } else if (this.second) {\n          return new Parens(this).invert();\n        } else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((ref1 = fst.operator) === '!' || ref1 === 'in' || ref1 === 'instanceof')) {\n          return fst;\n        } else {\n          return new Op('!', this);\n        }\n      }\n\n      unfoldSoak(o) {\n        var ref1;\n        return ((ref1 = this.operator) === '++' || ref1 === '--' || ref1 === 'delete') && unfoldSoak(o, this, 'first');\n      }\n\n      generateDo(exp) {\n        var call, func, j, len1, param, passedParams, ref, ref1;\n        passedParams = [];\n        func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;\n        ref1 = func.params || [];\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          param = ref1[j];\n          if (param.value) {\n            passedParams.push(param.value);\n            delete param.value;\n          } else {\n            passedParams.push(param);\n          }\n        }\n        call = new Call(exp, passedParams);\n        call.do = true;\n        return call;\n      }\n\n      compileNode(o) {\n        var answer, isChain, lhs, message, ref1, rhs;\n        isChain = this.isChainable() && this.first.isChainable();\n        if (!isChain) {\n          // In chains, there's no need to wrap bare obj literals in parens,\n          // as the chained expression is wrapped.\n          this.first.front = this.front;\n        }\n        if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) {\n          this.error('delete operand may not be argument or var');\n        }\n        if ((ref1 = this.operator) === '--' || ref1 === '++') {\n          message = isUnassignable(this.first.unwrapAll().value);\n          if (message) {\n            this.first.error(message);\n          }\n        }\n        if (this.isYield() || this.isAwait()) {\n          return this.compileContinuation(o);\n        }\n        if (this.isUnary()) {\n          return this.compileUnary(o);\n        }\n        if (isChain) {\n          return this.compileChain(o);\n        }\n        switch (this.operator) {\n          case '?':\n            return this.compileExistence(o, this.second.isDefaultValue);\n          case '//':\n            return this.compileFloorDivision(o);\n          case '%%':\n            return this.compileModulo(o);\n          default:\n            lhs = this.first.compileToFragments(o, LEVEL_OP);\n            rhs = this.second.compileToFragments(o, LEVEL_OP);\n            answer = [].concat(lhs, this.makeCode(` ${this.operator} `), rhs);\n            if (o.level <= LEVEL_OP) {\n              return answer;\n            } else {\n              return this.wrapInParentheses(answer);\n            }\n        }\n      }\n\n      // Mimic Python's chained comparisons when multiple comparison operators are\n      // used sequentially. For example:\n\n      //     bin/coffee -e 'console.log 50 < 65 > 10'\n      //     true\n      compileChain(o) {\n        var fragments, fst, shared;\n        [this.first.second, shared] = this.first.second.cache(o);\n        fst = this.first.compileToFragments(o, LEVEL_OP);\n        fragments = fst.concat(this.makeCode(` ${(this.invert ? '&&' : '||')} `), shared.compileToFragments(o), this.makeCode(` ${this.operator} `), this.second.compileToFragments(o, LEVEL_OP));\n        return this.wrapInParentheses(fragments);\n      }\n\n      // Keep reference to the left expression, unless this an existential assignment\n      compileExistence(o, checkOnlyUndefined) {\n        var fst, ref;\n        if (this.first.shouldCache()) {\n          ref = new IdentifierLiteral(o.scope.freeVariable('ref'));\n          fst = new Parens(new Assign(ref, this.first));\n        } else {\n          fst = this.first;\n          ref = fst;\n        }\n        return new If(new Existence(fst, checkOnlyUndefined), ref, {\n          type: 'if'\n        }).addElse(this.second).compileToFragments(o);\n      }\n\n      // Compile a unary **Op**.\n      compileUnary(o) {\n        var op, parts, plusMinus;\n        parts = [];\n        op = this.operator;\n        parts.push([this.makeCode(op)]);\n        if (op === '!' && this.first instanceof Existence) {\n          this.first.negated = !this.first.negated;\n          return this.first.compileToFragments(o);\n        }\n        if (o.level >= LEVEL_ACCESS) {\n          return (new Parens(this)).compileToFragments(o);\n        }\n        plusMinus = op === '+' || op === '-';\n        if ((op === 'new' || op === 'typeof' || op === 'delete') || plusMinus && this.first instanceof Op && this.first.operator === op) {\n          parts.push([this.makeCode(' ')]);\n        }\n        if ((plusMinus && this.first instanceof Op) || (op === 'new' && this.first.isStatement(o))) {\n          this.first = new Parens(this.first);\n        }\n        parts.push(this.first.compileToFragments(o, LEVEL_OP));\n        if (this.flip) {\n          parts.reverse();\n        }\n        return this.joinFragmentArrays(parts, '');\n      }\n\n      compileContinuation(o) {\n        var op, parts, ref1, ref2;\n        parts = [];\n        op = this.operator;\n        if (o.scope.parent == null) {\n          this.error(`${this.operator} can only occur inside functions`);\n        }\n        if (((ref1 = o.scope.method) != null ? ref1.bound : void 0) && o.scope.method.isGenerator) {\n          this.error('yield cannot occur inside bound (fat arrow) functions');\n        }\n        if (indexOf.call(Object.keys(this.first), 'expression') >= 0 && !(this.first instanceof Throw)) {\n          if (this.first.expression != null) {\n            parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));\n          }\n        } else {\n          if (o.level >= LEVEL_PAREN) {\n            parts.push([this.makeCode(\"(\")]);\n          }\n          parts.push([this.makeCode(op)]);\n          if (((ref2 = this.first.base) != null ? ref2.value : void 0) !== '') {\n            parts.push([this.makeCode(\" \")]);\n          }\n          parts.push(this.first.compileToFragments(o, LEVEL_OP));\n          if (o.level >= LEVEL_PAREN) {\n            parts.push([this.makeCode(\")\")]);\n          }\n        }\n        return this.joinFragmentArrays(parts, '');\n      }\n\n      compileFloorDivision(o) {\n        var div, floor, second;\n        floor = new Value(new IdentifierLiteral('Math'), [new Access(new PropertyName('floor'))]);\n        second = this.second.shouldCache() ? new Parens(this.second) : this.second;\n        div = new Op('/', this.first, second);\n        return new Call(floor, [div]).compileToFragments(o);\n      }\n\n      compileModulo(o) {\n        var mod;\n        mod = new Value(new Literal(utility('modulo', o)));\n        return new Call(mod, [this.first, this.second]).compileToFragments(o);\n      }\n\n      toString(idt) {\n        return super.toString(idt, this.constructor.name + ' ' + this.operator);\n      }\n\n    };\n\n    // The map of conversions from CoffeeScript to JavaScript symbols.\n    CONVERSIONS = {\n      '==': '===',\n      '!=': '!==',\n      'of': 'in',\n      'yieldfrom': 'yield*'\n    };\n\n    // The map of invertible operators.\n    INVERSIONS = {\n      '!==': '===',\n      '===': '!=='\n    };\n\n    Op.prototype.children = ['first', 'second'];\n\n    return Op;\n\n  }).call(this);\n\n  //### In\n  exports.In = In = (function() {\n    class In extends Base {\n      constructor(object, array) {\n        super();\n        this.object = object;\n        this.array = array;\n      }\n\n      compileNode(o) {\n        var hasSplat, j, len1, obj, ref1;\n        if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {\n          ref1 = this.array.base.objects;\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            obj = ref1[j];\n            if (!(obj instanceof Splat)) {\n              continue;\n            }\n            hasSplat = true;\n            break;\n          }\n          if (!hasSplat) {\n            // `compileOrTest` only if we have an array literal with no splats\n            return this.compileOrTest(o);\n          }\n        }\n        return this.compileLoopTest(o);\n      }\n\n      compileOrTest(o) {\n        var cmp, cnj, i, item, j, len1, ref, ref1, sub, tests;\n        [sub, ref] = this.object.cache(o, LEVEL_OP);\n        [cmp, cnj] = this.negated ? [' !== ', ' && '] : [' === ', ' || '];\n        tests = [];\n        ref1 = this.array.base.objects;\n        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {\n          item = ref1[i];\n          if (i) {\n            tests.push(this.makeCode(cnj));\n          }\n          tests = tests.concat((i ? ref : sub), this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));\n        }\n        if (o.level < LEVEL_OP) {\n          return tests;\n        } else {\n          return this.wrapInParentheses(tests);\n        }\n      }\n\n      compileLoopTest(o) {\n        var fragments, ref, sub;\n        [sub, ref] = this.object.cache(o, LEVEL_LIST);\n        fragments = [].concat(this.makeCode(utility('indexOf', o) + \".call(\"), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(\", \"), ref, this.makeCode(\") \" + (this.negated ? '< 0' : '>= 0')));\n        if (fragmentsToText(sub) === fragmentsToText(ref)) {\n          return fragments;\n        }\n        fragments = sub.concat(this.makeCode(', '), fragments);\n        if (o.level < LEVEL_LIST) {\n          return fragments;\n        } else {\n          return this.wrapInParentheses(fragments);\n        }\n      }\n\n      toString(idt) {\n        return super.toString(idt, this.constructor.name + (this.negated ? '!' : ''));\n      }\n\n    };\n\n    In.prototype.children = ['object', 'array'];\n\n    In.prototype.invert = NEGATE;\n\n    return In;\n\n  }).call(this);\n\n  //### Try\n\n  // A classic *try/catch/finally* block.\n  exports.Try = Try = (function() {\n    class Try extends Base {\n      constructor(attempt, errorVariable, recovery, ensure) {\n        super();\n        this.attempt = attempt;\n        this.errorVariable = errorVariable;\n        this.recovery = recovery;\n        this.ensure = ensure;\n      }\n\n      jumps(o) {\n        var ref1;\n        return this.attempt.jumps(o) || ((ref1 = this.recovery) != null ? ref1.jumps(o) : void 0);\n      }\n\n      makeReturn(res) {\n        if (this.attempt) {\n          this.attempt = this.attempt.makeReturn(res);\n        }\n        if (this.recovery) {\n          this.recovery = this.recovery.makeReturn(res);\n        }\n        return this;\n      }\n\n      // Compilation is more or less as you would expect -- the *finally* clause\n      // is optional, the *catch* is not.\n      compileNode(o) {\n        var catchPart, ensurePart, generatedErrorVariableName, message, placeholder, tryPart;\n        o.indent += TAB;\n        tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);\n        catchPart = this.recovery ? (generatedErrorVariableName = o.scope.freeVariable('error', {\n          reserve: false\n        }), placeholder = new IdentifierLiteral(generatedErrorVariableName), this.errorVariable ? (message = isUnassignable(this.errorVariable.unwrapAll().value), message ? this.errorVariable.error(message) : void 0, this.recovery.unshift(new Assign(this.errorVariable, placeholder))) : void 0, [].concat(this.makeCode(\" catch (\"), placeholder.compileToFragments(o), this.makeCode(\") {\\n\"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode(`\\n${this.tab}}`))) : !(this.ensure || this.recovery) ? (generatedErrorVariableName = o.scope.freeVariable('error', {\n          reserve: false\n        }), [this.makeCode(` catch (${generatedErrorVariableName}) {}`)]) : [];\n        ensurePart = this.ensure ? [].concat(this.makeCode(\" finally {\\n\"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode(`\\n${this.tab}}`)) : [];\n        return [].concat(this.makeCode(`${this.tab}try {\\n`), tryPart, this.makeCode(`\\n${this.tab}}`), catchPart, ensurePart);\n      }\n\n    };\n\n    Try.prototype.children = ['attempt', 'recovery', 'ensure'];\n\n    Try.prototype.isStatement = YES;\n\n    return Try;\n\n  }).call(this);\n\n  //### Throw\n\n  // Simple node to throw an exception.\n  exports.Throw = Throw = (function() {\n    class Throw extends Base {\n      constructor(expression1) {\n        super();\n        this.expression = expression1;\n      }\n\n      compileNode(o) {\n        var fragments;\n        fragments = this.expression.compileToFragments(o, LEVEL_LIST);\n        unshiftAfterComments(fragments, this.makeCode('throw '));\n        fragments.unshift(this.makeCode(this.tab));\n        fragments.push(this.makeCode(';'));\n        return fragments;\n      }\n\n    };\n\n    Throw.prototype.children = ['expression'];\n\n    Throw.prototype.isStatement = YES;\n\n    Throw.prototype.jumps = NO;\n\n    // A **Throw** is already a return, of sorts...\n    Throw.prototype.makeReturn = THIS;\n\n    return Throw;\n\n  }).call(this);\n\n  //### Existence\n\n  // Checks a variable for existence -- not `null` and not `undefined`. This is\n  // similar to `.nil?` in Ruby, and avoids having to consult a JavaScript truth\n  // table. Optionally only check if a variable is not `undefined`.\n  exports.Existence = Existence = (function() {\n    class Existence extends Base {\n      constructor(expression1, onlyNotUndefined = false) {\n        var salvagedComments;\n        super();\n        this.expression = expression1;\n        this.comparisonTarget = onlyNotUndefined ? 'undefined' : 'null';\n        salvagedComments = [];\n        this.expression.traverseChildren(true, function(child) {\n          var comment, j, len1, ref1;\n          if (child.comments) {\n            ref1 = child.comments;\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              comment = ref1[j];\n              if (indexOf.call(salvagedComments, comment) < 0) {\n                salvagedComments.push(comment);\n              }\n            }\n            return delete child.comments;\n          }\n        });\n        attachCommentsToNode(salvagedComments, this);\n        moveComments(this.expression, this);\n      }\n\n      compileNode(o) {\n        var cmp, cnj, code;\n        this.expression.front = this.front;\n        code = this.expression.compile(o, LEVEL_OP);\n        if (this.expression.unwrap() instanceof IdentifierLiteral && !o.scope.check(code)) {\n          [cmp, cnj] = this.negated ? ['===', '||'] : ['!==', '&&'];\n          code = `typeof ${code} ${cmp} \"undefined\"` + (this.comparisonTarget !== 'undefined' ? ` ${cnj} ${code} ${cmp} ${this.comparisonTarget}` : '');\n        } else {\n          // We explicity want to use loose equality (`==`) when comparing against `null`,\n          // so that an existence check roughly corresponds to a check for truthiness.\n          // Do *not* change this to `===` for `null`, as this will break mountains of\n          // existing code. When comparing only against `undefined`, however, we want to\n          // use `===` because this use case is for parity with ES2015+ default values,\n          // which only get assigned when the variable is `undefined` (but not `null`).\n          cmp = this.comparisonTarget === 'null' ? this.negated ? '==' : '!=' : this.negated ? '===' : '!=='; // `undefined`\n          code = `${code} ${cmp} ${this.comparisonTarget}`;\n        }\n        return [this.makeCode(o.level <= LEVEL_COND ? code : `(${code})`)];\n      }\n\n    };\n\n    Existence.prototype.children = ['expression'];\n\n    Existence.prototype.invert = NEGATE;\n\n    return Existence;\n\n  }).call(this);\n\n  //### Parens\n\n  // An extra set of parentheses, specified explicitly in the source. At one time\n  // we tried to clean up the results by detecting and removing redundant\n  // parentheses, but no longer -- you can put in as many as you please.\n\n  // Parentheses are a good way to force any statement to become an expression.\n  exports.Parens = Parens = (function() {\n    class Parens extends Base {\n      constructor(body1) {\n        super();\n        this.body = body1;\n      }\n\n      unwrap() {\n        return this.body;\n      }\n\n      shouldCache() {\n        return this.body.shouldCache();\n      }\n\n      compileNode(o) {\n        var bare, expr, fragments, ref1, shouldWrapComment;\n        expr = this.body.unwrap();\n        // If these parentheses are wrapping an `IdentifierLiteral` followed by a\n        // block comment, output the parentheses (or put another way, donât optimize\n        // away these redundant parentheses). This is because Flow requires\n        // parentheses in certain circumstances to distinguish identifiers followed\n        // by comment-based type annotations from JavaScript labels.\n        shouldWrapComment = (ref1 = expr.comments) != null ? ref1.some(function(comment) {\n          return comment.here && !comment.unshift && !comment.newLine;\n        }) : void 0;\n        if (expr instanceof Value && expr.isAtomic() && !this.csxAttribute && !shouldWrapComment) {\n          expr.front = this.front;\n          return expr.compileToFragments(o);\n        }\n        fragments = expr.compileToFragments(o, LEVEL_PAREN);\n        bare = o.level < LEVEL_OP && !shouldWrapComment && (expr instanceof Op || expr.unwrap() instanceof Call || (expr instanceof For && expr.returns)) && (o.level < LEVEL_COND || fragments.length <= 3);\n        if (this.csxAttribute) {\n          return this.wrapInBraces(fragments);\n        }\n        if (bare) {\n          return fragments;\n        } else {\n          return this.wrapInParentheses(fragments);\n        }\n      }\n\n    };\n\n    Parens.prototype.children = ['body'];\n\n    return Parens;\n\n  }).call(this);\n\n  //### StringWithInterpolations\n  exports.StringWithInterpolations = StringWithInterpolations = (function() {\n    class StringWithInterpolations extends Base {\n      constructor(body1) {\n        super();\n        this.body = body1;\n      }\n\n      // `unwrap` returns `this` to stop ancestor nodes reaching in to grab @body,\n      // and using @body.compileNode. `StringWithInterpolations.compileNode` is\n      // _the_ custom logic to output interpolated strings as code.\n      unwrap() {\n        return this;\n      }\n\n      shouldCache() {\n        return this.body.shouldCache();\n      }\n\n      compileNode(o) {\n        var code, element, elements, expr, fragments, j, len1, salvagedComments, wrapped;\n        if (this.csxAttribute) {\n          wrapped = new Parens(new StringWithInterpolations(this.body));\n          wrapped.csxAttribute = true;\n          return wrapped.compileNode(o);\n        }\n        // Assumes that `expr` is `Value` Â» `StringLiteral` or `Op`\n        expr = this.body.unwrap();\n        elements = [];\n        salvagedComments = [];\n        expr.traverseChildren(false, function(node) {\n          var comment, j, k, len1, len2, ref1;\n          if (node instanceof StringLiteral) {\n            if (node.comments) {\n              salvagedComments.push(...node.comments);\n              delete node.comments;\n            }\n            elements.push(node);\n            return true;\n          } else if (node instanceof Parens) {\n            if (salvagedComments.length !== 0) {\n              for (j = 0, len1 = salvagedComments.length; j < len1; j++) {\n                comment = salvagedComments[j];\n                comment.unshift = true;\n                comment.newLine = true;\n              }\n              attachCommentsToNode(salvagedComments, node);\n            }\n            elements.push(node);\n            return false;\n          } else if (node.comments) {\n            // This node is getting discarded, but salvage its comments.\n            if (elements.length !== 0 && !(elements[elements.length - 1] instanceof StringLiteral)) {\n              ref1 = node.comments;\n              for (k = 0, len2 = ref1.length; k < len2; k++) {\n                comment = ref1[k];\n                comment.unshift = false;\n                comment.newLine = true;\n              }\n              attachCommentsToNode(node.comments, elements[elements.length - 1]);\n            } else {\n              salvagedComments.push(...node.comments);\n            }\n            delete node.comments;\n          }\n          return true;\n        });\n        fragments = [];\n        if (!this.csx) {\n          fragments.push(this.makeCode('`'));\n        }\n        for (j = 0, len1 = elements.length; j < len1; j++) {\n          element = elements[j];\n          if (element instanceof StringLiteral) {\n            element.value = element.unquote(true, this.csx);\n            if (!this.csx) {\n              // Backticks and `${` inside template literals must be escaped.\n              element.value = element.value.replace(/(\\\\*)(`|\\$\\{)/g, function(match, backslashes, toBeEscaped) {\n                if (backslashes.length % 2 === 0) {\n                  return `${backslashes}\\\\${toBeEscaped}`;\n                } else {\n                  return match;\n                }\n              });\n            }\n            fragments.push(...element.compileToFragments(o));\n          } else {\n            if (!this.csx) {\n              fragments.push(this.makeCode('$'));\n            }\n            code = element.compileToFragments(o, LEVEL_PAREN);\n            if (!this.isNestedTag(element) || code.some(function(fragment) {\n              var ref1;\n              return (ref1 = fragment.comments) != null ? ref1.some(function(comment) {\n                return comment.here === false;\n              }) : void 0;\n            })) {\n              code = this.wrapInBraces(code);\n              // Flag the `{` and `}` fragments as having been generated by this\n              // `StringWithInterpolations` node, so that `compileComments` knows\n              // to treat them as bounds. But the braces are unnecessary if all of\n              // the enclosed comments are `/* */` comments. Donât trust\n              // `fragment.type`, which can report minified variable names when\n              // this compiler is minified.\n              code[0].isStringWithInterpolations = true;\n              code[code.length - 1].isStringWithInterpolations = true;\n            }\n            fragments.push(...code);\n          }\n        }\n        if (!this.csx) {\n          fragments.push(this.makeCode('`'));\n        }\n        return fragments;\n      }\n\n      isNestedTag(element) {\n        var call, exprs, ref1;\n        exprs = (ref1 = element.body) != null ? ref1.expressions : void 0;\n        call = exprs != null ? exprs[0].unwrap() : void 0;\n        return this.csx && exprs && exprs.length === 1 && call instanceof Call && call.csx;\n      }\n\n    };\n\n    StringWithInterpolations.prototype.children = ['body'];\n\n    return StringWithInterpolations;\n\n  }).call(this);\n\n  //### For\n\n  // CoffeeScript's replacement for the *for* loop is our array and object\n  // comprehensions, that compile into *for* loops here. They also act as an\n  // expression, able to return the result of each filtered iteration.\n\n  // Unlike Python array comprehensions, they can be multi-line, and you can pass\n  // the current index of the loop as a second parameter. Unlike Ruby blocks,\n  // you can map and filter in a single pass.\n  exports.For = For = (function() {\n    class For extends While {\n      constructor(body, source) {\n        super();\n        this.addBody(body);\n        this.addSource(source);\n      }\n\n      isAwait() {\n        var ref1;\n        return (ref1 = this.await) != null ? ref1 : false;\n      }\n\n      addBody(body) {\n        this.body = Block.wrap([body]);\n        return this;\n      }\n\n      addSource(source) {\n        var attr, attribs, attribute, j, k, len1, len2, ref1, ref2, ref3, ref4;\n        ({source: this.source = false} = source);\n        attribs = [\"name\", \"index\", \"guard\", \"step\", \"own\", \"ownTag\", \"await\", \"awaitTag\", \"object\", \"from\"];\n        for (j = 0, len1 = attribs.length; j < len1; j++) {\n          attr = attribs[j];\n          this[attr] = (ref1 = source[attr]) != null ? ref1 : this[attr];\n        }\n        if (!this.source) {\n          return this;\n        }\n        if (this.from && this.index) {\n          this.index.error('cannot use index with for-from');\n        }\n        if (this.own && !this.object) {\n          this.ownTag.error(`cannot use own with for-${(this.from ? 'from' : 'in')}`);\n        }\n        if (this.object) {\n          [this.name, this.index] = [this.index, this.name];\n        }\n        if (((ref2 = this.index) != null ? typeof ref2.isArray === \"function\" ? ref2.isArray() : void 0 : void 0) || ((ref3 = this.index) != null ? typeof ref3.isObject === \"function\" ? ref3.isObject() : void 0 : void 0)) {\n          this.index.error('index cannot be a pattern matching expression');\n        }\n        if (this.await && !this.from) {\n          this.awaitTag.error('await must be used with for-from');\n        }\n        this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length && !this.from;\n        this.pattern = this.name instanceof Value;\n        if (this.range && this.index) {\n          this.index.error('indexes do not apply to range loops');\n        }\n        if (this.range && this.pattern) {\n          this.name.error('cannot pattern match over range loops');\n        }\n        this.returns = false;\n        ref4 = ['source', 'guard', 'step', 'name', 'index'];\n        // Move up any comments in the â`for` lineâ, i.e. the line of code with `for`,\n        // from any child nodes of that line up to the `for` node itself so that these\n        // comments get output, and get output above the `for` loop.\n        for (k = 0, len2 = ref4.length; k < len2; k++) {\n          attribute = ref4[k];\n          if (!this[attribute]) {\n            continue;\n          }\n          this[attribute].traverseChildren(true, (node) => {\n            var comment, l, len3, ref5;\n            if (node.comments) {\n              ref5 = node.comments;\n              for (l = 0, len3 = ref5.length; l < len3; l++) {\n                comment = ref5[l];\n                // These comments are buried pretty deeply, so if they happen to be\n                // trailing comments the line they trail will be unrecognizable when\n                // weâre done compiling this `for` loop; so just shift them up to\n                // output above the `for` line.\n                comment.newLine = comment.unshift = true;\n              }\n              return moveComments(node, this[attribute]);\n            }\n          });\n          moveComments(this[attribute], this);\n        }\n        return this;\n      }\n\n      // Welcome to the hairiest method in all of CoffeeScript. Handles the inner\n      // loop, filtering, stepping, and result saving for array, object, and range\n      // comprehensions. Some of the generated code can be shared in common, and\n      // some cannot.\n      compileNode(o) {\n        var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, down, forClose, forCode, forPartFragments, fragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, last, lvar, name, namePart, ref, ref1, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart;\n        body = Block.wrap([this.body]);\n        ref1 = body.expressions, [last] = slice1.call(ref1, -1);\n        if ((last != null ? last.jumps() : void 0) instanceof Return) {\n          this.returns = false;\n        }\n        source = this.range ? this.source.base : this.source;\n        scope = o.scope;\n        if (!this.pattern) {\n          name = this.name && (this.name.compile(o, LEVEL_LIST));\n        }\n        index = this.index && (this.index.compile(o, LEVEL_LIST));\n        if (name && !this.pattern) {\n          scope.find(name);\n        }\n        if (index && !(this.index instanceof Value)) {\n          scope.find(index);\n        }\n        if (this.returns) {\n          rvar = scope.freeVariable('results');\n        }\n        if (this.from) {\n          if (this.pattern) {\n            ivar = scope.freeVariable('x', {\n              single: true\n            });\n          }\n        } else {\n          ivar = (this.object && index) || scope.freeVariable('i', {\n            single: true\n          });\n        }\n        kvar = ((this.range || this.from) && name) || index || ivar;\n        kvarAssign = kvar !== ivar ? `${kvar} = ` : \"\";\n        if (this.step && !this.range) {\n          [step, stepVar] = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST, shouldCacheOrIsAssignable));\n          if (this.step.isNumber()) {\n            stepNum = Number(stepVar);\n          }\n        }\n        if (this.pattern) {\n          name = ivar;\n        }\n        varPart = '';\n        guardPart = '';\n        defPart = '';\n        idt1 = this.tab + TAB;\n        if (this.range) {\n          forPartFragments = source.compileToFragments(merge(o, {\n            index: ivar,\n            name,\n            step: this.step,\n            shouldCache: shouldCacheOrIsAssignable\n          }));\n        } else {\n          svar = this.source.compile(o, LEVEL_LIST);\n          if ((name || this.own) && !(this.source.unwrap() instanceof IdentifierLiteral)) {\n            defPart += `${this.tab}${(ref = scope.freeVariable('ref'))} = ${svar};\\n`;\n            svar = ref;\n          }\n          if (name && !this.pattern && !this.from) {\n            namePart = `${name} = ${svar}[${kvar}]`;\n          }\n          if (!this.object && !this.from) {\n            if (step !== stepVar) {\n              defPart += `${this.tab}${step};\\n`;\n            }\n            down = stepNum < 0;\n            if (!(this.step && (stepNum != null) && down)) {\n              lvar = scope.freeVariable('len');\n            }\n            declare = `${kvarAssign}${ivar} = 0, ${lvar} = ${svar}.length`;\n            declareDown = `${kvarAssign}${ivar} = ${svar}.length - 1`;\n            compare = `${ivar} < ${lvar}`;\n            compareDown = `${ivar} >= 0`;\n            if (this.step) {\n              if (stepNum != null) {\n                if (down) {\n                  compare = compareDown;\n                  declare = declareDown;\n                }\n              } else {\n                compare = `${stepVar} > 0 ? ${compare} : ${compareDown}`;\n                declare = `(${stepVar} > 0 ? (${declare}) : ${declareDown})`;\n              }\n              increment = `${ivar} += ${stepVar}`;\n            } else {\n              increment = `${(kvar !== ivar ? `++${ivar}` : `${ivar}++`)}`;\n            }\n            forPartFragments = [this.makeCode(`${declare}; ${compare}; ${kvarAssign}${increment}`)];\n          }\n        }\n        if (this.returns) {\n          resultPart = `${this.tab}${rvar} = [];\\n`;\n          returnResult = `\\n${this.tab}return ${rvar};`;\n          body.makeReturn(rvar);\n        }\n        if (this.guard) {\n          if (body.expressions.length > 1) {\n            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new StatementLiteral(\"continue\")));\n          } else {\n            if (this.guard) {\n              body = Block.wrap([new If(this.guard, body)]);\n            }\n          }\n        }\n        if (this.pattern) {\n          body.expressions.unshift(new Assign(this.name, this.from ? new IdentifierLiteral(kvar) : new Literal(`${svar}[${kvar}]`)));\n        }\n        if (namePart) {\n          varPart = `\\n${idt1}${namePart};`;\n        }\n        if (this.object) {\n          forPartFragments = [this.makeCode(`${kvar} in ${svar}`)];\n          if (this.own) {\n            guardPart = `\\n${idt1}if (!${utility('hasProp', o)}.call(${svar}, ${kvar})) continue;`;\n          }\n        } else if (this.from) {\n          if (this.await) {\n            forPartFragments = new Op('await', new Parens(new Literal(`${kvar} of ${svar}`)));\n            forPartFragments = forPartFragments.compileToFragments(o, LEVEL_TOP);\n          } else {\n            forPartFragments = [this.makeCode(`${kvar} of ${svar}`)];\n          }\n        }\n        bodyFragments = body.compileToFragments(merge(o, {\n          indent: idt1\n        }), LEVEL_TOP);\n        if (bodyFragments && bodyFragments.length > 0) {\n          bodyFragments = [].concat(this.makeCode('\\n'), bodyFragments, this.makeCode('\\n'));\n        }\n        fragments = [this.makeCode(defPart)];\n        if (resultPart) {\n          fragments.push(this.makeCode(resultPart));\n        }\n        forCode = this.await ? 'for ' : 'for (';\n        forClose = this.await ? '' : ')';\n        fragments = fragments.concat(this.makeCode(this.tab), this.makeCode(forCode), forPartFragments, this.makeCode(`${forClose} {${guardPart}${varPart}`), bodyFragments, this.makeCode(this.tab), this.makeCode('}'));\n        if (returnResult) {\n          fragments.push(this.makeCode(returnResult));\n        }\n        return fragments;\n      }\n\n    };\n\n    For.prototype.children = ['body', 'source', 'guard', 'step'];\n\n    return For;\n\n  }).call(this);\n\n  //### Switch\n\n  // A JavaScript *switch* statement. Converts into a returnable expression on-demand.\n  exports.Switch = Switch = (function() {\n    class Switch extends Base {\n      constructor(subject, cases, otherwise) {\n        super();\n        this.subject = subject;\n        this.cases = cases;\n        this.otherwise = otherwise;\n      }\n\n      jumps(o = {\n          block: true\n        }) {\n        var block, conds, j, jumpNode, len1, ref1, ref2;\n        ref1 = this.cases;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          [conds, block] = ref1[j];\n          if (jumpNode = block.jumps(o)) {\n            return jumpNode;\n          }\n        }\n        return (ref2 = this.otherwise) != null ? ref2.jumps(o) : void 0;\n      }\n\n      makeReturn(res) {\n        var j, len1, pair, ref1, ref2;\n        ref1 = this.cases;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          pair = ref1[j];\n          pair[1].makeReturn(res);\n        }\n        if (res) {\n          this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));\n        }\n        if ((ref2 = this.otherwise) != null) {\n          ref2.makeReturn(res);\n        }\n        return this;\n      }\n\n      compileNode(o) {\n        var block, body, cond, conditions, expr, fragments, i, idt1, idt2, j, k, len1, len2, ref1, ref2;\n        idt1 = o.indent + TAB;\n        idt2 = o.indent = idt1 + TAB;\n        fragments = [].concat(this.makeCode(this.tab + \"switch (\"), (this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode(\"false\")), this.makeCode(\") {\\n\"));\n        ref1 = this.cases;\n        for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {\n          [conditions, block] = ref1[i];\n          ref2 = flatten([conditions]);\n          for (k = 0, len2 = ref2.length; k < len2; k++) {\n            cond = ref2[k];\n            if (!this.subject) {\n              cond = cond.invert();\n            }\n            fragments = fragments.concat(this.makeCode(idt1 + \"case \"), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(\":\\n\"));\n          }\n          if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {\n            fragments = fragments.concat(body, this.makeCode('\\n'));\n          }\n          if (i === this.cases.length - 1 && !this.otherwise) {\n            break;\n          }\n          expr = this.lastNode(block.expressions);\n          if (expr instanceof Return || expr instanceof Throw || (expr instanceof Literal && expr.jumps() && expr.value !== 'debugger')) {\n            continue;\n          }\n          fragments.push(cond.makeCode(idt2 + 'break;\\n'));\n        }\n        if (this.otherwise && this.otherwise.expressions.length) {\n          fragments.push(this.makeCode(idt1 + \"default:\\n\"), ...(this.otherwise.compileToFragments(o, LEVEL_TOP)), this.makeCode(\"\\n\"));\n        }\n        fragments.push(this.makeCode(this.tab + '}'));\n        return fragments;\n      }\n\n    };\n\n    Switch.prototype.children = ['subject', 'cases', 'otherwise'];\n\n    Switch.prototype.isStatement = YES;\n\n    return Switch;\n\n  }).call(this);\n\n  //### If\n\n  // *If/else* statements. Acts as an expression by pushing down requested returns\n  // to the last line of each clause.\n\n  // Single-expression **Ifs** are compiled into conditional operators if possible,\n  // because ternaries are already proper expressions, and donât need conversion.\n  exports.If = If = (function() {\n    class If extends Base {\n      constructor(condition, body1, options = {}) {\n        super();\n        this.body = body1;\n        this.condition = options.type === 'unless' ? condition.invert() : condition;\n        this.elseBody = null;\n        this.isChain = false;\n        ({soak: this.soak} = options);\n        if (this.condition.comments) {\n          moveComments(this.condition, this);\n        }\n      }\n\n      bodyNode() {\n        var ref1;\n        return (ref1 = this.body) != null ? ref1.unwrap() : void 0;\n      }\n\n      elseBodyNode() {\n        var ref1;\n        return (ref1 = this.elseBody) != null ? ref1.unwrap() : void 0;\n      }\n\n      // Rewrite a chain of **Ifs** to add a default case as the final *else*.\n      addElse(elseBody) {\n        if (this.isChain) {\n          this.elseBodyNode().addElse(elseBody);\n        } else {\n          this.isChain = elseBody instanceof If;\n          this.elseBody = this.ensureBlock(elseBody);\n          this.elseBody.updateLocationDataIfMissing(elseBody.locationData);\n        }\n        return this;\n      }\n\n      // The **If** only compiles into a statement if either of its bodies needs\n      // to be a statement. Otherwise a conditional operator is safe.\n      isStatement(o) {\n        var ref1;\n        return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((ref1 = this.elseBodyNode()) != null ? ref1.isStatement(o) : void 0);\n      }\n\n      jumps(o) {\n        var ref1;\n        return this.body.jumps(o) || ((ref1 = this.elseBody) != null ? ref1.jumps(o) : void 0);\n      }\n\n      compileNode(o) {\n        if (this.isStatement(o)) {\n          return this.compileStatement(o);\n        } else {\n          return this.compileExpression(o);\n        }\n      }\n\n      makeReturn(res) {\n        if (res) {\n          this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));\n        }\n        this.body && (this.body = new Block([this.body.makeReturn(res)]));\n        this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(res)]));\n        return this;\n      }\n\n      ensureBlock(node) {\n        if (node instanceof Block) {\n          return node;\n        } else {\n          return new Block([node]);\n        }\n      }\n\n      // Compile the `If` as a regular *if-else* statement. Flattened chains\n      // force inner *else* bodies into statement form.\n      compileStatement(o) {\n        var answer, body, child, cond, exeq, ifPart, indent;\n        child = del(o, 'chainChild');\n        exeq = del(o, 'isExistentialEquals');\n        if (exeq) {\n          return new If(this.condition.invert(), this.elseBodyNode(), {\n            type: 'if'\n          }).compileToFragments(o);\n        }\n        indent = o.indent + TAB;\n        cond = this.condition.compileToFragments(o, LEVEL_PAREN);\n        body = this.ensureBlock(this.body).compileToFragments(merge(o, {indent}));\n        ifPart = [].concat(this.makeCode(\"if (\"), cond, this.makeCode(\") {\\n\"), body, this.makeCode(`\\n${this.tab}}`));\n        if (!child) {\n          ifPart.unshift(this.makeCode(this.tab));\n        }\n        if (!this.elseBody) {\n          return ifPart;\n        }\n        answer = ifPart.concat(this.makeCode(' else '));\n        if (this.isChain) {\n          o.chainChild = true;\n          answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));\n        } else {\n          answer = answer.concat(this.makeCode(\"{\\n\"), this.elseBody.compileToFragments(merge(o, {indent}), LEVEL_TOP), this.makeCode(`\\n${this.tab}}`));\n        }\n        return answer;\n      }\n\n      // Compile the `If` as a conditional operator.\n      compileExpression(o) {\n        var alt, body, cond, fragments;\n        cond = this.condition.compileToFragments(o, LEVEL_COND);\n        body = this.bodyNode().compileToFragments(o, LEVEL_LIST);\n        alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];\n        fragments = cond.concat(this.makeCode(\" ? \"), body, this.makeCode(\" : \"), alt);\n        if (o.level >= LEVEL_COND) {\n          return this.wrapInParentheses(fragments);\n        } else {\n          return fragments;\n        }\n      }\n\n      unfoldSoak() {\n        return this.soak && this;\n      }\n\n    };\n\n    If.prototype.children = ['condition', 'body', 'elseBody'];\n\n    return If;\n\n  }).call(this);\n\n  // Constants\n  // ---------\n  UTILITIES = {\n    modulo: function() {\n      return 'function(a, b) { return (+a % (b = +b) + b) % b; }';\n    },\n    boundMethodCheck: function() {\n      return \"function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } }\";\n    },\n    // Shortcuts to speed up the lookup time for native functions.\n    hasProp: function() {\n      return '{}.hasOwnProperty';\n    },\n    indexOf: function() {\n      return '[].indexOf';\n    },\n    slice: function() {\n      return '[].slice';\n    },\n    splice: function() {\n      return '[].splice';\n    }\n  };\n\n  // Levels indicate a node's position in the AST. Useful for knowing if\n  // parens are necessary or superfluous.\n  LEVEL_TOP = 1; // ...;\n\n  LEVEL_PAREN = 2; // (...)\n\n  LEVEL_LIST = 3; // [...]\n\n  LEVEL_COND = 4; // ... ? x : y\n\n  LEVEL_OP = 5; // !...\n\n  LEVEL_ACCESS = 6; // ...[0]\n\n  \n  // Tabs are two spaces for pretty printing.\n  TAB = '  ';\n\n  SIMPLENUM = /^[+-]?\\d+$/;\n\n  // Helper Functions\n  // ----------------\n\n  // Helper for ensuring that utility functions are assigned at the top level.\n  utility = function(name, o) {\n    var ref, root;\n    ({root} = o.scope);\n    if (name in root.utilities) {\n      return root.utilities[name];\n    } else {\n      ref = root.freeVariable(name);\n      root.assign(ref, UTILITIES[name](o));\n      return root.utilities[name] = ref;\n    }\n  };\n\n  multident = function(code, tab, includingFirstLine = true) {\n    var endsWithNewLine;\n    endsWithNewLine = code[code.length - 1] === '\\n';\n    code = (includingFirstLine ? tab : '') + code.replace(/\\n/g, `$&${tab}`);\n    code = code.replace(/\\s+$/, '');\n    if (endsWithNewLine) {\n      code = code + '\\n';\n    }\n    return code;\n  };\n\n  // Wherever in CoffeeScript 1 we mightâve inserted a `makeCode \"#{@tab}\"` to\n  // indent a line of code, now we must account for the possibility of comments\n  // preceding that line of code. If there are such comments, indent each line of\n  // such comments, and _then_ indent the first following line of code.\n  indentInitial = function(fragments, node) {\n    var fragment, fragmentIndex, j, len1;\n    for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {\n      fragment = fragments[fragmentIndex];\n      if (fragment.isHereComment) {\n        fragment.code = multident(fragment.code, node.tab);\n      } else {\n        fragments.splice(fragmentIndex, 0, node.makeCode(`${node.tab}`));\n        break;\n      }\n    }\n    return fragments;\n  };\n\n  hasLineComments = function(node) {\n    var comment, j, len1, ref1;\n    if (!node.comments) {\n      return false;\n    }\n    ref1 = node.comments;\n    for (j = 0, len1 = ref1.length; j < len1; j++) {\n      comment = ref1[j];\n      if (comment.here === false) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Move the `comments` property from one object to another, deleting it from\n  // the first object.\n  moveComments = function(from, to) {\n    if (!(from != null ? from.comments : void 0)) {\n      return;\n    }\n    attachCommentsToNode(from.comments, to);\n    return delete from.comments;\n  };\n\n  // Sometimes when compiling a node, we want to insert a fragment at the start\n  // of an array of fragments; but if the start has one or more comment fragments,\n  // we want to insert this fragment after those but before any non-comments.\n  unshiftAfterComments = function(fragments, fragmentToInsert) {\n    var fragment, fragmentIndex, inserted, j, len1;\n    inserted = false;\n    for (fragmentIndex = j = 0, len1 = fragments.length; j < len1; fragmentIndex = ++j) {\n      fragment = fragments[fragmentIndex];\n      if (!(!fragment.isComment)) {\n        continue;\n      }\n      fragments.splice(fragmentIndex, 0, fragmentToInsert);\n      inserted = true;\n      break;\n    }\n    if (!inserted) {\n      fragments.push(fragmentToInsert);\n    }\n    return fragments;\n  };\n\n  isLiteralArguments = function(node) {\n    return node instanceof IdentifierLiteral && node.value === 'arguments';\n  };\n\n  isLiteralThis = function(node) {\n    return node instanceof ThisLiteral || (node instanceof Code && node.bound);\n  };\n\n  shouldCacheOrIsAssignable = function(node) {\n    return node.shouldCache() || (typeof node.isAssignable === \"function\" ? node.isAssignable() : void 0);\n  };\n\n  // Unfold a node's child if soak, then tuck the node under created `If`\n  unfoldSoak = function(o, parent, name) {\n    var ifn;\n    if (!(ifn = parent[name].unfoldSoak(o))) {\n      return;\n    }\n    parent[name] = ifn.body;\n    ifn.body = new Value(parent);\n    return ifn;\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.262Z",
		"atimeMs": 1551857503262,
		"isfile": true
	},
	"filename": "lib/coffeescript/optparse.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  var LONG_FLAG, MULTI_FLAG, OPTIONAL, OptionParser, SHORT_FLAG, buildRule, buildRules, normalizeArguments, repeat,\n    splice = [].splice;\n\n  ({repeat} = require('./helpers'));\n\n  // A simple **OptionParser** class to parse option flags from the command-line.\n  // Use it like so:\n\n  //     parser  = new OptionParser switches, helpBanner\n  //     options = parser.parse process.argv\n\n  // The first non-option is considered to be the start of the file (and file\n  // option) list, and all subsequent arguments are left unparsed.\n\n  // The `coffee` command uses an instance of **OptionParser** to parse its\n  // command-line arguments in `src/command.coffee`.\n  exports.OptionParser = OptionParser = class OptionParser {\n    // Initialize with a list of valid options, in the form:\n\n    //     [short-flag, long-flag, description]\n\n    // Along with an optional banner for the usage help.\n    constructor(ruleDeclarations, banner) {\n      this.banner = banner;\n      this.rules = buildRules(ruleDeclarations);\n    }\n\n    // Parse the list of arguments, populating an `options` object with all of the\n    // specified options, and return it. Options after the first non-option\n    // argument are treated as arguments. `options.arguments` will be an array\n    // containing the remaining arguments. This is a simpler API than many option\n    // parsers that allow you to attach callback actions for every flag. Instead,\n    // you're responsible for interpreting the options object.\n    parse(args) {\n      var argument, hasArgument, i, isList, len, name, options, positional, rules;\n      // The CoffeeScript option parser is a little odd; options after the first\n      // non-option argument are treated as non-option arguments themselves.\n      // Optional arguments are normalized by expanding merged flags into multiple\n      // flags. This allows you to have `-wl` be the same as `--watch --lint`.\n      // Note that executable scripts with a shebang (`#!`) line should use the\n      // line `#!/usr/bin/env coffee`, or `#!/absolute/path/to/coffee`, without a\n      // `--` argument after, because that will fail on Linux (see #3946).\n      ({rules, positional} = normalizeArguments(args, this.rules.flagDict));\n      options = {};\n// The `argument` field is added to the rule instance non-destructively by\n// `normalizeArguments`.\n      for (i = 0, len = rules.length; i < len; i++) {\n        ({hasArgument, argument, isList, name} = rules[i]);\n        if (hasArgument) {\n          if (isList) {\n            if (options[name] == null) {\n              options[name] = [];\n            }\n            options[name].push(argument);\n          } else {\n            options[name] = argument;\n          }\n        } else {\n          options[name] = true;\n        }\n      }\n      if (positional[0] === '--') {\n        options.doubleDashed = true;\n        positional = positional.slice(1);\n      }\n      options.arguments = positional;\n      return options;\n    }\n\n    // Return the help text for this **OptionParser**, listing and describing all\n    // of the valid options, for `--help` and such.\n    help() {\n      var i, len, letPart, lines, ref, rule, spaces;\n      lines = [];\n      if (this.banner) {\n        lines.unshift(`${this.banner}\\n`);\n      }\n      ref = this.rules.ruleList;\n      for (i = 0, len = ref.length; i < len; i++) {\n        rule = ref[i];\n        spaces = 15 - rule.longFlag.length;\n        spaces = spaces > 0 ? repeat(' ', spaces) : '';\n        letPart = rule.shortFlag ? rule.shortFlag + ', ' : '    ';\n        lines.push('  ' + letPart + rule.longFlag + spaces + rule.description);\n      }\n      return `\\n${lines.join('\\n')}\\n`;\n    }\n\n  };\n\n  // Helpers\n  // -------\n\n  // Regex matchers for option flags on the command line and their rules.\n  LONG_FLAG = /^(--\\w[\\w\\-]*)/;\n\n  SHORT_FLAG = /^(-\\w)$/;\n\n  MULTI_FLAG = /^-(\\w{2,})/;\n\n  // Matches the long flag part of a rule for an option with an argument. Not\n  // applied to anything in process.argv.\n  OPTIONAL = /\\[(\\w+(\\*?))\\]/;\n\n  // Build and return the list of option rules. If the optional *short-flag* is\n  // unspecified, leave it out by padding with `null`.\n  buildRules = function(ruleDeclarations) {\n    var flag, flagDict, i, j, len, len1, ref, rule, ruleList, tuple;\n    ruleList = (function() {\n      var i, len, results;\n      results = [];\n      for (i = 0, len = ruleDeclarations.length; i < len; i++) {\n        tuple = ruleDeclarations[i];\n        if (tuple.length < 3) {\n          tuple.unshift(null);\n        }\n        results.push(buildRule(...tuple));\n      }\n      return results;\n    })();\n    flagDict = {};\n    for (i = 0, len = ruleList.length; i < len; i++) {\n      rule = ruleList[i];\n      ref = [rule.shortFlag, rule.longFlag];\n      // `shortFlag` is null if not provided in the rule.\n      for (j = 0, len1 = ref.length; j < len1; j++) {\n        flag = ref[j];\n        if (!(flag != null)) {\n          continue;\n        }\n        if (flagDict[flag] != null) {\n          throw new Error(`flag ${flag} for switch ${rule.name} was already declared for switch ${flagDict[flag].name}`);\n        }\n        flagDict[flag] = rule;\n      }\n    }\n    return {ruleList, flagDict};\n  };\n\n  // Build a rule from a `-o` short flag, a `--output [DIR]` long flag, and the\n  // description of what the option does.\n  buildRule = function(shortFlag, longFlag, description) {\n    var match;\n    match = longFlag.match(OPTIONAL);\n    shortFlag = shortFlag != null ? shortFlag.match(SHORT_FLAG)[1] : void 0;\n    longFlag = longFlag.match(LONG_FLAG)[1];\n    return {\n      name: longFlag.replace(/^--/, ''),\n      shortFlag: shortFlag,\n      longFlag: longFlag,\n      description: description,\n      hasArgument: !!(match && match[1]),\n      isList: !!(match && match[2])\n    };\n  };\n\n  normalizeArguments = function(args, flagDict) {\n    var arg, argIndex, flag, i, innerOpts, j, lastOpt, len, len1, multiFlags, multiOpts, needsArgOpt, positional, ref, rule, rules, singleRule, withArg;\n    rules = [];\n    positional = [];\n    needsArgOpt = null;\n    for (argIndex = i = 0, len = args.length; i < len; argIndex = ++i) {\n      arg = args[argIndex];\n      // If the previous argument given to the script was an option that uses the\n      // next command-line argument as its argument, create copy of the optionâs\n      // rule with an `argument` field.\n      if (needsArgOpt != null) {\n        withArg = Object.assign({}, needsArgOpt.rule, {\n          argument: arg\n        });\n        rules.push(withArg);\n        needsArgOpt = null;\n        continue;\n      }\n      multiFlags = (ref = arg.match(MULTI_FLAG)) != null ? ref[1].split('').map(function(flagName) {\n        return `-${flagName}`;\n      }) : void 0;\n      if (multiFlags != null) {\n        multiOpts = multiFlags.map(function(flag) {\n          var rule;\n          rule = flagDict[flag];\n          if (rule == null) {\n            throw new Error(`unrecognized option ${flag} in multi-flag ${arg}`);\n          }\n          return {rule, flag};\n        });\n        // Only the last flag in a multi-flag may have an argument.\n        [...innerOpts] = multiOpts, [lastOpt] = splice.call(innerOpts, -1);\n        for (j = 0, len1 = innerOpts.length; j < len1; j++) {\n          ({rule, flag} = innerOpts[j]);\n          if (rule.hasArgument) {\n            throw new Error(`cannot use option ${flag} in multi-flag ${arg} except as the last option, because it needs an argument`);\n          }\n          rules.push(rule);\n        }\n        if (lastOpt.rule.hasArgument) {\n          needsArgOpt = lastOpt;\n        } else {\n          rules.push(lastOpt.rule);\n        }\n      } else if ([LONG_FLAG, SHORT_FLAG].some(function(pat) {\n        return arg.match(pat) != null;\n      })) {\n        singleRule = flagDict[arg];\n        if (singleRule == null) {\n          throw new Error(`unrecognized option ${arg}`);\n        }\n        if (singleRule.hasArgument) {\n          needsArgOpt = {\n            rule: singleRule,\n            flag: arg\n          };\n        } else {\n          rules.push(singleRule);\n        }\n      } else {\n        // This is a positional argument.\n        positional = args.slice(argIndex);\n        break;\n      }\n    }\n    if (needsArgOpt != null) {\n      throw new Error(`value required for ${needsArgOpt.flag}, but it was the last argument provided`);\n    }\n    return {rules, positional};\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.263Z",
		"atimeMs": 1551857503263,
		"isfile": true
	},
	"filename": "lib/coffeescript/parser.js",
	"content": "/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,24],$V1=[1,56],$V2=[1,91],$V3=[1,92],$V4=[1,87],$V5=[1,93],$V6=[1,94],$V7=[1,89],$V8=[1,90],$V9=[1,64],$Va=[1,66],$Vb=[1,67],$Vc=[1,68],$Vd=[1,69],$Ve=[1,70],$Vf=[1,72],$Vg=[1,73],$Vh=[1,58],$Vi=[1,42],$Vj=[1,36],$Vk=[1,76],$Vl=[1,77],$Vm=[1,86],$Vn=[1,54],$Vo=[1,59],$Vp=[1,60],$Vq=[1,74],$Vr=[1,75],$Vs=[1,47],$Vt=[1,55],$Vu=[1,71],$Vv=[1,81],$Vw=[1,82],$Vx=[1,83],$Vy=[1,84],$Vz=[1,53],$VA=[1,80],$VB=[1,38],$VC=[1,39],$VD=[1,40],$VE=[1,41],$VF=[1,43],$VG=[1,44],$VH=[1,95],$VI=[1,6,35,48,146],$VJ=[1,6,33,35,48,70,71,93,127,135,146,149,157],$VK=[1,113],$VL=[1,114],$VM=[1,115],$VN=[1,110],$VO=[1,98],$VP=[1,97],$VQ=[1,96],$VR=[1,99],$VS=[1,100],$VT=[1,101],$VU=[1,102],$VV=[1,103],$VW=[1,104],$VX=[1,105],$VY=[1,106],$VZ=[1,107],$V_=[1,108],$V$=[1,109],$V01=[1,117],$V11=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$V21=[2,198],$V31=[1,123],$V41=[1,128],$V51=[1,124],$V61=[1,125],$V71=[1,126],$V81=[1,129],$V91=[1,122],$Va1=[1,6,33,35,48,70,71,93,127,135,146,148,149,150,156,157,174],$Vb1=[1,6,33,35,46,47,48,70,71,80,81,83,88,93,101,102,103,105,109,125,126,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$Vc1=[2,123],$Vd1=[2,127],$Ve1=[6,33,88,93],$Vf1=[2,100],$Vg1=[1,141],$Vh1=[1,135],$Vi1=[1,140],$Vj1=[1,144],$Vk1=[1,149],$Vl1=[1,147],$Vm1=[1,151],$Vn1=[1,155],$Vo1=[1,153],$Vp1=[1,159],$Vq1=[1,6,33,35,46,47,48,62,70,71,80,81,83,88,93,101,102,103,105,109,125,126,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$Vr1=[2,120],$Vs1=[1,6,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$Vt1=[2,31],$Vu1=[1,184],$Vv1=[1,185],$Vw1=[2,87],$Vx1=[1,189],$Vy1=[1,195],$Vz1=[1,210],$VA1=[1,205],$VB1=[1,214],$VC1=[1,211],$VD1=[1,216],$VE1=[1,217],$VF1=[1,219],$VG1=[14,32,33,39,40,44,46,47,50,51,55,56,57,58,59,60,69,77,84,85,86,90,91,107,110,112,120,129,130,140,144,145,148,150,153,156,167,173,176,177,178,179,180,181],$VH1=[1,6,33,35,46,47,48,62,70,71,80,81,83,88,93,101,102,103,105,109,111,125,126,127,135,146,148,149,150,156,157,174,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194],$VI1=[1,230],$VJ1=[1,231],$VK1=[2,144],$VL1=[1,247],$VM1=[1,249],$VN1=[1,259],$VO1=[1,6,33,35,46,47,48,66,70,71,80,81,83,88,93,101,102,103,105,109,125,126,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$VP1=[1,6,33,35,36,46,47,48,62,66,70,71,80,81,83,88,93,101,102,103,105,109,111,117,125,126,127,135,146,148,149,150,156,157,164,165,166,174,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194],$VQ1=[1,6,33,35,46,47,48,53,66,70,71,80,81,83,88,93,101,102,103,105,109,125,126,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$VR1=[1,289],$VS1=[46,47,126],$VT1=[1,300],$VU1=[1,299],$VV1=[6,33],$VW1=[2,98],$VX1=[1,306],$VY1=[6,33,35,88,93],$VZ1=[6,33,35,62,71,88,93],$V_1=[1,6,33,35,48,70,71,80,81,83,88,93,101,102,103,105,109,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$V$1=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,178,179,183,184,185,186,187,188,189,190,191,192,193],$V02=[2,350],$V12=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,178,179,183,185,186,187,188,189,190,191,192,193],$V22=[46,47,80,81,101,102,103,105,125,126],$V32=[1,334],$V42=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174],$V52=[2,85],$V62=[1,351],$V72=[1,353],$V82=[1,358],$V92=[1,360],$Va2=[6,33,70,93],$Vb2=[2,223],$Vc2=[2,224],$Vd2=[1,6,33,35,46,47,48,62,70,71,80,81,83,88,93,101,102,103,105,109,125,126,127,135,146,148,149,150,156,157,164,165,166,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$Ve2=[1,374],$Vf2=[6,14,32,33,35,39,40,44,46,47,50,51,55,56,57,58,59,60,69,70,71,77,84,85,86,90,91,93,107,110,112,120,129,130,140,144,145,148,150,153,156,167,173,176,177,178,179,180,181],$Vg2=[6,33,35,70,93],$Vh2=[6,33,35,70,93,127],$Vi2=[1,6,33,35,46,47,48,62,66,70,71,80,81,83,88,93,101,102,103,105,109,111,125,126,127,135,146,148,149,150,156,157,164,165,166,174,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194],$Vj2=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,157,174],$Vk2=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,149,157,174],$Vl2=[2,275],$Vm2=[164,165,166],$Vn2=[93,164,165,166],$Vo2=[6,33,109],$Vp2=[1,399],$Vq2=[6,33,35,93,109],$Vr2=[6,33,35,66,93,109],$Vs2=[1,405],$Vt2=[1,406],$Vu2=[6,33,35,62,66,71,80,81,93,109,126],$Vv2=[6,33,35,71,80,81,93,109,126],$Vw2=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,178,179,185,186,187,188,189,190,191,192,193],$Vx2=[2,342],$Vy2=[2,341],$Vz2=[1,6,33,35,46,47,48,53,70,71,80,81,83,88,93,101,102,103,105,109,125,126,127,135,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$VA2=[1,428],$VB2=[14,32,39,40,44,46,47,50,51,55,56,57,58,59,60,69,77,83,84,85,86,90,91,107,110,112,120,129,130,140,144,145,148,150,153,156,167,173,176,177,178,179,180,181],$VC2=[2,209],$VD2=[6,33,35],$VE2=[2,99],$VF2=[1,437],$VG2=[1,438],$VH2=[1,6,33,35,48,70,71,80,81,83,88,93,101,102,103,105,109,127,135,142,143,146,148,149,150,156,157,169,171,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$VI2=[1,315],$VJ2=[35,169,171],$VK2=[1,6,35,48,70,71,83,88,93,109,127,135,146,149,157,174],$VL2=[1,475],$VM2=[1,481],$VN2=[1,6,33,35,48,70,71,93,127,135,146,149,157,174],$VO2=[2,114],$VP2=[1,494],$VQ2=[1,495],$VR2=[6,33,35,70],$VS2=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,169,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$VT2=[1,6,33,35,48,70,71,93,127,135,146,149,157,169],$VU2=[2,289],$VV2=[2,290],$VW2=[2,305],$VX2=[1,518],$VY2=[1,519],$VZ2=[6,33,35,109],$V_2=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,150,156,157,174],$V$2=[1,540],$V03=[6,33,35,93,127],$V13=[6,33,35,93],$V23=[1,6,33,35,48,70,71,83,88,93,109,127,135,142,146,148,149,150,156,157,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$V33=[33,93],$V43=[1,568],$V53=[1,569],$V63=[1,575],$V73=[1,576],$V83=[2,260],$V93=[2,263],$Va3=[2,276],$Vb3=[1,625],$Vc3=[1,626],$Vd3=[2,291],$Ve3=[2,295],$Vf3=[2,292],$Vg3=[2,296],$Vh3=[2,293],$Vi3=[2,294],$Vj3=[2,306],$Vk3=[2,307],$Vl3=[1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,174],$Vm3=[2,297],$Vn3=[2,299],$Vo3=[2,301],$Vp3=[2,303],$Vq3=[2,298],$Vr3=[2,300],$Vs3=[2,302],$Vt3=[2,304];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"Root\":3,\"Body\":4,\"Line\":5,\"TERMINATOR\":6,\"Expression\":7,\"ExpressionLine\":8,\"Statement\":9,\"FuncDirective\":10,\"YieldReturn\":11,\"AwaitReturn\":12,\"Return\":13,\"STATEMENT\":14,\"Import\":15,\"Export\":16,\"Value\":17,\"Code\":18,\"Operation\":19,\"Assign\":20,\"If\":21,\"Try\":22,\"While\":23,\"For\":24,\"Switch\":25,\"Class\":26,\"Throw\":27,\"Yield\":28,\"CodeLine\":29,\"IfLine\":30,\"OperationLine\":31,\"YIELD\":32,\"INDENT\":33,\"Object\":34,\"OUTDENT\":35,\"FROM\":36,\"Block\":37,\"Identifier\":38,\"IDENTIFIER\":39,\"CSX_TAG\":40,\"Property\":41,\"PROPERTY\":42,\"AlphaNumeric\":43,\"NUMBER\":44,\"String\":45,\"STRING\":46,\"STRING_START\":47,\"STRING_END\":48,\"Regex\":49,\"REGEX\":50,\"REGEX_START\":51,\"Invocation\":52,\"REGEX_END\":53,\"Literal\":54,\"JS\":55,\"UNDEFINED\":56,\"NULL\":57,\"BOOL\":58,\"INFINITY\":59,\"NAN\":60,\"Assignable\":61,\"=\":62,\"AssignObj\":63,\"ObjAssignable\":64,\"ObjRestValue\":65,\":\":66,\"SimpleObjAssignable\":67,\"ThisProperty\":68,\"[\":69,\"]\":70,\"...\":71,\"ObjSpreadExpr\":72,\"ObjSpreadIdentifier\":73,\"Parenthetical\":74,\"Super\":75,\"This\":76,\"SUPER\":77,\"Arguments\":78,\"ObjSpreadAccessor\":79,\".\":80,\"INDEX_START\":81,\"IndexValue\":82,\"INDEX_END\":83,\"RETURN\":84,\"AWAIT\":85,\"PARAM_START\":86,\"ParamList\":87,\"PARAM_END\":88,\"FuncGlyph\":89,\"->\":90,\"=>\":91,\"OptComma\":92,\",\":93,\"Param\":94,\"ParamVar\":95,\"Array\":96,\"Splat\":97,\"SimpleAssignable\":98,\"Accessor\":99,\"Range\":100,\"?.\":101,\"::\":102,\"?::\":103,\"Index\":104,\"INDEX_SOAK\":105,\"Slice\":106,\"{\":107,\"AssignList\":108,\"}\":109,\"CLASS\":110,\"EXTENDS\":111,\"IMPORT\":112,\"ImportDefaultSpecifier\":113,\"ImportNamespaceSpecifier\":114,\"ImportSpecifierList\":115,\"ImportSpecifier\":116,\"AS\":117,\"DEFAULT\":118,\"IMPORT_ALL\":119,\"EXPORT\":120,\"ExportSpecifierList\":121,\"EXPORT_ALL\":122,\"ExportSpecifier\":123,\"OptFuncExist\":124,\"FUNC_EXIST\":125,\"CALL_START\":126,\"CALL_END\":127,\"ArgList\":128,\"THIS\":129,\"@\":130,\"Elisions\":131,\"ArgElisionList\":132,\"OptElisions\":133,\"RangeDots\":134,\"..\":135,\"Arg\":136,\"ArgElision\":137,\"Elision\":138,\"SimpleArgs\":139,\"TRY\":140,\"Catch\":141,\"FINALLY\":142,\"CATCH\":143,\"THROW\":144,\"(\":145,\")\":146,\"WhileLineSource\":147,\"WHILE\":148,\"WHEN\":149,\"UNTIL\":150,\"WhileSource\":151,\"Loop\":152,\"LOOP\":153,\"ForBody\":154,\"ForLineBody\":155,\"FOR\":156,\"BY\":157,\"ForStart\":158,\"ForSource\":159,\"ForLineSource\":160,\"ForVariables\":161,\"OWN\":162,\"ForValue\":163,\"FORIN\":164,\"FOROF\":165,\"FORFROM\":166,\"SWITCH\":167,\"Whens\":168,\"ELSE\":169,\"When\":170,\"LEADING_WHEN\":171,\"IfBlock\":172,\"IF\":173,\"POST_IF\":174,\"IfBlockLine\":175,\"UNARY\":176,\"UNARY_MATH\":177,\"-\":178,\"+\":179,\"--\":180,\"++\":181,\"?\":182,\"MATH\":183,\"**\":184,\"SHIFT\":185,\"COMPARE\":186,\"&\":187,\"^\":188,\"|\":189,\"&&\":190,\"||\":191,\"BIN?\":192,\"RELATION\":193,\"COMPOUND_ASSIGN\":194,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",6:\"TERMINATOR\",14:\"STATEMENT\",32:\"YIELD\",33:\"INDENT\",35:\"OUTDENT\",36:\"FROM\",39:\"IDENTIFIER\",40:\"CSX_TAG\",42:\"PROPERTY\",44:\"NUMBER\",46:\"STRING\",47:\"STRING_START\",48:\"STRING_END\",50:\"REGEX\",51:\"REGEX_START\",53:\"REGEX_END\",55:\"JS\",56:\"UNDEFINED\",57:\"NULL\",58:\"BOOL\",59:\"INFINITY\",60:\"NAN\",62:\"=\",66:\":\",69:\"[\",70:\"]\",71:\"...\",77:\"SUPER\",80:\".\",81:\"INDEX_START\",83:\"INDEX_END\",84:\"RETURN\",85:\"AWAIT\",86:\"PARAM_START\",88:\"PARAM_END\",90:\"->\",91:\"=>\",93:\",\",101:\"?.\",102:\"::\",103:\"?::\",105:\"INDEX_SOAK\",107:\"{\",109:\"}\",110:\"CLASS\",111:\"EXTENDS\",112:\"IMPORT\",117:\"AS\",118:\"DEFAULT\",119:\"IMPORT_ALL\",120:\"EXPORT\",122:\"EXPORT_ALL\",125:\"FUNC_EXIST\",126:\"CALL_START\",127:\"CALL_END\",129:\"THIS\",130:\"@\",135:\"..\",140:\"TRY\",142:\"FINALLY\",143:\"CATCH\",144:\"THROW\",145:\"(\",146:\")\",148:\"WHILE\",149:\"WHEN\",150:\"UNTIL\",153:\"LOOP\",156:\"FOR\",157:\"BY\",162:\"OWN\",164:\"FORIN\",165:\"FOROF\",166:\"FORFROM\",167:\"SWITCH\",169:\"ELSE\",171:\"LEADING_WHEN\",173:\"IF\",174:\"POST_IF\",176:\"UNARY\",177:\"UNARY_MATH\",178:\"-\",179:\"+\",180:\"--\",181:\"++\",182:\"?\",183:\"MATH\",184:\"**\",185:\"SHIFT\",186:\"COMPARE\",187:\"&\",188:\"^\",189:\"|\",190:\"&&\",191:\"||\",192:\"BIN?\",193:\"RELATION\",194:\"COMPOUND_ASSIGN\"},\nproductions_: [0,[3,0],[3,1],[4,1],[4,3],[4,2],[5,1],[5,1],[5,1],[5,1],[10,1],[10,1],[9,1],[9,1],[9,1],[9,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[8,1],[8,1],[8,1],[28,1],[28,2],[28,4],[28,3],[37,2],[37,3],[38,1],[38,1],[41,1],[43,1],[43,1],[45,1],[45,3],[49,1],[49,3],[54,1],[54,1],[54,1],[54,1],[54,1],[54,1],[54,1],[54,1],[20,3],[20,4],[20,5],[63,1],[63,1],[63,3],[63,5],[63,3],[63,5],[67,1],[67,1],[67,1],[64,1],[64,3],[64,1],[65,2],[65,2],[65,2],[65,2],[72,1],[72,1],[72,1],[72,1],[72,1],[72,2],[72,2],[72,2],[73,2],[73,2],[79,2],[79,3],[13,2],[13,4],[13,1],[11,3],[11,2],[12,3],[12,2],[18,5],[18,2],[29,5],[29,2],[89,1],[89,1],[92,0],[92,1],[87,0],[87,1],[87,3],[87,4],[87,6],[94,1],[94,2],[94,2],[94,3],[94,1],[95,1],[95,1],[95,1],[95,1],[97,2],[97,2],[98,1],[98,2],[98,2],[98,1],[61,1],[61,1],[61,1],[17,1],[17,1],[17,1],[17,1],[17,1],[17,1],[17,1],[75,3],[75,4],[99,2],[99,2],[99,2],[99,2],[99,1],[99,1],[99,1],[104,3],[104,2],[82,1],[82,1],[34,4],[108,0],[108,1],[108,3],[108,4],[108,6],[26,1],[26,2],[26,3],[26,4],[26,2],[26,3],[26,4],[26,5],[15,2],[15,4],[15,4],[15,5],[15,7],[15,6],[15,9],[115,1],[115,3],[115,4],[115,4],[115,6],[116,1],[116,3],[116,1],[116,3],[113,1],[114,3],[16,3],[16,5],[16,2],[16,4],[16,5],[16,6],[16,3],[16,5],[16,4],[16,7],[121,1],[121,3],[121,4],[121,4],[121,6],[123,1],[123,3],[123,3],[123,1],[123,3],[52,3],[52,3],[52,3],[124,0],[124,1],[78,2],[78,4],[76,1],[76,1],[68,2],[96,2],[96,3],[96,4],[134,1],[134,1],[100,5],[100,5],[106,3],[106,2],[106,3],[106,2],[106,2],[106,1],[128,1],[128,3],[128,4],[128,4],[128,6],[136,1],[136,1],[136,1],[136,1],[132,1],[132,3],[132,4],[132,4],[132,6],[137,1],[137,2],[133,1],[133,2],[131,1],[131,2],[138,1],[139,1],[139,1],[139,3],[139,3],[22,2],[22,3],[22,4],[22,5],[141,3],[141,3],[141,2],[27,2],[27,4],[74,3],[74,5],[147,2],[147,4],[147,2],[147,4],[151,2],[151,4],[151,4],[151,2],[151,4],[151,4],[23,2],[23,2],[23,2],[23,2],[23,1],[152,2],[152,2],[24,2],[24,2],[24,2],[24,2],[154,2],[154,4],[154,2],[155,4],[155,2],[158,2],[158,3],[158,3],[163,1],[163,1],[163,1],[163,1],[161,1],[161,3],[159,2],[159,2],[159,4],[159,4],[159,4],[159,4],[159,4],[159,4],[159,6],[159,6],[159,6],[159,6],[159,6],[159,6],[159,6],[159,6],[159,2],[159,4],[159,4],[160,2],[160,2],[160,4],[160,4],[160,4],[160,4],[160,4],[160,4],[160,6],[160,6],[160,6],[160,6],[160,6],[160,6],[160,6],[160,6],[160,2],[160,4],[160,4],[25,5],[25,5],[25,7],[25,7],[25,4],[25,6],[168,1],[168,2],[170,3],[170,4],[172,3],[172,5],[21,1],[21,3],[21,3],[21,3],[175,3],[175,5],[30,1],[30,3],[30,3],[30,3],[31,2],[19,2],[19,2],[19,2],[19,2],[19,2],[19,4],[19,2],[19,2],[19,2],[19,2],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,5],[19,4]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\nreturn this.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Block);\nbreak;\ncase 2:\nreturn this.$ = $$[$0];\nbreak;\ncase 3:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(yy.Block.wrap([$$[$0]]));\nbreak;\ncase 4:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])($$[$0-2].push($$[$0]));\nbreak;\ncase 5:\nthis.$ = $$[$0-1];\nbreak;\ncase 6: case 7: case 8: case 9: case 10: case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 41: case 46: case 48: case 58: case 63: case 64: case 65: case 66: case 68: case 73: case 74: case 75: case 76: case 77: case 98: case 99: case 110: case 111: case 112: case 113: case 119: case 120: case 123: case 128: case 138: case 223: case 224: case 225: case 227: case 239: case 240: case 283: case 284: case 333: case 339: case 345:\nthis.$ = $$[$0];\nbreak;\ncase 13:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.StatementLiteral($$[$0]));\nbreak;\ncase 31:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Op($$[$0],\n      new yy.Value(new yy.Literal(''))));\nbreak;\ncase 32: case 349: case 350: case 351: case 354:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Op($$[$0-1],\n      $$[$0]));\nbreak;\ncase 33: case 355:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Op($$[$0-3],\n      $$[$0-1]));\nbreak;\ncase 34:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Op($$[$0-2].concat($$[$0-1]),\n      $$[$0]));\nbreak;\ncase 35:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Block);\nbreak;\ncase 36: case 84: case 139:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])($$[$0-1]);\nbreak;\ncase 37:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.IdentifierLiteral($$[$0]));\nbreak;\ncase 38:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.CSXTag($$[$0]));\nbreak;\ncase 39:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.PropertyName($$[$0]));\nbreak;\ncase 40:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.NumberLiteral($$[$0]));\nbreak;\ncase 42:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.StringLiteral($$[$0]));\nbreak;\ncase 43:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.StringWithInterpolations($$[$0-1]));\nbreak;\ncase 44:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.RegexLiteral($$[$0]));\nbreak;\ncase 45:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.RegexWithInterpolations($$[$0-1].args));\nbreak;\ncase 47:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.PassthroughLiteral($$[$0]));\nbreak;\ncase 49:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.UndefinedLiteral($$[$0]));\nbreak;\ncase 50:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.NullLiteral($$[$0]));\nbreak;\ncase 51:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.BooleanLiteral($$[$0]));\nbreak;\ncase 52:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.InfinityLiteral($$[$0]));\nbreak;\ncase 53:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.NaNLiteral($$[$0]));\nbreak;\ncase 54:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Assign($$[$0-2],\n      $$[$0]));\nbreak;\ncase 55:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Assign($$[$0-3],\n      $$[$0]));\nbreak;\ncase 56:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Assign($$[$0-4],\n      $$[$0-1]));\nbreak;\ncase 57: case 116: case 121: case 122: case 124: case 125: case 126: case 127: case 129: case 285: case 286:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Value($$[$0]));\nbreak;\ncase 59:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Assign(yy.addDataToNode(yy, _$[$0-2])(new yy.Value($$[$0-2])),\n      $$[$0],\n      'object',\n      {\n          operatorToken: yy.addDataToNode(yy, _$[$0-1])(new yy.Literal($$[$0-1]))\n        }));\nbreak;\ncase 60:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Assign(yy.addDataToNode(yy, _$[$0-4])(new yy.Value($$[$0-4])),\n      $$[$0-1],\n      'object',\n      {\n          operatorToken: yy.addDataToNode(yy, _$[$0-3])(new yy.Literal($$[$0-3]))\n        }));\nbreak;\ncase 61:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Assign(yy.addDataToNode(yy, _$[$0-2])(new yy.Value($$[$0-2])),\n      $$[$0],\n      null,\n      {\n          operatorToken: yy.addDataToNode(yy, _$[$0-1])(new yy.Literal($$[$0-1]))\n        }));\nbreak;\ncase 62:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Assign(yy.addDataToNode(yy, _$[$0-4])(new yy.Value($$[$0-4])),\n      $$[$0-1],\n      null,\n      {\n          operatorToken: yy.addDataToNode(yy, _$[$0-3])(new yy.Literal($$[$0-3]))\n        }));\nbreak;\ncase 67:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Value(new yy.ComputedPropertyName($$[$0-1])));\nbreak;\ncase 69:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Splat(new yy.Value($$[$0-1])));\nbreak;\ncase 70:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Splat(new yy.Value($$[$0])));\nbreak;\ncase 71: case 114:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Splat($$[$0-1]));\nbreak;\ncase 72: case 115:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Splat($$[$0]));\nbreak;\ncase 78:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.SuperCall(yy.addDataToNode(yy, _$[$0-1])(new yy.Super),\n      $$[$0],\n      false,\n      $$[$0-1]));\nbreak;\ncase 79:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Call(new yy.Value($$[$0-1]),\n      $$[$0]));\nbreak;\ncase 80:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Call($$[$0-1],\n      $$[$0]));\nbreak;\ncase 81: case 82:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])((new yy.Value($$[$0-1])).add($$[$0]));\nbreak;\ncase 83: case 132:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Access($$[$0]));\nbreak;\ncase 85:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Return($$[$0]));\nbreak;\ncase 86:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Return(new yy.Value($$[$0-1])));\nbreak;\ncase 87:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Return);\nbreak;\ncase 88:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.YieldReturn($$[$0]));\nbreak;\ncase 89:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.YieldReturn);\nbreak;\ncase 90:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.AwaitReturn($$[$0]));\nbreak;\ncase 91:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.AwaitReturn);\nbreak;\ncase 92:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Code($$[$0-3],\n      $$[$0],\n      $$[$0-1],\n      yy.addDataToNode(yy, _$[$0-4])(new yy.Literal($$[$0-4]))));\nbreak;\ncase 93:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Code([],\n      $$[$0],\n      $$[$0-1]));\nbreak;\ncase 94:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Code($$[$0-3],\n      yy.addDataToNode(yy, _$[$0])(yy.Block.wrap([$$[$0]])),\n      $$[$0-1],\n      yy.addDataToNode(yy, _$[$0-4])(new yy.Literal($$[$0-4]))));\nbreak;\ncase 95:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Code([],\n      yy.addDataToNode(yy, _$[$0])(yy.Block.wrap([$$[$0]])),\n      $$[$0-1]));\nbreak;\ncase 96: case 97:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.FuncGlyph($$[$0]));\nbreak;\ncase 100: case 144: case 234:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])([]);\nbreak;\ncase 101: case 145: case 164: case 185: case 218: case 232: case 236: case 287:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])([$$[$0]]);\nbreak;\ncase 102: case 146: case 165: case 186: case 219: case 228:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])($$[$0-2].concat($$[$0]));\nbreak;\ncase 103: case 147: case 166: case 187: case 220:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])($$[$0-3].concat($$[$0]));\nbreak;\ncase 104: case 148: case 168: case 189: case 222:\nthis.$ = yy.addDataToNode(yy, _$[$0-5], _$[$0])($$[$0-5].concat($$[$0-2]));\nbreak;\ncase 105:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Param($$[$0]));\nbreak;\ncase 106:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Param($$[$0-1],\n      null,\n      true));\nbreak;\ncase 107:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Param($$[$0],\n      null,\n      true));\nbreak;\ncase 108:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Param($$[$0-2],\n      $$[$0]));\nbreak;\ncase 109: case 226:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Expansion);\nbreak;\ncase 117:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])($$[$0-1].add($$[$0]));\nbreak;\ncase 118:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Value($$[$0-1]).add($$[$0]));\nbreak;\ncase 130:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Super(yy.addDataToNode(yy, _$[$0])(new yy.Access($$[$0])),\n      [],\n      false,\n      $$[$0-2]));\nbreak;\ncase 131:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Super(yy.addDataToNode(yy, _$[$0-1])(new yy.Index($$[$0-1])),\n      [],\n      false,\n      $$[$0-3]));\nbreak;\ncase 133:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Access($$[$0],\n      'soak'));\nbreak;\ncase 134:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])([yy.addDataToNode(yy, _$[$0-1])(new yy.Access(new yy.PropertyName('prototype'))),\n      yy.addDataToNode(yy, _$[$0])(new yy.Access($$[$0]))]);\nbreak;\ncase 135:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])([yy.addDataToNode(yy, _$[$0-1])(new yy.Access(new yy.PropertyName('prototype'),\n      'soak')),\n      yy.addDataToNode(yy, _$[$0])(new yy.Access($$[$0]))]);\nbreak;\ncase 136:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Access(new yy.PropertyName('prototype')));\nbreak;\ncase 137:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Access(new yy.PropertyName('prototype'),\n      'soak'));\nbreak;\ncase 140:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(yy.extend($$[$0],\n      {\n          soak: true\n        }));\nbreak;\ncase 141:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Index($$[$0]));\nbreak;\ncase 142:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Slice($$[$0]));\nbreak;\ncase 143:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Obj($$[$0-2],\n      $$[$0-3].generated));\nbreak;\ncase 149:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Class);\nbreak;\ncase 150:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Class(null,\n      null,\n      $$[$0]));\nbreak;\ncase 151:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Class(null,\n      $$[$0]));\nbreak;\ncase 152:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Class(null,\n      $$[$0-1],\n      $$[$0]));\nbreak;\ncase 153:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Class($$[$0]));\nbreak;\ncase 154:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Class($$[$0-1],\n      null,\n      $$[$0]));\nbreak;\ncase 155:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Class($$[$0-2],\n      $$[$0]));\nbreak;\ncase 156:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Class($$[$0-3],\n      $$[$0-1],\n      $$[$0]));\nbreak;\ncase 157:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.ImportDeclaration(null,\n      $$[$0]));\nbreak;\ncase 158:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause($$[$0-2],\n      null),\n      $$[$0]));\nbreak;\ncase 159:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause(null,\n      $$[$0-2]),\n      $$[$0]));\nbreak;\ncase 160:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause(null,\n      new yy.ImportSpecifierList([])),\n      $$[$0]));\nbreak;\ncase 161:\nthis.$ = yy.addDataToNode(yy, _$[$0-6], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause(null,\n      new yy.ImportSpecifierList($$[$0-4])),\n      $$[$0]));\nbreak;\ncase 162:\nthis.$ = yy.addDataToNode(yy, _$[$0-5], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause($$[$0-4],\n      $$[$0-2]),\n      $$[$0]));\nbreak;\ncase 163:\nthis.$ = yy.addDataToNode(yy, _$[$0-8], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause($$[$0-7],\n      new yy.ImportSpecifierList($$[$0-4])),\n      $$[$0]));\nbreak;\ncase 167: case 188: case 201: case 221:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])($$[$0-2]);\nbreak;\ncase 169:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.ImportSpecifier($$[$0]));\nbreak;\ncase 170:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ImportSpecifier($$[$0-2],\n      $$[$0]));\nbreak;\ncase 171:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.ImportSpecifier(new yy.Literal($$[$0])));\nbreak;\ncase 172:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ImportSpecifier(new yy.Literal($$[$0-2]),\n      $$[$0]));\nbreak;\ncase 173:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.ImportDefaultSpecifier($$[$0]));\nbreak;\ncase 174:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ImportNamespaceSpecifier(new yy.Literal($$[$0-2]),\n      $$[$0]));\nbreak;\ncase 175:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList([])));\nbreak;\ncase 176:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($$[$0-2])));\nbreak;\ncase 177:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.ExportNamedDeclaration($$[$0]));\nbreak;\ncase 178:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.ExportNamedDeclaration(new yy.Assign($$[$0-2],\n      $$[$0],\n      null,\n      {\n          moduleDeclaration: 'export'\n        })));\nbreak;\ncase 179:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.ExportNamedDeclaration(new yy.Assign($$[$0-3],\n      $$[$0],\n      null,\n      {\n          moduleDeclaration: 'export'\n        })));\nbreak;\ncase 180:\nthis.$ = yy.addDataToNode(yy, _$[$0-5], _$[$0])(new yy.ExportNamedDeclaration(new yy.Assign($$[$0-4],\n      $$[$0-1],\n      null,\n      {\n          moduleDeclaration: 'export'\n        })));\nbreak;\ncase 181:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ExportDefaultDeclaration($$[$0]));\nbreak;\ncase 182:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.ExportDefaultDeclaration(new yy.Value($$[$0-1])));\nbreak;\ncase 183:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.ExportAllDeclaration(new yy.Literal($$[$0-2]),\n      $$[$0]));\nbreak;\ncase 184:\nthis.$ = yy.addDataToNode(yy, _$[$0-6], _$[$0])(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($$[$0-4]),\n      $$[$0]));\nbreak;\ncase 190:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.ExportSpecifier($$[$0]));\nbreak;\ncase 191:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ExportSpecifier($$[$0-2],\n      $$[$0]));\nbreak;\ncase 192:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ExportSpecifier($$[$0-2],\n      new yy.Literal($$[$0])));\nbreak;\ncase 193:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.ExportSpecifier(new yy.Literal($$[$0])));\nbreak;\ncase 194:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.ExportSpecifier(new yy.Literal($$[$0-2]),\n      $$[$0]));\nbreak;\ncase 195:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.TaggedTemplateCall($$[$0-2],\n      $$[$0],\n      $$[$0-1]));\nbreak;\ncase 196:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Call($$[$0-2],\n      $$[$0],\n      $$[$0-1]));\nbreak;\ncase 197:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.SuperCall(yy.addDataToNode(yy, _$[$0-2])(new yy.Super),\n      $$[$0],\n      $$[$0-1],\n      $$[$0-2]));\nbreak;\ncase 198:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(false);\nbreak;\ncase 199:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(true);\nbreak;\ncase 200:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])([]);\nbreak;\ncase 202: case 203:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Value(new yy.ThisLiteral($$[$0])));\nbreak;\ncase 204:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Value(yy.addDataToNode(yy, _$[$0-1])(new yy.ThisLiteral($$[$0-1])),\n      [yy.addDataToNode(yy, _$[$0])(new yy.Access($$[$0]))],\n      'this'));\nbreak;\ncase 205:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Arr([]));\nbreak;\ncase 206:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Arr($$[$0-1]));\nbreak;\ncase 207:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Arr([].concat($$[$0-2],\n      $$[$0-1])));\nbreak;\ncase 208:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])('inclusive');\nbreak;\ncase 209:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])('exclusive');\nbreak;\ncase 210: case 211:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Range($$[$0-3],\n      $$[$0-1],\n      $$[$0-2]));\nbreak;\ncase 212: case 214:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Range($$[$0-2],\n      $$[$0],\n      $$[$0-1]));\nbreak;\ncase 213: case 215:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Range($$[$0-1],\n      null,\n      $$[$0]));\nbreak;\ncase 216:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Range(null,\n      $$[$0],\n      $$[$0-1]));\nbreak;\ncase 217:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Range(null,\n      null,\n      $$[$0]));\nbreak;\ncase 229:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])($$[$0-3].concat($$[$0-2],\n      $$[$0]));\nbreak;\ncase 230:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])($$[$0-2].concat($$[$0-1]));\nbreak;\ncase 231:\nthis.$ = yy.addDataToNode(yy, _$[$0-5], _$[$0])($$[$0-5].concat($$[$0-4],\n      $$[$0-2],\n      $$[$0-1]));\nbreak;\ncase 233: case 237: case 334:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])($$[$0-1].concat($$[$0]));\nbreak;\ncase 235:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])([].concat($$[$0]));\nbreak;\ncase 238:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])(new yy.Elision);\nbreak;\ncase 241: case 242:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])([].concat($$[$0-2],\n      $$[$0]));\nbreak;\ncase 243:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Try($$[$0]));\nbreak;\ncase 244:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Try($$[$0-1],\n      $$[$0][0],\n      $$[$0][1]));\nbreak;\ncase 245:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Try($$[$0-2],\n      null,\n      null,\n      $$[$0]));\nbreak;\ncase 246:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Try($$[$0-3],\n      $$[$0-2][0],\n      $$[$0-2][1],\n      $$[$0]));\nbreak;\ncase 247:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])([$$[$0-1],\n      $$[$0]]);\nbreak;\ncase 248:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])([yy.addDataToNode(yy, _$[$0-1])(new yy.Value($$[$0-1])),\n      $$[$0]]);\nbreak;\ncase 249:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])([null,\n      $$[$0]]);\nbreak;\ncase 250:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Throw($$[$0]));\nbreak;\ncase 251:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Throw(new yy.Value($$[$0-1])));\nbreak;\ncase 252:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Parens($$[$0-1]));\nbreak;\ncase 253:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Parens($$[$0-2]));\nbreak;\ncase 254: case 258:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.While($$[$0]));\nbreak;\ncase 255: case 259: case 260:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.While($$[$0-2],\n      {\n          guard: $$[$0]\n        }));\nbreak;\ncase 256: case 261:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.While($$[$0],\n      {\n          invert: true\n        }));\nbreak;\ncase 257: case 262: case 263:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.While($$[$0-2],\n      {\n          invert: true,\n          guard: $$[$0]\n        }));\nbreak;\ncase 264: case 265: case 273: case 274:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])($$[$0-1].addBody($$[$0]));\nbreak;\ncase 266: case 267:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])($$[$0].addBody(yy.addDataToNode(yy, _$[$0-1])(yy.Block.wrap([$$[$0-1]]))));\nbreak;\ncase 268:\nthis.$ = yy.addDataToNode(yy, _$[$0], _$[$0])($$[$0]);\nbreak;\ncase 269:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.While(yy.addDataToNode(yy, _$[$0-1])(new yy.BooleanLiteral('true'))).addBody($$[$0]));\nbreak;\ncase 270:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.While(yy.addDataToNode(yy, _$[$0-1])(new yy.BooleanLiteral('true'))).addBody(yy.addDataToNode(yy, _$[$0])(yy.Block.wrap([$$[$0]]))));\nbreak;\ncase 271: case 272:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])($$[$0].addBody($$[$0-1]));\nbreak;\ncase 275:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.For([],\n      {\n          source: yy.addDataToNode(yy, _$[$0])(new yy.Value($$[$0]))\n        }));\nbreak;\ncase 276: case 278:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.For([],\n      {\n          source: yy.addDataToNode(yy, _$[$0-2])(new yy.Value($$[$0-2])),\n          step: $$[$0]\n        }));\nbreak;\ncase 277: case 279:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])($$[$0-1].addSource($$[$0]));\nbreak;\ncase 280:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.For([],\n      {\n          name: $$[$0][0],\n          index: $$[$0][1]\n        }));\nbreak;\ncase 281:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])((function() {\n        var index,\n      name;\n        [name,\n      index] = $$[$0];\n        return new yy.For([],\n      {\n          name,\n          index,\n          await: true,\n          awaitTag: yy.addDataToNode(yy, _$[$0-1])(new yy.Literal($$[$0-1]))\n        });\n      }()));\nbreak;\ncase 282:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])((function() {\n        var index,\n      name;\n        [name,\n      index] = $$[$0];\n        return new yy.For([],\n      {\n          name,\n          index,\n          own: true,\n          ownTag: yy.addDataToNode(yy, _$[$0-1])(new yy.Literal($$[$0-1]))\n        });\n      }()));\nbreak;\ncase 288:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])([$$[$0-2],\n      $$[$0]]);\nbreak;\ncase 289: case 308:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])({\n          source: $$[$0]\n        });\nbreak;\ncase 290: case 309:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])({\n          source: $$[$0],\n          object: true\n        });\nbreak;\ncase 291: case 292: case 310: case 311:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])({\n          source: $$[$0-2],\n          guard: $$[$0]\n        });\nbreak;\ncase 293: case 294: case 312: case 313:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])({\n          source: $$[$0-2],\n          guard: $$[$0],\n          object: true\n        });\nbreak;\ncase 295: case 296: case 314: case 315:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])({\n          source: $$[$0-2],\n          step: $$[$0]\n        });\nbreak;\ncase 297: case 298: case 299: case 300: case 316: case 317: case 318: case 319:\nthis.$ = yy.addDataToNode(yy, _$[$0-5], _$[$0])({\n          source: $$[$0-4],\n          guard: $$[$0-2],\n          step: $$[$0]\n        });\nbreak;\ncase 301: case 302: case 303: case 304: case 320: case 321: case 322: case 323:\nthis.$ = yy.addDataToNode(yy, _$[$0-5], _$[$0])({\n          source: $$[$0-4],\n          step: $$[$0-2],\n          guard: $$[$0]\n        });\nbreak;\ncase 305: case 324:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])({\n          source: $$[$0],\n          from: true\n        });\nbreak;\ncase 306: case 307: case 325: case 326:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])({\n          source: $$[$0-2],\n          guard: $$[$0],\n          from: true\n        });\nbreak;\ncase 327: case 328:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Switch($$[$0-3],\n      $$[$0-1]));\nbreak;\ncase 329: case 330:\nthis.$ = yy.addDataToNode(yy, _$[$0-6], _$[$0])(new yy.Switch($$[$0-5],\n      $$[$0-3],\n      $$[$0-1]));\nbreak;\ncase 331:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Switch(null,\n      $$[$0-1]));\nbreak;\ncase 332:\nthis.$ = yy.addDataToNode(yy, _$[$0-5], _$[$0])(new yy.Switch(null,\n      $$[$0-3],\n      $$[$0-1]));\nbreak;\ncase 335:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])([[$$[$0-1],\n      $$[$0]]]);\nbreak;\ncase 336:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])([[$$[$0-2],\n      $$[$0-1]]]);\nbreak;\ncase 337: case 343:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.If($$[$0-1],\n      $$[$0],\n      {\n          type: $$[$0-2]\n        }));\nbreak;\ncase 338: case 344:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])($$[$0-4].addElse(yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.If($$[$0-1],\n      $$[$0],\n      {\n          type: $$[$0-2]\n        }))));\nbreak;\ncase 340: case 346:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])($$[$0-2].addElse($$[$0]));\nbreak;\ncase 341: case 342: case 347: case 348:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.If($$[$0],\n      yy.addDataToNode(yy, _$[$0-2])(yy.Block.wrap([$$[$0-2]])),\n      {\n          type: $$[$0-1],\n          statement: true\n        }));\nbreak;\ncase 352:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Op('-',\n      $$[$0]));\nbreak;\ncase 353:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Op('+',\n      $$[$0]));\nbreak;\ncase 356:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Op('--',\n      $$[$0]));\nbreak;\ncase 357:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Op('++',\n      $$[$0]));\nbreak;\ncase 358:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Op('--',\n      $$[$0-1],\n      null,\n      true));\nbreak;\ncase 359:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Op('++',\n      $$[$0-1],\n      null,\n      true));\nbreak;\ncase 360:\nthis.$ = yy.addDataToNode(yy, _$[$0-1], _$[$0])(new yy.Existence($$[$0-1]));\nbreak;\ncase 361:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Op('+',\n      $$[$0-2],\n      $$[$0]));\nbreak;\ncase 362:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Op('-',\n      $$[$0-2],\n      $$[$0]));\nbreak;\ncase 363: case 364: case 365: case 366: case 367: case 368: case 369: case 370: case 371: case 372:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Op($$[$0-1],\n      $$[$0-2],\n      $$[$0]));\nbreak;\ncase 373:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])((function() {\n        if ($$[$0-1].charAt(0) === '!') {\n          return new yy.Op($$[$0-1].slice(1),\n      $$[$0-2],\n      $$[$0]).invert();\n        } else {\n          return new yy.Op($$[$0-1],\n      $$[$0-2],\n      $$[$0]);\n        }\n      }()));\nbreak;\ncase 374:\nthis.$ = yy.addDataToNode(yy, _$[$0-2], _$[$0])(new yy.Assign($$[$0-2],\n      $$[$0],\n      $$[$0-1]));\nbreak;\ncase 375:\nthis.$ = yy.addDataToNode(yy, _$[$0-4], _$[$0])(new yy.Assign($$[$0-4],\n      $$[$0-1],\n      $$[$0-3]));\nbreak;\ncase 376:\nthis.$ = yy.addDataToNode(yy, _$[$0-3], _$[$0])(new yy.Assign($$[$0-3],\n      $$[$0],\n      $$[$0-2]));\nbreak;\n}\n},\ntable: [{1:[2,1],3:1,4:2,5:3,7:4,8:5,9:6,10:7,11:27,12:28,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$V1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vi,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{1:[3]},{1:[2,2],6:$VH},o($VI,[2,3]),o($VJ,[2,6],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($VJ,[2,7]),o($VJ,[2,8],{158:116,151:118,154:119,148:$VK,150:$VL,156:$VM,174:$V01}),o($VJ,[2,9]),o($V11,[2,16],{124:120,99:121,104:127,46:$V21,47:$V21,126:$V21,80:$V31,81:$V41,101:$V51,102:$V61,103:$V71,105:$V81,125:$V91}),o($V11,[2,17],{104:127,99:130,80:$V31,81:$V41,101:$V51,102:$V61,103:$V71,105:$V81}),o($V11,[2,18]),o($V11,[2,19]),o($V11,[2,20]),o($V11,[2,21]),o($V11,[2,22]),o($V11,[2,23]),o($V11,[2,24]),o($V11,[2,25]),o($V11,[2,26]),o($V11,[2,27]),o($VJ,[2,28]),o($VJ,[2,29]),o($VJ,[2,30]),o($Va1,[2,12]),o($Va1,[2,13]),o($Va1,[2,14]),o($Va1,[2,15]),o($VJ,[2,10]),o($VJ,[2,11]),o($Vb1,$Vc1,{62:[1,131]}),o($Vb1,[2,124]),o($Vb1,[2,125]),o($Vb1,[2,126]),o($Vb1,$Vd1),o($Vb1,[2,128]),o($Vb1,[2,129]),o($Ve1,$Vf1,{87:132,94:133,95:134,38:136,68:137,96:138,34:139,39:$V2,40:$V3,69:$Vg1,71:$Vh1,107:$Vm,130:$Vi1}),{5:143,7:4,8:5,9:6,10:7,11:27,12:28,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$V1,33:$Vj1,34:62,37:142,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vi,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:145,8:146,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:150,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:156,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:157,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:158,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:$Vp1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:[1,160],85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{17:162,18:163,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:164,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:161,100:32,107:$Vm,129:$Vq,130:$Vr,145:$Vu},{17:162,18:163,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:164,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:165,100:32,107:$Vm,129:$Vq,130:$Vr,145:$Vu},o($Vq1,$Vr1,{180:[1,166],181:[1,167],194:[1,168]}),o($V11,[2,339],{169:[1,169]}),{33:$Vj1,37:170},{33:$Vj1,37:171},{33:$Vj1,37:172},o($V11,[2,268]),{33:$Vj1,37:173},{33:$Vj1,37:174},{7:175,8:176,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:[1,177],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vs1,[2,149],{54:30,74:31,100:32,52:33,76:34,75:35,96:61,34:62,43:63,49:65,38:78,68:79,45:88,89:152,17:162,18:163,61:164,37:178,98:180,33:$Vj1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,86:$Vm1,90:$Vk,91:$Vl,107:$Vm,111:[1,179],129:$Vq,130:$Vr,145:$Vu}),{7:181,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:[1,182],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o([1,6,35,48,70,71,93,127,135,146,148,149,150,156,157,174,182,183,184,185,186,187,188,189,190,191,192,193],$Vt1,{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,98:45,172:46,151:48,147:49,152:50,154:51,155:52,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,89:152,9:154,7:183,14:$V0,32:$Vk1,33:$Vu1,36:$Vv1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,84:[1,186],85:$Vl1,86:$Vm1,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,153:$Vx,167:$Vz,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),o($VJ,[2,345],{169:[1,187]}),o([1,6,35,48,70,71,93,127,135,146,148,149,150,156,157,174],$Vw1,{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,98:45,172:46,151:48,147:49,152:50,154:51,155:52,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,89:152,9:154,7:188,14:$V0,32:$Vk1,33:$Vx1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,153:$Vx,167:$Vz,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),{38:194,39:$V2,40:$V3,45:190,46:$V5,47:$V6,107:[1,193],113:191,114:192,119:$Vy1},{26:197,38:198,39:$V2,40:$V3,107:[1,196],110:$Vn,118:[1,199],122:[1,200]},o($Vq1,[2,121]),o($Vq1,[2,122]),o($Vb1,[2,46]),o($Vb1,[2,47]),o($Vb1,[2,48]),o($Vb1,[2,49]),o($Vb1,[2,50]),o($Vb1,[2,51]),o($Vb1,[2,52]),o($Vb1,[2,53]),{4:201,5:3,7:4,8:5,9:6,10:7,11:27,12:28,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$V1,33:[1,202],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vi,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:203,8:204,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:$Vz1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,70:$VA1,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,93:$VC1,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,131:206,132:207,136:212,137:209,138:208,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{80:$VD1,81:$VE1,124:215,125:$V91,126:$V21},o($Vb1,[2,202]),o($Vb1,[2,203],{41:218,42:$VF1}),o($VG1,[2,96]),o($VG1,[2,97]),o($VH1,[2,116]),o($VH1,[2,119]),{7:220,8:221,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:222,8:223,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:224,8:225,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:227,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:$Vj1,34:62,37:226,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{34:236,38:233,39:$V2,40:$V3,68:234,69:$Vf,85:$VI1,96:235,100:228,107:$Vm,130:$Vi1,161:229,162:$VJ1,163:232},{159:237,160:238,164:[1,239],165:[1,240],166:[1,241]},o([6,33,93,109],$VK1,{45:88,108:242,63:243,64:244,65:245,67:246,43:248,72:250,38:251,41:252,68:253,73:254,34:255,74:256,75:257,76:258,39:$V2,40:$V3,42:$VF1,44:$V4,46:$V5,47:$V6,69:$VL1,71:$VM1,77:$VN1,107:$Vm,129:$Vq,130:$Vr,145:$Vu}),o($VO1,[2,40]),o($VO1,[2,41]),o($Vb1,[2,44]),{17:162,18:163,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:260,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:164,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:261,100:32,107:$Vm,129:$Vq,130:$Vr,145:$Vu},o($VP1,[2,37]),o($VP1,[2,38]),o($VQ1,[2,42]),{4:262,5:3,7:4,8:5,9:6,10:7,11:27,12:28,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$V1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vi,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VI,[2,5],{7:4,8:5,9:6,10:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,13:23,15:25,16:26,11:27,12:28,61:29,54:30,74:31,100:32,52:33,76:34,75:35,89:37,98:45,172:46,151:48,147:49,152:50,154:51,155:52,175:57,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,5:263,14:$V0,32:$V1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,84:$Vh,85:$Vi,86:$Vj,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,148:$Vv,150:$Vw,153:$Vx,156:$Vy,167:$Vz,173:$VA,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),o($V11,[2,360]),{7:264,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:265,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:266,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:267,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:268,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:269,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:270,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:271,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:272,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:273,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:274,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:275,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:276,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:277,8:278,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V11,[2,267]),o($V11,[2,272]),{7:222,8:279,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:224,8:280,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{34:236,38:233,39:$V2,40:$V3,68:234,69:$Vf,85:$VI1,96:235,100:281,107:$Vm,130:$Vi1,161:229,162:$VJ1,163:232},{159:237,164:[1,282],165:[1,283],166:[1,284]},{7:285,8:286,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V11,[2,266]),o($V11,[2,271]),{45:287,46:$V5,47:$V6,78:288,126:$VR1},o($VH1,[2,117]),o($VS1,[2,199]),{41:290,42:$VF1},{41:291,42:$VF1},o($VH1,[2,136],{41:292,42:$VF1}),o($VH1,[2,137],{41:293,42:$VF1}),o($VH1,[2,138]),{7:295,8:297,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VT1,74:31,75:35,76:34,77:$Vg,82:294,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,106:296,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,134:298,135:$VU1,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{81:$V41,104:301,105:$V81},o($VH1,[2,118]),{6:[1,303],7:302,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:[1,304],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VV1,$VW1,{92:307,88:[1,305],93:$VX1}),o($VY1,[2,101]),o($VY1,[2,105],{62:[1,309],71:[1,308]}),o($VY1,[2,109],{38:136,68:137,96:138,34:139,95:310,39:$V2,40:$V3,69:$Vg1,107:$Vm,130:$Vi1}),o($VZ1,[2,110]),o($VZ1,[2,111]),o($VZ1,[2,112]),o($VZ1,[2,113]),{41:218,42:$VF1},{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:$Vz1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,70:$VA1,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,93:$VC1,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,131:206,132:207,136:212,137:209,138:208,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V_1,[2,93]),o($VJ,[2,95]),{4:314,5:3,7:4,8:5,9:6,10:7,11:27,12:28,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$V1,34:62,35:[1,313],38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vi,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V$1,$V02,{151:111,154:112,158:116,182:$VQ}),o($VJ,[2,349]),{7:158,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:$Vp1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{148:$VK,150:$VL,151:118,154:119,156:$VM,158:116,174:$V01},o([1,6,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,182,183,184,185,186,187,188,189,190,191,192,193],$Vt1,{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,98:45,172:46,151:48,147:49,152:50,154:51,155:52,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,89:152,9:154,7:183,14:$V0,32:$Vk1,33:$Vu1,36:$Vv1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,153:$Vx,167:$Vz,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),o($V12,[2,351],{151:111,154:112,158:116,182:$VQ,184:$VS}),o($Ve1,$Vf1,{94:133,95:134,38:136,68:137,96:138,34:139,87:316,39:$V2,40:$V3,69:$Vg1,71:$Vh1,107:$Vm,130:$Vi1}),{33:$Vj1,37:142},{7:317,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{148:$VK,150:$VL,151:118,154:119,156:$VM,158:116,174:[1,318]},{7:319,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V12,[2,352],{151:111,154:112,158:116,182:$VQ,184:$VS}),o($V12,[2,353],{151:111,154:112,158:116,182:$VQ,184:$VS}),o($V$1,[2,354],{151:111,154:112,158:116,182:$VQ}),{34:320,107:$Vm},o($VJ,[2,91],{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,98:45,172:46,151:48,147:49,152:50,154:51,155:52,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,89:152,9:154,7:321,14:$V0,32:$Vk1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,148:$Vw1,150:$Vw1,156:$Vw1,174:$Vw1,153:$Vx,167:$Vz,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),o($V11,[2,356],{46:$Vr1,47:$Vr1,80:$Vr1,81:$Vr1,101:$Vr1,102:$Vr1,103:$Vr1,105:$Vr1,125:$Vr1,126:$Vr1}),o($VS1,$V21,{124:120,99:121,104:127,80:$V31,81:$V41,101:$V51,102:$V61,103:$V71,105:$V81,125:$V91}),{80:$V31,81:$V41,99:130,101:$V51,102:$V61,103:$V71,104:127,105:$V81},o($V22,$Vc1),o($V11,[2,357],{46:$Vr1,47:$Vr1,80:$Vr1,81:$Vr1,101:$Vr1,102:$Vr1,103:$Vr1,105:$Vr1,125:$Vr1,126:$Vr1}),o($V11,[2,358]),o($V11,[2,359]),{6:[1,324],7:322,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:[1,323],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{33:$Vj1,37:325,173:[1,326]},o($V11,[2,243],{141:327,142:[1,328],143:[1,329]}),o($V11,[2,264]),o($V11,[2,265]),o($V11,[2,273]),o($V11,[2,274]),{33:[1,330],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[1,331]},{168:332,170:333,171:$V32},o($V11,[2,150]),{7:335,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vs1,[2,153],{37:336,33:$Vj1,46:$Vr1,47:$Vr1,80:$Vr1,81:$Vr1,101:$Vr1,102:$Vr1,103:$Vr1,105:$Vr1,125:$Vr1,126:$Vr1,111:[1,337]}),o($V42,[2,250],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{34:338,107:$Vm},o($V42,[2,32],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{34:339,107:$Vm},{7:340,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o([1,6,35,48,70,71,93,127,135,146,149,157],[2,89],{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,98:45,172:46,151:48,147:49,152:50,154:51,155:52,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,89:152,9:154,7:341,14:$V0,32:$Vk1,33:$Vx1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,148:$Vw1,150:$Vw1,156:$Vw1,174:$Vw1,153:$Vx,167:$Vz,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),{33:$Vj1,37:342,173:[1,343]},o($Va1,$V52,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{34:344,107:$Vm},o($Va1,[2,157]),{36:[1,345],93:[1,346]},{36:[1,347]},{33:$V62,38:352,39:$V2,40:$V3,109:[1,348],115:349,116:350,118:$V72},o([36,93],[2,173]),{117:[1,354]},{33:$V82,38:359,39:$V2,40:$V3,109:[1,355],118:$V92,121:356,123:357},o($Va1,[2,177]),{62:[1,361]},{7:362,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:[1,363],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{36:[1,364]},{6:$VH,146:[1,365]},{4:366,5:3,7:4,8:5,9:6,10:7,11:27,12:28,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$V1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vi,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Va2,$Vb2,{151:111,154:112,158:116,134:367,71:[1,368],135:$VU1,148:$VK,150:$VL,156:$VM,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($Va2,$Vc2,{134:369,71:$VT1,135:$VU1}),o($Vd2,[2,205]),{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,70:[1,370],71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,93:$VC1,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,136:372,138:371,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o([6,33,70],$VW1,{133:373,92:375,93:$Ve2}),o($Vf2,[2,236]),o($Vg2,[2,227]),{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:$Vz1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,93:$VC1,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,131:377,132:376,136:212,137:209,138:208,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vf2,[2,238]),o($Vg2,[2,232]),o($Vh2,[2,225]),o($Vh2,[2,226],{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,98:45,172:46,151:48,147:49,152:50,154:51,155:52,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,89:152,9:154,7:378,14:$V0,32:$Vk1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,148:$Vv,150:$Vw,153:$Vx,156:$Vy,167:$Vz,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),{78:379,126:$VR1},{41:380,42:$VF1},{7:381,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vi2,[2,204]),o($Vi2,[2,39]),{33:$Vj1,37:382,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:$Vj1,37:383},o($Vj2,[2,258],{151:111,154:112,158:116,148:$VK,149:[1,384],150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{33:[2,254],149:[1,385]},o($Vj2,[2,261],{151:111,154:112,158:116,148:$VK,149:[1,386],150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{33:[2,256],149:[1,387]},o($V11,[2,269]),o($Vk2,[2,270],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{33:$Vl2,157:[1,388]},o($Vm2,[2,280]),{34:236,38:233,39:$V2,40:$V3,68:234,69:$Vg1,96:235,107:$Vm,130:$Vi1,161:389,163:232},{34:236,38:233,39:$V2,40:$V3,68:234,69:$Vg1,96:235,107:$Vm,130:$Vi1,161:390,163:232},o($Vm2,[2,287],{93:[1,391]}),o($Vn2,[2,283]),o($Vn2,[2,284]),o($Vn2,[2,285]),o($Vn2,[2,286]),o($V11,[2,277]),{33:[2,279]},{7:392,8:393,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:394,8:395,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:396,8:397,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vo2,$VW1,{92:398,93:$Vp2}),o($Vq2,[2,145]),o($Vq2,[2,57],{66:[1,400]}),o($Vq2,[2,58]),o($Vr2,[2,66],{78:403,79:404,62:[1,401],71:[1,402],80:$Vs2,81:$Vt2,126:$VR1}),{7:407,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vr2,[2,68]),{34:255,38:251,39:$V2,40:$V3,41:252,42:$VF1,67:408,68:253,72:409,73:254,74:256,75:257,76:258,77:$VN1,107:$Vm,129:$Vq,130:$Vr,145:$Vu},{71:[1,410],78:411,79:412,80:$Vs2,81:$Vt2,126:$VR1},o($Vu2,[2,63]),o($Vu2,[2,64]),o($Vu2,[2,65]),o($Vv2,[2,73]),o($Vv2,[2,74]),o($Vv2,[2,75]),o($Vv2,[2,76]),o($Vv2,[2,77]),{78:413,80:$VD1,81:$VE1,126:$VR1},o($V22,$Vd1,{53:[1,414]}),o($V22,$Vr1),{6:$VH,48:[1,415]},o($VI,[2,4]),o($Vw2,[2,361],{151:111,154:112,158:116,182:$VQ,183:$VR,184:$VS}),o($Vw2,[2,362],{151:111,154:112,158:116,182:$VQ,183:$VR,184:$VS}),o($V12,[2,363],{151:111,154:112,158:116,182:$VQ,184:$VS}),o($V12,[2,364],{151:111,154:112,158:116,182:$VQ,184:$VS}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,185,186,187,188,189,190,191,192,193],[2,365],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,186,187,188,189,190,191,192],[2,366],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,193:$V$}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,187,188,189,190,191,192],[2,367],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,193:$V$}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,188,189,190,191,192],[2,368],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,193:$V$}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,189,190,191,192],[2,369],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,193:$V$}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,190,191,192],[2,370],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,193:$V$}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,191,192],[2,371],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,193:$V$}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,192],[2,372],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,193:$V$}),o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,157,174,186,187,188,189,190,191,192,193],[2,373],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT}),o($Vk2,$Vx2,{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($VJ,[2,348]),{149:[1,416]},{149:[1,417]},o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,149,150,156,174,178,179,182,183,184,185,186,187,188,189,190,191,192,193],$Vl2,{157:[1,418]}),{7:419,8:420,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:421,8:422,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:423,8:424,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vk2,$Vy2,{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($VJ,[2,347]),o($Vz2,[2,195]),o($Vz2,[2,196]),{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:$VA2,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,127:[1,425],128:426,129:$Vq,130:$Vr,136:427,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VH1,[2,132]),o($VH1,[2,133]),o($VH1,[2,134]),o($VH1,[2,135]),{83:[1,429]},{71:$VT1,83:[2,141],134:430,135:$VU1,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{83:[2,142]},{71:$VT1,134:431,135:$VU1},{7:432,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,83:[2,217],84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VB2,[2,208]),o($VB2,$VC2),o($VH1,[2,140]),o($V42,[2,54],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{7:433,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:434,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{89:435,90:$Vk,91:$Vl},o($VD2,$VE2,{95:134,38:136,68:137,96:138,34:139,94:436,39:$V2,40:$V3,69:$Vg1,71:$Vh1,107:$Vm,130:$Vi1}),{6:$VF2,33:$VG2},o($VY1,[2,106]),{7:439,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VY1,[2,107]),o($Vh2,$Vb2,{151:111,154:112,158:116,71:[1,440],148:$VK,150:$VL,156:$VM,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($Vh2,$Vc2),o($VH2,[2,35]),{6:$VH,35:[1,441]},{7:442,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VV1,$VW1,{92:307,88:[1,443],93:$VX1}),o($V$1,$V02,{151:111,154:112,158:116,182:$VQ}),{7:444,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{33:$Vj1,37:382,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{35:[1,445]},o($VJ,[2,90],{151:111,154:112,158:116,148:$V52,150:$V52,156:$V52,174:$V52,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,[2,374],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{7:446,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:447,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V11,[2,340]),{7:448,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V11,[2,244],{142:[1,449]}),{33:$Vj1,37:450},{33:$Vj1,34:452,37:453,38:451,39:$V2,40:$V3,107:$Vm},{168:454,170:333,171:$V32},{168:455,170:333,171:$V32},{35:[1,456],169:[1,457],170:458,171:$V32},o($VJ2,[2,333]),{7:460,8:461,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,139:459,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VK2,[2,151],{151:111,154:112,158:116,37:462,33:$Vj1,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V11,[2,154]),{7:463,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{35:[1,464]},{35:[1,465]},o($V42,[2,34],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($VJ,[2,88],{151:111,154:112,158:116,148:$V52,150:$V52,156:$V52,174:$V52,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($VJ,[2,346]),{7:467,8:466,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{35:[1,468]},{45:469,46:$V5,47:$V6},{107:[1,471],114:470,119:$Vy1},{45:472,46:$V5,47:$V6},{36:[1,473]},o($Vo2,$VW1,{92:474,93:$VL2}),o($Vq2,[2,164]),{33:$V62,38:352,39:$V2,40:$V3,115:476,116:350,118:$V72},o($Vq2,[2,169],{117:[1,477]}),o($Vq2,[2,171],{117:[1,478]}),{38:479,39:$V2,40:$V3},o($Va1,[2,175]),o($Vo2,$VW1,{92:480,93:$VM2}),o($Vq2,[2,185]),{33:$V82,38:359,39:$V2,40:$V3,118:$V92,121:482,123:357},o($Vq2,[2,190],{117:[1,483]}),o($Vq2,[2,193],{117:[1,484]}),{6:[1,486],7:485,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:[1,487],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VN2,[2,181],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{34:488,107:$Vm},{45:489,46:$V5,47:$V6},o($Vb1,[2,252]),{6:$VH,35:[1,490]},{7:491,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o([14,32,39,40,44,46,47,50,51,55,56,57,58,59,60,69,77,84,85,86,90,91,107,110,112,120,129,130,140,144,145,148,150,153,156,167,173,176,177,178,179,180,181],$VC2,{6:$VO2,33:$VO2,70:$VO2,93:$VO2}),{7:492,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vd2,[2,206]),o($Vf2,[2,237]),o($Vg2,[2,233]),{6:$VP2,33:$VQ2,70:[1,493]},o($VR2,$VE2,{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,89:37,98:45,172:46,151:48,147:49,152:50,154:51,155:52,175:57,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,9:148,138:208,136:212,97:213,7:311,8:312,137:496,131:497,14:$V0,32:$Vk1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,71:$VB1,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,90:$Vk,91:$Vl,93:$VC1,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,148:$Vv,150:$Vw,153:$Vx,156:$Vy,167:$Vz,173:$VA,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),o($VR2,[2,234]),o($VD2,$VW1,{92:375,133:498,93:$Ve2}),{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,93:$VC1,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,136:372,138:371,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vh2,[2,115],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($Vz2,[2,197]),o($Vb1,[2,130]),{83:[1,499],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($VS2,[2,337]),o($VT2,[2,343]),{7:500,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:501,8:502,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:503,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:504,8:505,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:506,8:507,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vm2,[2,281]),o($Vm2,[2,282]),{34:236,38:233,39:$V2,40:$V3,68:234,69:$Vg1,96:235,107:$Vm,130:$Vi1,163:508},{33:$VU2,148:$VK,149:[1,509],150:$VL,151:111,154:112,156:$VM,157:[1,510],158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,308],149:[1,511],157:[1,512]},{33:$VV2,148:$VK,149:[1,513],150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,309],149:[1,514]},{33:$VW2,148:$VK,149:[1,515],150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,324],149:[1,516]},{6:$VX2,33:$VY2,109:[1,517]},o($VZ2,$VE2,{45:88,64:244,65:245,67:246,43:248,72:250,38:251,41:252,68:253,73:254,34:255,74:256,75:257,76:258,63:520,39:$V2,40:$V3,42:$VF1,44:$V4,46:$V5,47:$V6,69:$VL1,71:$VM1,77:$VN1,107:$Vm,129:$Vq,130:$Vr,145:$Vu}),{7:521,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:[1,522],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:523,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,33:[1,524],34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vq2,[2,69]),o($Vv2,[2,79]),o($Vv2,[2,81]),{41:525,42:$VF1},{7:295,8:297,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VT1,74:31,75:35,76:34,77:$Vg,82:526,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,106:296,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,134:298,135:$VU1,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{70:[1,527],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($Vq2,[2,70],{78:403,79:404,80:$Vs2,81:$Vt2,126:$VR1}),o($Vq2,[2,72],{78:411,79:412,80:$Vs2,81:$Vt2,126:$VR1}),o($Vq2,[2,71]),o($Vv2,[2,80]),o($Vv2,[2,82]),o($Vv2,[2,78]),o($Vb1,[2,45]),o($VQ1,[2,43]),{7:528,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:529,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:530,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o([1,6,33,35,48,70,71,83,88,93,109,127,135,146,148,150,156,174],$VU2,{151:111,154:112,158:116,149:[1,531],157:[1,532],178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{149:[1,533],157:[1,534]},o($V_2,$VV2,{151:111,154:112,158:116,149:[1,535],178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{149:[1,536]},o($V_2,$VW2,{151:111,154:112,158:116,149:[1,537],178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{149:[1,538]},o($Vz2,[2,200]),o([6,33,127],$VW1,{92:539,93:$V$2}),o($V03,[2,218]),{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:$VA2,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,128:541,129:$Vq,130:$Vr,136:427,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VH1,[2,139]),{7:542,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,83:[2,213],84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:543,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,83:[2,215],84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{83:[2,216],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($V42,[2,55],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{35:[1,544],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{5:546,7:4,8:5,9:6,10:7,11:27,12:28,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$V1,33:$Vj1,34:62,37:545,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vi,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($VY1,[2,102]),{34:139,38:136,39:$V2,40:$V3,68:137,69:$Vg1,71:$Vh1,94:547,95:134,96:138,107:$Vm,130:$Vi1},o($V13,$Vf1,{94:133,95:134,38:136,68:137,96:138,34:139,87:548,39:$V2,40:$V3,69:$Vg1,71:$Vh1,107:$Vm,130:$Vi1}),o($VY1,[2,108],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($Vh2,$VO2),o($VH2,[2,36]),o($Vk2,$Vx2,{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{89:549,90:$Vk,91:$Vl},o($Vk2,$Vy2,{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V11,[2,355]),{35:[1,550],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($V42,[2,376],{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{33:$Vj1,37:551,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:$Vj1,37:552},o($V11,[2,245]),{33:$Vj1,37:553},{33:$Vj1,37:554},o($V23,[2,249]),{35:[1,555],169:[1,556],170:458,171:$V32},{35:[1,557],169:[1,558],170:458,171:$V32},o($V11,[2,331]),{33:$Vj1,37:559},o($VJ2,[2,334]),{33:$Vj1,37:560,93:[1,561]},o($V33,[2,239],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V33,[2,240]),o($V11,[2,152]),o($VK2,[2,155],{151:111,154:112,158:116,37:562,33:$Vj1,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V11,[2,251]),o($V11,[2,33]),{33:$Vj1,37:563},{148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($Va1,[2,86]),o($Va1,[2,158]),{36:[1,564]},{33:$V62,38:352,39:$V2,40:$V3,115:565,116:350,118:$V72},o($Va1,[2,159]),{45:566,46:$V5,47:$V6},{6:$V43,33:$V53,109:[1,567]},o($VZ2,$VE2,{38:352,116:570,39:$V2,40:$V3,118:$V72}),o($VD2,$VW1,{92:571,93:$VL2}),{38:572,39:$V2,40:$V3},{38:573,39:$V2,40:$V3},{36:[2,174]},{6:$V63,33:$V73,109:[1,574]},o($VZ2,$VE2,{38:359,123:577,39:$V2,40:$V3,118:$V92}),o($VD2,$VW1,{92:578,93:$VM2}),{38:579,39:$V2,40:$V3,118:[1,580]},{38:581,39:$V2,40:$V3},o($VN2,[2,178],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{7:582,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:583,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{35:[1,584]},o($Va1,[2,183]),{146:[1,585]},{70:[1,586],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{70:[1,587],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($Vd2,[2,207]),{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,93:$VC1,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,131:377,136:212,137:588,138:208,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:$Vz1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,93:$VC1,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,131:377,132:589,136:212,137:209,138:208,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vg2,[2,228]),o($VR2,[2,235],{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,89:37,98:45,172:46,151:48,147:49,152:50,154:51,155:52,175:57,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,9:148,97:213,7:311,8:312,138:371,136:372,14:$V0,32:$Vk1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,71:$VB1,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,90:$Vk,91:$Vl,93:$VC1,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,148:$Vv,150:$Vw,153:$Vx,156:$Vy,167:$Vz,173:$VA,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),{6:$VP2,33:$VQ2,35:[1,590]},o($Vb1,[2,131]),o($Vk2,[2,259],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{33:$V83,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,255]},o($Vk2,[2,262],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{33:$V93,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,257]},{33:$Va3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,278]},o($Vm2,[2,288]),{7:591,8:592,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:593,8:594,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:595,8:596,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:597,8:598,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:599,8:600,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:601,8:602,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:603,8:604,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:605,8:606,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vd2,[2,143]),{34:255,38:251,39:$V2,40:$V3,41:252,42:$VF1,43:248,44:$V4,45:88,46:$V5,47:$V6,63:607,64:244,65:245,67:246,68:253,69:$VL1,71:$VM1,72:250,73:254,74:256,75:257,76:258,77:$VN1,107:$Vm,129:$Vq,130:$Vr,145:$Vu},o($V13,$VK1,{45:88,63:243,64:244,65:245,67:246,43:248,72:250,38:251,41:252,68:253,73:254,34:255,74:256,75:257,76:258,108:608,39:$V2,40:$V3,42:$VF1,44:$V4,46:$V5,47:$V6,69:$VL1,71:$VM1,77:$VN1,107:$Vm,129:$Vq,130:$Vr,145:$Vu}),o($Vq2,[2,146]),o($Vq2,[2,59],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{7:609,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vq2,[2,61],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{7:610,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($Vv2,[2,83]),{83:[1,611]},o($Vr2,[2,67]),o($Vk2,$V83,{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($Vk2,$V93,{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($Vk2,$Va3,{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{7:612,8:613,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:614,8:615,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:616,8:617,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:618,8:619,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:620,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:621,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:622,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:623,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{6:$Vb3,33:$Vc3,127:[1,624]},o([6,33,35,127],$VE2,{17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,13:23,15:25,16:26,61:29,54:30,74:31,100:32,52:33,76:34,75:35,89:37,98:45,172:46,151:48,147:49,152:50,154:51,155:52,175:57,96:61,34:62,43:63,49:65,38:78,68:79,158:85,45:88,9:148,97:213,7:311,8:312,136:627,14:$V0,32:$Vk1,39:$V2,40:$V3,44:$V4,46:$V5,47:$V6,50:$V7,51:$V8,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,69:$Vf,71:$VB1,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,90:$Vk,91:$Vl,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,148:$Vv,150:$Vw,153:$Vx,156:$Vy,167:$Vz,173:$VA,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG}),o($VD2,$VW1,{92:628,93:$V$2}),{83:[2,212],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{83:[2,214],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($V11,[2,56]),o($V_1,[2,92]),o($VJ,[2,94]),o($VY1,[2,103]),o($VD2,$VW1,{92:629,93:$VX1}),{33:$Vj1,37:545},o($V11,[2,375]),o($VS2,[2,338]),o($V11,[2,246]),o($V23,[2,247]),o($V23,[2,248]),o($V11,[2,327]),{33:$Vj1,37:630},o($V11,[2,328]),{33:$Vj1,37:631},{35:[1,632]},o($VJ2,[2,335],{6:[1,633]}),{7:634,8:635,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V11,[2,156]),o($VT2,[2,344]),{45:636,46:$V5,47:$V6},o($Vo2,$VW1,{92:637,93:$VL2}),o($Va1,[2,160]),{36:[1,638]},{38:352,39:$V2,40:$V3,116:639,118:$V72},{33:$V62,38:352,39:$V2,40:$V3,115:640,116:350,118:$V72},o($Vq2,[2,165]),{6:$V43,33:$V53,35:[1,641]},o($Vq2,[2,170]),o($Vq2,[2,172]),o($Va1,[2,176],{36:[1,642]}),{38:359,39:$V2,40:$V3,118:$V92,123:643},{33:$V82,38:359,39:$V2,40:$V3,118:$V92,121:644,123:357},o($Vq2,[2,186]),{6:$V63,33:$V73,35:[1,645]},o($Vq2,[2,191]),o($Vq2,[2,192]),o($Vq2,[2,194]),o($VN2,[2,179],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{35:[1,646],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($Va1,[2,182]),o($Vb1,[2,253]),o($Vb1,[2,210]),o($Vb1,[2,211]),o($Vg2,[2,229]),o($VD2,$VW1,{92:375,133:647,93:$Ve2}),o($Vg2,[2,230]),{33:$Vd3,148:$VK,150:$VL,151:111,154:112,156:$VM,157:[1,648],158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,310],157:[1,649]},{33:$Ve3,148:$VK,149:[1,650],150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,314],149:[1,651]},{33:$Vf3,148:$VK,150:$VL,151:111,154:112,156:$VM,157:[1,652],158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,311],157:[1,653]},{33:$Vg3,148:$VK,149:[1,654],150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,315],149:[1,655]},{33:$Vh3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,312]},{33:$Vi3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,313]},{33:$Vj3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,325]},{33:$Vk3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,326]},o($Vq2,[2,147]),o($VD2,$VW1,{92:656,93:$Vp2}),{35:[1,657],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{35:[1,658],148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VI2,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},o($Vv2,[2,84]),o($Vl3,$Vd3,{151:111,154:112,158:116,157:[1,659],178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{157:[1,660]},o($V_2,$Ve3,{151:111,154:112,158:116,149:[1,661],178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{149:[1,662]},o($Vl3,$Vf3,{151:111,154:112,158:116,157:[1,663],178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{157:[1,664]},o($V_2,$Vg3,{151:111,154:112,158:116,149:[1,665],178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{149:[1,666]},o($V42,$Vh3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vi3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vj3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vk3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($Vz2,[2,201]),{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,136:667,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:311,8:312,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,33:$VA2,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,71:$VB1,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,97:213,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,128:668,129:$Vq,130:$Vr,136:427,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V03,[2,219]),{6:$Vb3,33:$Vc3,35:[1,669]},{6:$VF2,33:$VG2,35:[1,670]},{35:[1,671]},{35:[1,672]},o($V11,[2,332]),o($VJ2,[2,336]),o($V33,[2,241],{151:111,154:112,158:116,148:$VK,150:$VL,156:$VM,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V33,[2,242]),o($Va1,[2,162]),{6:$V43,33:$V53,109:[1,673]},{45:674,46:$V5,47:$V6},o($Vq2,[2,166]),o($VD2,$VW1,{92:675,93:$VL2}),o($Vq2,[2,167]),{45:676,46:$V5,47:$V6},o($Vq2,[2,187]),o($VD2,$VW1,{92:677,93:$VM2}),o($Vq2,[2,188]),o($Va1,[2,180]),{6:$VP2,33:$VQ2,35:[1,678]},{7:679,8:680,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:681,8:682,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:683,8:684,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:685,8:686,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:687,8:688,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:689,8:690,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:691,8:692,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:693,8:694,9:148,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,29:20,30:21,31:22,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vj,89:37,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$VA,175:57,176:$VB,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{6:$VX2,33:$VY2,35:[1,695]},o($Vq2,[2,60]),o($Vq2,[2,62]),{7:696,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:697,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:698,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:699,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:700,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:701,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:702,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},{7:703,9:154,13:23,14:$V0,15:25,16:26,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:19,32:$Vk1,34:62,38:78,39:$V2,40:$V3,43:63,44:$V4,45:88,46:$V5,47:$V6,49:65,50:$V7,51:$V8,52:33,54:30,55:$V9,56:$Va,57:$Vb,58:$Vc,59:$Vd,60:$Ve,61:29,68:79,69:$Vf,74:31,75:35,76:34,77:$Vg,84:$Vh,85:$Vl1,86:$Vm1,89:152,90:$Vk,91:$Vl,96:61,98:45,100:32,107:$Vm,110:$Vn,112:$Vo,120:$Vp,129:$Vq,130:$Vr,140:$Vs,144:$Vt,145:$Vu,147:49,148:$Vv,150:$Vw,151:48,152:50,153:$Vx,154:51,155:52,156:$Vy,158:85,167:$Vz,172:46,173:$Vn1,176:$Vo1,177:$VC,178:$VD,179:$VE,180:$VF,181:$VG},o($V03,[2,220]),o($VD2,$VW1,{92:704,93:$V$2}),o($V03,[2,221]),o($VY1,[2,104]),o($V11,[2,329]),o($V11,[2,330]),{36:[1,705]},o($Va1,[2,161]),{6:$V43,33:$V53,35:[1,706]},o($Va1,[2,184]),{6:$V63,33:$V73,35:[1,707]},o($Vg2,[2,231]),{33:$Vm3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,316]},{33:$Vn3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,318]},{33:$Vo3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,320]},{33:$Vp3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,322]},{33:$Vq3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,317]},{33:$Vr3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,319]},{33:$Vs3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,321]},{33:$Vt3,148:$VK,150:$VL,151:111,154:112,156:$VM,158:116,174:$VN,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$},{33:[2,323]},o($Vq2,[2,148]),o($V42,$Vm3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vn3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vo3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vp3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vq3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vr3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vs3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),o($V42,$Vt3,{151:111,154:112,158:116,178:$VO,179:$VP,182:$VQ,183:$VR,184:$VS,185:$VT,186:$VU,187:$VV,188:$VW,189:$VX,190:$VY,191:$VZ,192:$V_,193:$V$}),{6:$Vb3,33:$Vc3,35:[1,708]},{45:709,46:$V5,47:$V6},o($Vq2,[2,168]),o($Vq2,[2,189]),o($V03,[2,222]),o($Va1,[2,163])],\ndefaultActions: {238:[2,279],296:[2,142],479:[2,174],502:[2,255],505:[2,257],507:[2,278],600:[2,312],602:[2,313],604:[2,325],606:[2,326],680:[2,316],682:[2,318],684:[2,320],686:[2,322],688:[2,317],690:[2,319],692:[2,321],694:[2,323]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\nexports.main = function() {};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.264Z",
		"atimeMs": 1551857503264,
		"isfile": true
	},
	"filename": "lib/coffeescript/register.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  var CoffeeScript, Module, binary, child_process, ext, findExtension, fork, getRootModule, helpers, i, len, loadFile, path, ref;\n\n  CoffeeScript = require('./');\n\n  child_process = require('child_process');\n\n  helpers = require('./helpers');\n\n  path = require('path');\n\n  // Load and run a CoffeeScript file for Node, stripping any `BOM`s.\n  loadFile = function(module, filename) {\n    var answer, options;\n    options = module.options || getRootModule(module).options;\n    answer = CoffeeScript._compileFile(filename, options);\n    return module._compile(answer, filename);\n  };\n\n  // If the installed version of Node supports `require.extensions`, register\n  // CoffeeScript as an extension.\n  if (require.extensions) {\n    ref = CoffeeScript.FILE_EXTENSIONS;\n    for (i = 0, len = ref.length; i < len; i++) {\n      ext = ref[i];\n      require.extensions[ext] = loadFile;\n    }\n    // Patch Node's module loader to be able to handle multi-dot extensions.\n    // This is a horrible thing that should not be required.\n    Module = require('module');\n    findExtension = function(filename) {\n      var curExtension, extensions;\n      extensions = path.basename(filename).split('.');\n      if (extensions[0] === '') {\n        // Remove the initial dot from dotfiles.\n        extensions.shift();\n      }\n      // Start with the longest possible extension and work our way shortwards.\n      while (extensions.shift()) {\n        curExtension = '.' + extensions.join('.');\n        if (Module._extensions[curExtension]) {\n          return curExtension;\n        }\n      }\n      return '.js';\n    };\n    Module.prototype.load = function(filename) {\n      var extension;\n      this.filename = filename;\n      this.paths = Module._nodeModulePaths(path.dirname(filename));\n      extension = findExtension(filename);\n      Module._extensions[extension](this, filename);\n      return this.loaded = true;\n    };\n  }\n\n  // If we're on Node, patch `child_process.fork` so that Coffee scripts are able\n  // to fork both CoffeeScript files, and JavaScript files, directly.\n  if (child_process) {\n    ({fork} = child_process);\n    binary = require.resolve('../../bin/coffee');\n    child_process.fork = function(path, args, options) {\n      if (helpers.isCoffee(path)) {\n        if (!Array.isArray(args)) {\n          options = args || {};\n          args = [];\n        }\n        args = [path].concat(args);\n        path = binary;\n      }\n      return fork(path, args, options);\n    };\n  }\n\n  // Utility function to find the `options` object attached to the topmost module.\n  getRootModule = function(module) {\n    if (module.parent) {\n      return getRootModule(module.parent);\n    } else {\n      return module;\n    }\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.264Z",
		"atimeMs": 1551857503264,
		"isfile": true
	},
	"filename": "lib/coffeescript/repl.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  var CoffeeScript, addHistory, addMultilineHandler, fs, getCommandId, merge, nodeREPL, path, replDefaults, runInContext, sawSIGINT, transpile, updateSyntaxError, vm;\n\n  fs = require('fs');\n\n  path = require('path');\n\n  vm = require('vm');\n\n  nodeREPL = require('repl');\n\n  CoffeeScript = require('./');\n\n  ({merge, updateSyntaxError} = require('./helpers'));\n\n  sawSIGINT = false;\n\n  transpile = false;\n\n  replDefaults = {\n    prompt: 'coffee> ',\n    historyFile: (function() {\n      var historyPath;\n      historyPath = process.env.XDG_CACHE_HOME || process.env.HOME;\n      if (historyPath) {\n        return path.join(historyPath, '.coffee_history');\n      }\n    })(),\n    historyMaxInputSize: 10240,\n    eval: function(input, context, filename, cb) {\n      var Assign, Block, Call, Code, Literal, Value, ast, err, isAsync, js, ref, ref1, referencedVars, result, token, tokens;\n      // XXX: multiline hack.\n      input = input.replace(/\\uFF00/g, '\\n');\n      // Node's REPL sends the input ending with a newline and then wrapped in\n      // parens. Unwrap all that.\n      input = input.replace(/^\\(([\\s\\S]*)\\n\\)$/m, '$1');\n      // Node's REPL v6.9.1+ sends the input wrapped in a try/catch statement.\n      // Unwrap that too.\n      input = input.replace(/^\\s*try\\s*{([\\s\\S]*)}\\s*catch.*$/m, '$1');\n      // Require AST nodes to do some AST manipulation.\n      ({Block, Assign, Value, Literal, Call, Code} = require('./nodes'));\n      try {\n        // Tokenize the clean input.\n        tokens = CoffeeScript.tokens(input);\n        // Filter out tokens generated just to hold comments.\n        if (tokens.length >= 2 && tokens[0].generated && ((ref = tokens[0].comments) != null ? ref.length : void 0) !== 0 && tokens[0][1] === '' && tokens[1][0] === 'TERMINATOR') {\n          tokens = tokens.slice(2);\n        }\n        if (tokens.length >= 1 && tokens[tokens.length - 1].generated && ((ref1 = tokens[tokens.length - 1].comments) != null ? ref1.length : void 0) !== 0 && tokens[tokens.length - 1][1] === '') {\n          tokens.pop();\n        }\n        // Collect referenced variable names just like in `CoffeeScript.compile`.\n        referencedVars = (function() {\n          var i, len, results;\n          results = [];\n          for (i = 0, len = tokens.length; i < len; i++) {\n            token = tokens[i];\n            if (token[0] === 'IDENTIFIER') {\n              results.push(token[1]);\n            }\n          }\n          return results;\n        })();\n        // Generate the AST of the tokens.\n        ast = CoffeeScript.nodes(tokens);\n        // Add assignment to `__` variable to force the input to be an expression.\n        ast = new Block([new Assign(new Value(new Literal('__')), ast, '=')]);\n        // Wrap the expression in a closure to support top-level `await`.\n        ast = new Code([], ast);\n        isAsync = ast.isAsync;\n        // Invoke the wrapping closure.\n        ast = new Block([new Call(ast)]);\n        js = ast.compile({\n          bare: true,\n          locals: Object.keys(context),\n          referencedVars,\n          sharedScope: true\n        });\n        if (transpile) {\n          js = transpile.transpile(js, transpile.options).code;\n          // Strip `\"use strict\"`, to avoid an exception on assigning to\n          // undeclared variable `__`.\n          js = js.replace(/^\"use strict\"|^'use strict'/, '');\n        }\n        result = runInContext(js, context, filename);\n        // Await an async result, if necessary.\n        if (isAsync) {\n          result.then(function(resolvedResult) {\n            if (!sawSIGINT) {\n              return cb(null, resolvedResult);\n            }\n          });\n          return sawSIGINT = false;\n        } else {\n          return cb(null, result);\n        }\n      } catch (error) {\n        err = error;\n        // AST's `compile` does not add source code information to syntax errors.\n        updateSyntaxError(err, input);\n        return cb(err);\n      }\n    }\n  };\n\n  runInContext = function(js, context, filename) {\n    if (context === global) {\n      return vm.runInThisContext(js, filename);\n    } else {\n      return vm.runInContext(js, context, filename);\n    }\n  };\n\n  addMultilineHandler = function(repl) {\n    var inputStream, multiline, nodeLineListener, origPrompt, outputStream, ref, rli;\n    ({rli, inputStream, outputStream} = repl);\n    // Node 0.11.12 changed API, prompt is now _prompt.\n    origPrompt = (ref = repl._prompt) != null ? ref : repl.prompt;\n    multiline = {\n      enabled: false,\n      initialPrompt: origPrompt.replace(/^[^> ]*/, function(x) {\n        return x.replace(/./g, '-');\n      }),\n      prompt: origPrompt.replace(/^[^> ]*>?/, function(x) {\n        return x.replace(/./g, '.');\n      }),\n      buffer: ''\n    };\n    // Proxy node's line listener\n    nodeLineListener = rli.listeners('line')[0];\n    rli.removeListener('line', nodeLineListener);\n    rli.on('line', function(cmd) {\n      if (multiline.enabled) {\n        multiline.buffer += `${cmd}\\n`;\n        rli.setPrompt(multiline.prompt);\n        rli.prompt(true);\n      } else {\n        rli.setPrompt(origPrompt);\n        nodeLineListener(cmd);\n      }\n    });\n    // Handle Ctrl-v\n    return inputStream.on('keypress', function(char, key) {\n      if (!(key && key.ctrl && !key.meta && !key.shift && key.name === 'v')) {\n        return;\n      }\n      if (multiline.enabled) {\n        // allow arbitrarily switching between modes any time before multiple lines are entered\n        if (!multiline.buffer.match(/\\n/)) {\n          multiline.enabled = !multiline.enabled;\n          rli.setPrompt(origPrompt);\n          rli.prompt(true);\n          return;\n        }\n        // no-op unless the current line is empty\n        if ((rli.line != null) && !rli.line.match(/^\\s*$/)) {\n          return;\n        }\n        // eval, print, loop\n        multiline.enabled = !multiline.enabled;\n        rli.line = '';\n        rli.cursor = 0;\n        rli.output.cursorTo(0);\n        rli.output.clearLine(1);\n        // XXX: multiline hack\n        multiline.buffer = multiline.buffer.replace(/\\n/g, '\\uFF00');\n        rli.emit('line', multiline.buffer);\n        multiline.buffer = '';\n      } else {\n        multiline.enabled = !multiline.enabled;\n        rli.setPrompt(multiline.initialPrompt);\n        rli.prompt(true);\n      }\n    });\n  };\n\n  // Store and load command history from a file\n  addHistory = function(repl, filename, maxSize) {\n    var buffer, fd, lastLine, readFd, size, stat;\n    lastLine = null;\n    try {\n      // Get file info and at most maxSize of command history\n      stat = fs.statSync(filename);\n      size = Math.min(maxSize, stat.size);\n      // Read last `size` bytes from the file\n      readFd = fs.openSync(filename, 'r');\n      buffer = Buffer.alloc(size);\n      fs.readSync(readFd, buffer, 0, size, stat.size - size);\n      fs.closeSync(readFd);\n      // Set the history on the interpreter\n      repl.rli.history = buffer.toString().split('\\n').reverse();\n      if (stat.size > maxSize) {\n        // If the history file was truncated we should pop off a potential partial line\n        repl.rli.history.pop();\n      }\n      if (repl.rli.history[0] === '') {\n        // Shift off the final blank newline\n        repl.rli.history.shift();\n      }\n      repl.rli.historyIndex = -1;\n      lastLine = repl.rli.history[0];\n    } catch (error) {}\n    fd = fs.openSync(filename, 'a');\n    repl.rli.addListener('line', function(code) {\n      if (code && code.length && code !== '.history' && code !== '.exit' && lastLine !== code) {\n        // Save the latest command in the file\n        fs.writeSync(fd, `${code}\\n`);\n        return lastLine = code;\n      }\n    });\n    // XXX: The SIGINT event from REPLServer is undocumented, so this is a bit fragile\n    repl.on('SIGINT', function() {\n      return sawSIGINT = true;\n    });\n    repl.on('exit', function() {\n      return fs.closeSync(fd);\n    });\n    // Add a command to show the history stack\n    return repl.commands[getCommandId(repl, 'history')] = {\n      help: 'Show command history',\n      action: function() {\n        repl.outputStream.write(`${repl.rli.history.slice(0).reverse().join('\\n')}\\n`);\n        return repl.displayPrompt();\n      }\n    };\n  };\n\n  getCommandId = function(repl, commandName) {\n    var commandsHaveLeadingDot;\n    // Node 0.11 changed API, a command such as '.help' is now stored as 'help'\n    commandsHaveLeadingDot = repl.commands['.help'] != null;\n    if (commandsHaveLeadingDot) {\n      return `.${commandName}`;\n    } else {\n      return commandName;\n    }\n  };\n\n  module.exports = {\n    start: function(opts = {}) {\n      var Module, build, major, minor, originalModuleLoad, repl;\n      [major, minor, build] = process.versions.node.split('.').map(function(n) {\n        return parseInt(n, 10);\n      });\n      if (major < 6) {\n        console.warn(\"Node 6+ required for CoffeeScript REPL\");\n        process.exit(1);\n      }\n      CoffeeScript.register();\n      process.argv = ['coffee'].concat(process.argv.slice(2));\n      if (opts.transpile) {\n        transpile = {};\n        try {\n          transpile.transpile = require('@babel/core').transform;\n        } catch (error) {\n          try {\n            transpile.transpile = require('babel-core').transform;\n          } catch (error) {\n            console.error('To use --transpile with an interactive REPL, @babel/core must be installed either in the current folder or globally:\\n  npm install --save-dev @babel/core\\nor\\n  npm install --global @babel/core\\nAnd you must save options to configure Babel in one of the places it looks to find its options.\\nSee https://coffeescript.org/#transpilation');\n            process.exit(1);\n          }\n        }\n        transpile.options = {\n          filename: path.resolve(process.cwd(), '<repl>')\n        };\n        // Since the REPL compilation path is unique (in `eval` above), we need\n        // another way to get the `options` object attached to a module so that\n        // it knows later on whether it needs to be transpiled. In the case of\n        // the REPL, the only applicable option is `transpile`.\n        Module = require('module');\n        originalModuleLoad = Module.prototype.load;\n        Module.prototype.load = function(filename) {\n          this.options = {\n            transpile: transpile.options\n          };\n          return originalModuleLoad.call(this, filename);\n        };\n      }\n      opts = merge(replDefaults, opts);\n      repl = nodeREPL.start(opts);\n      if (opts.prelude) {\n        runInContext(opts.prelude, repl.context, 'prelude');\n      }\n      repl.on('exit', function() {\n        if (!repl.rli.closed) {\n          return repl.outputStream.write('\\n');\n        }\n      });\n      addMultilineHandler(repl);\n      if (opts.historyFile) {\n        addHistory(repl, opts.historyFile, opts.historyMaxInputSize);\n      }\n      // Adapt help inherited from the node REPL\n      repl.commands[getCommandId(repl, 'load')].help = 'Load code from a file into this REPL session';\n      return repl;\n    }\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.264Z",
		"atimeMs": 1551857503264,
		"isfile": true
	},
	"filename": "lib/coffeescript/rewriter.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // The CoffeeScript language has a good deal of optional syntax, implicit syntax,\n  // and shorthand syntax. This can greatly complicate a grammar and bloat\n  // the resulting parse table. Instead of making the parser handle it all, we take\n  // a series of passes over the token stream, using this **Rewriter** to convert\n  // shorthand into the unambiguous long form, add implicit indentation and\n  // parentheses, and generally clean things up.\n  var BALANCED_PAIRS, CALL_CLOSERS, CONTROL_IN_IMPLICIT, DISCARDED, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, Rewriter, SINGLE_CLOSERS, SINGLE_LINERS, generate, k, left, len, moveComments, right, throwSyntaxError,\n    indexOf = [].indexOf;\n\n  ({throwSyntaxError} = require('./helpers'));\n\n  // Move attached comments from one token to another.\n  moveComments = function(fromToken, toToken) {\n    var comment, k, len, ref, unshiftedComments;\n    if (!fromToken.comments) {\n      return;\n    }\n    if (toToken.comments && toToken.comments.length !== 0) {\n      unshiftedComments = [];\n      ref = fromToken.comments;\n      for (k = 0, len = ref.length; k < len; k++) {\n        comment = ref[k];\n        if (comment.unshift) {\n          unshiftedComments.push(comment);\n        } else {\n          toToken.comments.push(comment);\n        }\n      }\n      toToken.comments = unshiftedComments.concat(toToken.comments);\n    } else {\n      toToken.comments = fromToken.comments;\n    }\n    return delete fromToken.comments;\n  };\n\n  // Create a generated token: one that exists due to a use of implicit syntax.\n  // Optionally have this new token take the attached comments from another token.\n  generate = function(tag, value, origin, commentsToken) {\n    var token;\n    token = [tag, value];\n    token.generated = true;\n    if (origin) {\n      token.origin = origin;\n    }\n    if (commentsToken) {\n      moveComments(commentsToken, token);\n    }\n    return token;\n  };\n\n  // The **Rewriter** class is used by the [Lexer](lexer.html), directly against\n  // its internal array of tokens.\n  exports.Rewriter = Rewriter = (function() {\n    class Rewriter {\n      // Rewrite the token stream in multiple passes, one logical filter at\n      // a time. This could certainly be changed into a single pass through the\n      // stream, with a big olâ efficient switch, but itâs much nicer to work with\n      // like this. The order of these passes mattersâindentation must be\n      // corrected before implicit parentheses can be wrapped around blocks of code.\n      rewrite(tokens1) {\n        var ref, ref1, t;\n        this.tokens = tokens1;\n        // Set environment variable `DEBUG_TOKEN_STREAM` to `true` to output token\n        // debugging info. Also set `DEBUG_REWRITTEN_TOKEN_STREAM` to `true` to\n        // output the token stream after it has been rewritten by this file.\n        if (typeof process !== \"undefined\" && process !== null ? (ref = process.env) != null ? ref.DEBUG_TOKEN_STREAM : void 0 : void 0) {\n          if (process.env.DEBUG_REWRITTEN_TOKEN_STREAM) {\n            console.log('Initial token stream:');\n          }\n          console.log(((function() {\n            var k, len, ref1, results;\n            ref1 = this.tokens;\n            results = [];\n            for (k = 0, len = ref1.length; k < len; k++) {\n              t = ref1[k];\n              results.push(t[0] + '/' + t[1] + (t.comments ? '*' : ''));\n            }\n            return results;\n          }).call(this)).join(' '));\n        }\n        this.removeLeadingNewlines();\n        this.closeOpenCalls();\n        this.closeOpenIndexes();\n        this.normalizeLines();\n        this.tagPostfixConditionals();\n        this.addImplicitBracesAndParens();\n        this.addParensToChainedDoIife();\n        this.rescueStowawayComments();\n        this.addLocationDataToGeneratedTokens();\n        this.enforceValidCSXAttributes();\n        this.fixOutdentLocationData();\n        if (typeof process !== \"undefined\" && process !== null ? (ref1 = process.env) != null ? ref1.DEBUG_REWRITTEN_TOKEN_STREAM : void 0 : void 0) {\n          if (process.env.DEBUG_TOKEN_STREAM) {\n            console.log('Rewritten token stream:');\n          }\n          console.log(((function() {\n            var k, len, ref2, results;\n            ref2 = this.tokens;\n            results = [];\n            for (k = 0, len = ref2.length; k < len; k++) {\n              t = ref2[k];\n              results.push(t[0] + '/' + t[1] + (t.comments ? '*' : ''));\n            }\n            return results;\n          }).call(this)).join(' '));\n        }\n        return this.tokens;\n      }\n\n      // Rewrite the token stream, looking one token ahead and behind.\n      // Allow the return value of the block to tell us how many tokens to move\n      // forwards (or backwards) in the stream, to make sure we donât miss anything\n      // as tokens are inserted and removed, and the stream changes length under\n      // our feet.\n      scanTokens(block) {\n        var i, token, tokens;\n        ({tokens} = this);\n        i = 0;\n        while (token = tokens[i]) {\n          i += block.call(this, token, i, tokens);\n        }\n        return true;\n      }\n\n      detectEnd(i, condition, action, opts = {}) {\n        var levels, ref, ref1, token, tokens;\n        ({tokens} = this);\n        levels = 0;\n        while (token = tokens[i]) {\n          if (levels === 0 && condition.call(this, token, i)) {\n            return action.call(this, token, i);\n          }\n          if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {\n            levels += 1;\n          } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {\n            levels -= 1;\n          }\n          if (levels < 0) {\n            if (opts.returnOnNegativeLevel) {\n              return;\n            }\n            return action.call(this, token, i);\n          }\n          i += 1;\n        }\n        return i - 1;\n      }\n\n      // Leading newlines would introduce an ambiguity in the grammar, so we\n      // dispatch them here.\n      removeLeadingNewlines() {\n        var i, k, l, leadingNewlineToken, len, len1, ref, ref1, tag;\n        ref = this.tokens;\n        for (i = k = 0, len = ref.length; k < len; i = ++k) {\n          [tag] = ref[i];\n          if (tag !== 'TERMINATOR') {\n            // Find the index of the first non-`TERMINATOR` token.\n            break;\n          }\n        }\n        if (i === 0) {\n          return;\n        }\n        ref1 = this.tokens.slice(0, i);\n        // If there are any comments attached to the tokens weâre about to discard,\n        // shift them forward to what will become the new first token.\n        for (l = 0, len1 = ref1.length; l < len1; l++) {\n          leadingNewlineToken = ref1[l];\n          moveComments(leadingNewlineToken, this.tokens[i]);\n        }\n        // Discard all the leading newline tokens.\n        return this.tokens.splice(0, i);\n      }\n\n      // The lexer has tagged the opening parenthesis of a method call. Match it with\n      // its paired close.\n      closeOpenCalls() {\n        var action, condition;\n        condition = function(token, i) {\n          var ref;\n          return (ref = token[0]) === ')' || ref === 'CALL_END';\n        };\n        action = function(token, i) {\n          return token[0] = 'CALL_END';\n        };\n        return this.scanTokens(function(token, i) {\n          if (token[0] === 'CALL_START') {\n            this.detectEnd(i + 1, condition, action);\n          }\n          return 1;\n        });\n      }\n\n      // The lexer has tagged the opening bracket of an indexing operation call.\n      // Match it with its paired close.\n      closeOpenIndexes() {\n        var action, condition;\n        condition = function(token, i) {\n          var ref;\n          return (ref = token[0]) === ']' || ref === 'INDEX_END';\n        };\n        action = function(token, i) {\n          return token[0] = 'INDEX_END';\n        };\n        return this.scanTokens(function(token, i) {\n          if (token[0] === 'INDEX_START') {\n            this.detectEnd(i + 1, condition, action);\n          }\n          return 1;\n        });\n      }\n\n      // Match tags in token stream starting at `i` with `pattern`.\n      // `pattern` may consist of strings (equality), an array of strings (one of)\n      // or null (wildcard). Returns the index of the match or -1 if no match.\n      indexOfTag(i, ...pattern) {\n        var fuzz, j, k, ref, ref1;\n        fuzz = 0;\n        for (j = k = 0, ref = pattern.length; (0 <= ref ? k < ref : k > ref); j = 0 <= ref ? ++k : --k) {\n          if (pattern[j] == null) {\n            continue;\n          }\n          if (typeof pattern[j] === 'string') {\n            pattern[j] = [pattern[j]];\n          }\n          if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {\n            return -1;\n          }\n        }\n        return i + j + fuzz - 1;\n      }\n\n      // Returns `yes` if standing in front of something looking like\n      // `@<x>:`, `<x>:` or `<EXPRESSION_START><x>...<EXPRESSION_END>:`.\n      looksObjectish(j) {\n        var end, index;\n        if (this.indexOfTag(j, '@', null, ':') !== -1 || this.indexOfTag(j, null, ':') !== -1) {\n          return true;\n        }\n        index = this.indexOfTag(j, EXPRESSION_START);\n        if (index !== -1) {\n          end = null;\n          this.detectEnd(index + 1, (function(token) {\n            var ref;\n            return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;\n          }), (function(token, i) {\n            return end = i;\n          }));\n          if (this.tag(end + 1) === ':') {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // Returns `yes` if current line of tokens contain an element of tags on same\n      // expression level. Stop searching at `LINEBREAKS` or explicit start of\n      // containing balanced expression.\n      findTagsBackwards(i, tags) {\n        var backStack, ref, ref1, ref2, ref3, ref4, ref5;\n        backStack = [];\n        while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {\n          if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {\n            backStack.push(this.tag(i));\n          }\n          if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {\n            backStack.pop();\n          }\n          i -= 1;\n        }\n        return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;\n      }\n\n      // Look for signs of implicit calls and objects in the token stream and\n      // add them.\n      addImplicitBracesAndParens() {\n        var stack, start;\n        // Track current balancing depth (both implicit and explicit) on stack.\n        stack = [];\n        start = null;\n        return this.scanTokens(function(token, i, tokens) {\n          var endImplicitCall, endImplicitObject, forward, implicitObjectContinues, inControlFlow, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, nextToken, offset, prevTag, prevToken, ref, ref1, ref2, s, sameLine, stackIdx, stackItem, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;\n          [tag] = token;\n          [prevTag] = prevToken = i > 0 ? tokens[i - 1] : [];\n          [nextTag] = nextToken = i < tokens.length - 1 ? tokens[i + 1] : [];\n          stackTop = function() {\n            return stack[stack.length - 1];\n          };\n          startIdx = i;\n          // Helper function, used for keeping track of the number of tokens consumed\n          // and spliced, when returning for getting a new token.\n          forward = function(n) {\n            return i - startIdx + n;\n          };\n          // Helper functions\n          isImplicit = function(stackItem) {\n            var ref;\n            return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;\n          };\n          isImplicitObject = function(stackItem) {\n            return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';\n          };\n          isImplicitCall = function(stackItem) {\n            return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';\n          };\n          inImplicit = function() {\n            return isImplicit(stackTop());\n          };\n          inImplicitCall = function() {\n            return isImplicitCall(stackTop());\n          };\n          inImplicitObject = function() {\n            return isImplicitObject(stackTop());\n          };\n          // Unclosed control statement inside implicit parens (like\n          // class declaration or if-conditionals).\n          inImplicitControl = function() {\n            var ref;\n            return inImplicit() && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';\n          };\n          startImplicitCall = function(idx) {\n            stack.push([\n              '(',\n              idx,\n              {\n                ours: true\n              }\n            ]);\n            return tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]], prevToken));\n          };\n          endImplicitCall = function() {\n            stack.pop();\n            tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]], prevToken));\n            return i += 1;\n          };\n          startImplicitObject = function(idx, startsLine = true) {\n            var val;\n            stack.push([\n              '{',\n              idx,\n              {\n                sameLine: true,\n                startsLine: startsLine,\n                ours: true\n              }\n            ]);\n            val = new String('{');\n            val.generated = true;\n            return tokens.splice(idx, 0, generate('{', val, token, prevToken));\n          };\n          endImplicitObject = function(j) {\n            j = j != null ? j : i;\n            stack.pop();\n            tokens.splice(j, 0, generate('}', '}', token, prevToken));\n            return i += 1;\n          };\n          implicitObjectContinues = (j) => {\n            var nextTerminatorIdx;\n            nextTerminatorIdx = null;\n            this.detectEnd(j, function(token) {\n              return token[0] === 'TERMINATOR';\n            }, function(token, i) {\n              return nextTerminatorIdx = i;\n            }, {\n              returnOnNegativeLevel: true\n            });\n            if (nextTerminatorIdx == null) {\n              return false;\n            }\n            return this.looksObjectish(nextTerminatorIdx + 1);\n          };\n          // Donât end an implicit call/object on next indent if any of these are in an argument/value.\n          if ((inImplicitCall() || inImplicitObject()) && indexOf.call(CONTROL_IN_IMPLICIT, tag) >= 0 || inImplicitObject() && prevTag === ':' && tag === 'FOR') {\n            stack.push([\n              'CONTROL',\n              i,\n              {\n                ours: true\n              }\n            ]);\n            return forward(1);\n          }\n          if (tag === 'INDENT' && inImplicit()) {\n            // An `INDENT` closes an implicit call unless\n\n            //  1. We have seen a `CONTROL` argument on the line.\n            //  2. The last token before the indent is part of the list below.\n            if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'ELSE' && prevTag !== '=') {\n              while (inImplicitCall() || inImplicitObject() && prevTag !== ':') {\n                if (inImplicitCall()) {\n                  endImplicitCall();\n                } else {\n                  endImplicitObject();\n                }\n              }\n            }\n            if (inImplicitControl()) {\n              stack.pop();\n            }\n            stack.push([tag, i]);\n            return forward(1);\n          }\n          // Straightforward start of explicit expression.\n          if (indexOf.call(EXPRESSION_START, tag) >= 0) {\n            stack.push([tag, i]);\n            return forward(1);\n          }\n          // Close all implicit expressions inside of explicitly closed expressions.\n          if (indexOf.call(EXPRESSION_END, tag) >= 0) {\n            while (inImplicit()) {\n              if (inImplicitCall()) {\n                endImplicitCall();\n              } else if (inImplicitObject()) {\n                endImplicitObject();\n              } else {\n                stack.pop();\n              }\n            }\n            start = stack.pop();\n          }\n          inControlFlow = () => {\n            var controlFlow, isFunc, seenFor, tagCurrentLine;\n            seenFor = this.findTagsBackwards(i, ['FOR']) && this.findTagsBackwards(i, ['FORIN', 'FOROF', 'FORFROM']);\n            controlFlow = seenFor || this.findTagsBackwards(i, ['WHILE', 'UNTIL', 'LOOP', 'LEADING_WHEN']);\n            if (!controlFlow) {\n              return false;\n            }\n            isFunc = false;\n            tagCurrentLine = token[2].first_line;\n            this.detectEnd(i, function(token, i) {\n              var ref;\n              return ref = token[0], indexOf.call(LINEBREAKS, ref) >= 0;\n            }, function(token, i) {\n              var first_line;\n              [prevTag, , {first_line}] = tokens[i - 1] || [];\n              return isFunc = tagCurrentLine === first_line && (prevTag === '->' || prevTag === '=>');\n            }, {\n              returnOnNegativeLevel: true\n            });\n            return isFunc;\n          };\n          // Recognize standard implicit calls like\n          // f a, f() b, f? c, h[0] d etc.\n          // Added support for spread dots on the left side: f ...a\n          if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || (nextTag === '...' && (ref = this.tag(i + 2), indexOf.call(IMPLICIT_CALL, ref) >= 0) && !this.findTagsBackwards(i, ['INDEX_START', '['])) || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !nextToken.spaced && !nextToken.newLine) && !inControlFlow()) {\n            if (tag === '?') {\n              tag = token[0] = 'FUNC_EXIST';\n            }\n            startImplicitCall(i + 1);\n            return forward(2);\n          }\n          // Implicit call taking an implicit indented object as first argument.\n\n          //     f\n          //       a: b\n          //       c: d\n\n          // Donât accept implicit calls of this type, when on the same line\n          // as the control structures below as that may misinterpret constructs like:\n\n          //     if f\n          //        a: 1\n          // as\n\n          //     if f(a: 1)\n\n          // which is probably always unintended.\n          // Furthermore donât allow this in literal arrays, as\n          // that creates grammatical ambiguities.\n          if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {\n            startImplicitCall(i + 1);\n            stack.push(['INDENT', i + 2]);\n            return forward(3);\n          }\n          // Implicit objects start here.\n          if (tag === ':') {\n            // Go back to the (implicit) start of the object.\n            s = (function() {\n              var ref1;\n              switch (false) {\n                case ref1 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref1) < 0:\n                  return start[1];\n                case this.tag(i - 2) !== '@':\n                  return i - 2;\n                default:\n                  return i - 1;\n              }\n            }).call(this);\n            startsLine = s <= 0 || (ref1 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref1) >= 0) || tokens[s - 1].newLine;\n            // Are we just continuing an already declared object?\n            if (stackTop()) {\n              [stackTag, stackIdx] = stackTop();\n              if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {\n                return forward(1);\n              }\n            }\n            startImplicitObject(s, !!startsLine);\n            return forward(2);\n          }\n          // End implicit calls when chaining method calls\n          // like e.g.:\n\n          //     f ->\n          //       a\n          //     .g b, ->\n          //       c\n          //     .h a\n\n          // and also\n\n          //     f a\n          //     .g b\n          //     .h a\n\n          // Mark all enclosing objects as not sameLine\n          if (indexOf.call(LINEBREAKS, tag) >= 0) {\n            for (k = stack.length - 1; k >= 0; k += -1) {\n              stackItem = stack[k];\n              if (!isImplicit(stackItem)) {\n                break;\n              }\n              if (isImplicitObject(stackItem)) {\n                stackItem[2].sameLine = false;\n              }\n            }\n          }\n          newLine = prevTag === 'OUTDENT' || prevToken.newLine;\n          if (indexOf.call(IMPLICIT_END, tag) >= 0 || (indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) || ((tag === '..' || tag === '...') && this.findTagsBackwards(i, [\"INDEX_START\"]))) {\n            while (inImplicit()) {\n              [stackTag, stackIdx, {sameLine, startsLine}] = stackTop();\n              // Close implicit calls when reached end of argument list\n              if (inImplicitCall() && prevTag !== ',' || (prevTag === ',' && tag === 'TERMINATOR' && (nextTag == null))) {\n                endImplicitCall();\n              // Close implicit objects such as:\n              // return a: 1, b: 2 unless true\n              } else if (inImplicitObject() && sameLine && tag !== 'TERMINATOR' && prevTag !== ':' && !((tag === 'POST_IF' || tag === 'FOR' || tag === 'WHILE' || tag === 'UNTIL') && startsLine && implicitObjectContinues(i + 1))) {\n                endImplicitObject();\n              // Close implicit objects when at end of line, line didn't end with a comma\n              // and the implicit object didn't start the line or the next line doesnât look like\n              // the continuation of an object.\n              } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {\n                endImplicitObject();\n              } else if (inImplicitControl() && tokens[stackTop()[1]][0] === 'CLASS' && tag === 'TERMINATOR') {\n                stack.pop();\n              } else {\n                break;\n              }\n            }\n          }\n          // Close implicit object if comma is the last character\n          // and what comes after doesnât look like it belongs.\n          // This is used for trailing commas and calls, like:\n\n          //     x =\n          //         a: b,\n          //         c: d,\n          //     e = 2\n\n          // and\n\n          //     f a, b: c, d: e, f, g: h: i, j\n\n          if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !((ref2 = this.tag(i + 2)) === 'FOROF' || ref2 === 'FORIN') && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {\n            // When nextTag is OUTDENT the comma is insignificant and\n            // should just be ignored so embed it in the implicit object.\n\n            // When it isnât the comma go on to play a role in a call or\n            // array further up the stack, so give it a chance.\n            offset = nextTag === 'OUTDENT' ? 1 : 0;\n            while (inImplicitObject()) {\n              endImplicitObject(i + offset);\n            }\n          }\n          return forward(1);\n        });\n      }\n\n      // Make sure only strings and wrapped expressions are used in CSX attributes.\n      enforceValidCSXAttributes() {\n        return this.scanTokens(function(token, i, tokens) {\n          var next, ref;\n          if (token.csxColon) {\n            next = tokens[i + 1];\n            if ((ref = next[0]) !== 'STRING_START' && ref !== 'STRING' && ref !== '(') {\n              throwSyntaxError('expected wrapped or quoted JSX attribute', next[2]);\n            }\n          }\n          return 1;\n        });\n      }\n\n      // Not all tokens survive processing by the parser. To avoid comments getting\n      // lost into the ether, find comments attached to doomed tokens and move them\n      // to a token that will make it to the other side.\n      rescueStowawayComments() {\n        var insertPlaceholder, shiftCommentsBackward, shiftCommentsForward;\n        insertPlaceholder = function(token, j, tokens, method) {\n          if (tokens[j][0] !== 'TERMINATOR') {\n            tokens[method](generate('TERMINATOR', '\\n', tokens[j]));\n          }\n          return tokens[method](generate('JS', '', tokens[j], token));\n        };\n        shiftCommentsForward = function(token, i, tokens) {\n          var comment, j, k, len, ref, ref1, ref2;\n          // Find the next surviving token and attach this tokenâs comments to it,\n          // with a flag that we know to output such comments *before* that\n          // tokenâs own compilation. (Otherwise comments are output following\n          // the token theyâre attached to.)\n          j = i;\n          while (j !== tokens.length && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {\n            j++;\n          }\n          if (!(j === tokens.length || (ref1 = tokens[j][0], indexOf.call(DISCARDED, ref1) >= 0))) {\n            ref2 = token.comments;\n            for (k = 0, len = ref2.length; k < len; k++) {\n              comment = ref2[k];\n              comment.unshift = true;\n            }\n            moveComments(token, tokens[j]);\n            return 1; // All following tokens are doomed!\n          } else {\n            j = tokens.length - 1;\n            insertPlaceholder(token, j, tokens, 'push');\n            // The generated tokens were added to the end, not inline, so we donât skip.\n            return 1;\n          }\n        };\n        shiftCommentsBackward = function(token, i, tokens) {\n          var j, ref, ref1;\n          // Find the last surviving token and attach this tokenâs comments to it.\n          j = i;\n          while (j !== -1 && (ref = tokens[j][0], indexOf.call(DISCARDED, ref) >= 0)) {\n            j--;\n          }\n          if (!(j === -1 || (ref1 = tokens[j][0], indexOf.call(DISCARDED, ref1) >= 0))) {\n            moveComments(token, tokens[j]);\n            return 1; // All previous tokens are doomed!\n          } else {\n            insertPlaceholder(token, 0, tokens, 'unshift');\n            // We added two tokens, so shift forward to account for the insertion.\n            return 3;\n          }\n        };\n        return this.scanTokens(function(token, i, tokens) {\n          var dummyToken, j, ref, ref1, ret;\n          if (!token.comments) {\n            return 1;\n          }\n          ret = 1;\n          if (ref = token[0], indexOf.call(DISCARDED, ref) >= 0) {\n            // This token wonât survive passage through the parser, so we need to\n            // rescue its attached tokens and redistribute them to nearby tokens.\n            // Comments that donât start a new line can shift backwards to the last\n            // safe token, while other tokens should shift forward.\n            dummyToken = {\n              comments: []\n            };\n            j = token.comments.length - 1;\n            while (j !== -1) {\n              if (token.comments[j].newLine === false && token.comments[j].here === false) {\n                dummyToken.comments.unshift(token.comments[j]);\n                token.comments.splice(j, 1);\n              }\n              j--;\n            }\n            if (dummyToken.comments.length !== 0) {\n              ret = shiftCommentsBackward(dummyToken, i - 1, tokens);\n            }\n            if (token.comments.length !== 0) {\n              shiftCommentsForward(token, i, tokens);\n            }\n          } else {\n            // If any of this tokenâs comments start a lineâthereâs only\n            // whitespace between the preceding newline and the start of the\n            // commentâand this isnât one of the special `JS` tokens, then\n            // shift this comment forward to precede the next valid token.\n            // `Block.compileComments` also has logic to make sure that\n            // âstarting new lineâ comments follow or precede the nearest\n            // newline relative to the token that the comment is attached to,\n            // but that newline might be inside a `}` or `)` or other generated\n            // token that we really want this comment to output after. Therefore\n            // we need to shift the comments here, avoiding such generated and\n            // discarded tokens.\n            dummyToken = {\n              comments: []\n            };\n            j = token.comments.length - 1;\n            while (j !== -1) {\n              if (token.comments[j].newLine && !token.comments[j].unshift && !(token[0] === 'JS' && token.generated)) {\n                dummyToken.comments.unshift(token.comments[j]);\n                token.comments.splice(j, 1);\n              }\n              j--;\n            }\n            if (dummyToken.comments.length !== 0) {\n              ret = shiftCommentsForward(dummyToken, i + 1, tokens);\n            }\n          }\n          if (((ref1 = token.comments) != null ? ref1.length : void 0) === 0) {\n            delete token.comments;\n          }\n          return ret;\n        });\n      }\n\n      // Add location data to all tokens generated by the rewriter.\n      addLocationDataToGeneratedTokens() {\n        return this.scanTokens(function(token, i, tokens) {\n          var column, line, nextLocation, prevLocation, ref, ref1;\n          if (token[2]) {\n            return 1;\n          }\n          if (!(token.generated || token.explicit)) {\n            return 1;\n          }\n          if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {\n            ({\n              first_line: line,\n              first_column: column\n            } = nextLocation);\n          } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {\n            ({\n              last_line: line,\n              last_column: column\n            } = prevLocation);\n          } else {\n            line = column = 0;\n          }\n          token[2] = {\n            first_line: line,\n            first_column: column,\n            last_line: line,\n            last_column: column\n          };\n          return 1;\n        });\n      }\n\n      // `OUTDENT` tokens should always be positioned at the last character of the\n      // previous token, so that AST nodes ending in an `OUTDENT` token end up with a\n      // location corresponding to the last ârealâ token under the node.\n      fixOutdentLocationData() {\n        return this.scanTokens(function(token, i, tokens) {\n          var prevLocationData;\n          if (!(token[0] === 'OUTDENT' || (token.generated && token[0] === 'CALL_END') || (token.generated && token[0] === '}'))) {\n            return 1;\n          }\n          prevLocationData = tokens[i - 1][2];\n          token[2] = {\n            first_line: prevLocationData.last_line,\n            first_column: prevLocationData.last_column,\n            last_line: prevLocationData.last_line,\n            last_column: prevLocationData.last_column\n          };\n          return 1;\n        });\n      }\n\n      // Add parens around a `do` IIFE followed by a chained `.` so that the\n      // chaining applies to the executed function rather than the function\n      // object (see #3736)\n      addParensToChainedDoIife() {\n        var action, condition, doIndex;\n        condition = function(token, i) {\n          return this.tag(i - 1) === 'OUTDENT';\n        };\n        action = function(token, i) {\n          var ref;\n          if (ref = token[0], indexOf.call(CALL_CLOSERS, ref) < 0) {\n            return;\n          }\n          this.tokens.splice(doIndex, 0, generate('(', '(', this.tokens[doIndex]));\n          return this.tokens.splice(i + 1, 0, generate(')', ')', this.tokens[i]));\n        };\n        doIndex = null;\n        return this.scanTokens(function(token, i, tokens) {\n          var glyphIndex, ref;\n          if (token[1] !== 'do') {\n            return 1;\n          }\n          doIndex = i;\n          glyphIndex = i + 1;\n          if (this.tag(i + 1) === 'PARAM_START') {\n            glyphIndex = null;\n            this.detectEnd(i + 1, function(token, i) {\n              return this.tag(i - 1) === 'PARAM_END';\n            }, function(token, i) {\n              return glyphIndex = i;\n            });\n          }\n          if (!((glyphIndex != null) && ((ref = this.tag(glyphIndex)) === '->' || ref === '=>') && this.tag(glyphIndex + 1) === 'INDENT')) {\n            return 1;\n          }\n          this.detectEnd(glyphIndex + 1, condition, action);\n          return 2;\n        });\n      }\n\n      // Because our grammar is LALR(1), it canât handle some single-line\n      // expressions that lack ending delimiters. The **Rewriter** adds the implicit\n      // blocks, so it doesnât need to. To keep the grammar clean and tidy, trailing\n      // newlines within expressions are removed and the indentation tokens of empty\n      // blocks are added.\n      normalizeLines() {\n        var action, closeElseTag, condition, ifThens, indent, leading_if_then, leading_switch_when, outdent, starter;\n        starter = indent = outdent = null;\n        leading_switch_when = null;\n        leading_if_then = null;\n        // Count `THEN` tags\n        ifThens = [];\n        condition = function(token, i) {\n          var ref, ref1, ref2, ref3;\n          return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && (starter !== 'THEN' || (leading_if_then || leading_switch_when))) && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');\n        };\n        action = function(token, i) {\n          if (token[0] === 'ELSE' && starter === 'THEN') {\n            ifThens.pop();\n          }\n          return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);\n        };\n        closeElseTag = (tokens, i) => {\n          var lastThen, outdentElse, tlen;\n          tlen = ifThens.length;\n          if (!(tlen > 0)) {\n            return i;\n          }\n          lastThen = ifThens.pop();\n          [, outdentElse] = this.indentation(tokens[lastThen]);\n          // Insert `OUTDENT` to close inner `IF`.\n          outdentElse[1] = tlen * 2;\n          tokens.splice(i, 0, outdentElse);\n          // Insert `OUTDENT` to close outer `IF`.\n          outdentElse[1] = 2;\n          tokens.splice(i + 1, 0, outdentElse);\n          // Remove outdents from the end.\n          this.detectEnd(i + 2, function(token, i) {\n            var ref;\n            return (ref = token[0]) === 'OUTDENT' || ref === 'TERMINATOR';\n          }, function(token, i) {\n            if (this.tag(i) === 'OUTDENT' && this.tag(i + 1) === 'OUTDENT') {\n              return tokens.splice(i, 2);\n            }\n          });\n          return i + 2;\n        };\n        return this.scanTokens(function(token, i, tokens) {\n          var conditionTag, j, k, ref, ref1, tag;\n          [tag] = token;\n          conditionTag = (tag === '->' || tag === '=>') && this.findTagsBackwards(i, ['IF', 'WHILE', 'FOR', 'UNTIL', 'SWITCH', 'WHEN', 'LEADING_WHEN', '[', 'INDEX_START']) && !(this.findTagsBackwards(i, ['THEN', '..', '...']));\n          if (tag === 'TERMINATOR') {\n            if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {\n              tokens.splice(i, 1, ...this.indentation());\n              return 1;\n            }\n            if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {\n              tokens.splice(i, 1);\n              return 0;\n            }\n          }\n          if (tag === 'CATCH') {\n            for (j = k = 1; k <= 2; j = ++k) {\n              if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {\n                continue;\n              }\n              tokens.splice(i + j, 0, ...this.indentation());\n              return 2 + j;\n            }\n          }\n          if ((tag === '->' || tag === '=>') && (this.tag(i + 1) === ',' || this.tag(i + 1) === '.' && token.newLine)) {\n            [indent, outdent] = this.indentation(tokens[i]);\n            tokens.splice(i + 1, 0, indent, outdent);\n            return 1;\n          }\n          if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF') && !conditionTag) {\n            starter = tag;\n            [indent, outdent] = this.indentation(tokens[i]);\n            if (starter === 'THEN') {\n              indent.fromThen = true;\n            }\n            if (tag === 'THEN') {\n              leading_switch_when = this.findTagsBackwards(i, ['LEADING_WHEN']) && this.tag(i + 1) === 'IF';\n              leading_if_then = this.findTagsBackwards(i, ['IF']) && this.tag(i + 1) === 'IF';\n            }\n            if (tag === 'THEN' && this.findTagsBackwards(i, ['IF'])) {\n              ifThens.push(i);\n            }\n            // `ELSE` tag is not closed.\n            if (tag === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {\n              i = closeElseTag(tokens, i);\n            }\n            tokens.splice(i + 1, 0, indent);\n            this.detectEnd(i + 2, condition, action);\n            if (tag === 'THEN') {\n              tokens.splice(i, 1);\n            }\n            return 1;\n          }\n          return 1;\n        });\n      }\n\n      // Tag postfix conditionals as such, so that we can parse them with a\n      // different precedence.\n      tagPostfixConditionals() {\n        var action, condition, original;\n        original = null;\n        condition = function(token, i) {\n          var prevTag, tag;\n          [tag] = token;\n          [prevTag] = this.tokens[i - 1];\n          return tag === 'TERMINATOR' || (tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0);\n        };\n        action = function(token, i) {\n          if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {\n            return original[0] = 'POST_' + original[0];\n          }\n        };\n        return this.scanTokens(function(token, i) {\n          if (token[0] !== 'IF') {\n            return 1;\n          }\n          original = token;\n          this.detectEnd(i + 1, condition, action);\n          return 1;\n        });\n      }\n\n      // Generate the indentation tokens, based on another token on the same line.\n      indentation(origin) {\n        var indent, outdent;\n        indent = ['INDENT', 2];\n        outdent = ['OUTDENT', 2];\n        if (origin) {\n          indent.generated = outdent.generated = true;\n          indent.origin = outdent.origin = origin;\n        } else {\n          indent.explicit = outdent.explicit = true;\n        }\n        return [indent, outdent];\n      }\n\n      // Look up a tag by token index.\n      tag(i) {\n        var ref;\n        return (ref = this.tokens[i]) != null ? ref[0] : void 0;\n      }\n\n    };\n\n    Rewriter.prototype.generate = generate;\n\n    return Rewriter;\n\n  }).call(this);\n\n  // Constants\n  // ---------\n\n  // List of the token pairs that must be balanced.\n  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];\n\n  // The inverse mappings of `BALANCED_PAIRS` weâre trying to fix up, so we can\n  // look things up from either end.\n  exports.INVERSES = INVERSES = {};\n\n  // The tokens that signal the start/end of a balanced pair.\n  EXPRESSION_START = [];\n\n  EXPRESSION_END = [];\n\n  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {\n    [left, right] = BALANCED_PAIRS[k];\n    EXPRESSION_START.push(INVERSES[right] = left);\n    EXPRESSION_END.push(INVERSES[left] = right);\n  }\n\n  // Tokens that indicate the close of a clause of an expression.\n  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);\n\n  // Tokens that, if followed by an `IMPLICIT_CALL`, indicate a function invocation.\n  IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];\n\n  // If preceded by an `IMPLICIT_FUNC`, indicates a function invocation.\n  IMPLICIT_CALL = ['IDENTIFIER', 'CSX_TAG', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'YIELD', 'AWAIT', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];\n\n  IMPLICIT_UNSPACED_CALL = ['+', '-'];\n\n  // Tokens that always mark the end of an implicit call for single-liners.\n  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];\n\n  // Single-line flavors of block expressions that have unclosed endings.\n  // The grammar canât disambiguate them, so we insert the implicit indentation.\n  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];\n\n  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];\n\n  // Tokens that end a line.\n  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];\n\n  // Tokens that close open calls when they follow a newline.\n  CALL_CLOSERS = ['.', '?.', '::', '?::'];\n\n  // Tokens that prevent a subsequent indent from ending implicit calls/objects\n  CONTROL_IN_IMPLICIT = ['IF', 'TRY', 'FINALLY', 'CATCH', 'CLASS', 'SWITCH'];\n\n  // Tokens that are swallowed up by the parser, never leading to code generation.\n  // You can spot these in `grammar.coffee` because the `o` function second\n  // argument doesnât contain a `new` call for these tokens.\n  // `STRING_START` isnât on this list because its `locationData` matches that of\n  // the node that becomes `StringWithInterpolations`, and therefore\n  // `addDataToNode` attaches `STRING_START`âs tokens to that node.\n  DISCARDED = ['(', ')', '[', ']', '{', '}', '.', '..', '...', ',', '=', '++', '--', '?', 'AS', 'AWAIT', 'CALL_START', 'CALL_END', 'DEFAULT', 'ELSE', 'EXTENDS', 'EXPORT', 'FORIN', 'FOROF', 'FORFROM', 'IMPORT', 'INDENT', 'INDEX_SOAK', 'LEADING_WHEN', 'OUTDENT', 'PARAM_END', 'REGEX_START', 'REGEX_END', 'RETURN', 'STRING_END', 'THROW', 'UNARY', 'YIELD'].concat(IMPLICIT_UNSPACED_CALL.concat(IMPLICIT_END.concat(CALL_CLOSERS.concat(CONTROL_IN_IMPLICIT))));\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.265Z",
		"atimeMs": 1551857503265,
		"isfile": true
	},
	"filename": "lib/coffeescript/scope.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // The **Scope** class regulates lexical scoping within CoffeeScript. As you\n  // generate code, you create a tree of scopes in the same shape as the nested\n  // function bodies. Each scope knows about the variables declared within it,\n  // and has a reference to its parent enclosing scope. In this way, we know which\n  // variables are new and need to be declared with `var`, and which are shared\n  // with external scopes.\n  var Scope,\n    indexOf = [].indexOf;\n\n  exports.Scope = Scope = class Scope {\n    // Initialize a scope with its parent, for lookups up the chain,\n    // as well as a reference to the **Block** node it belongs to, which is\n    // where it should declare its variables, a reference to the function that\n    // it belongs to, and a list of variables referenced in the source code\n    // and therefore should be avoided when generating variables. Also track comments\n    // that should be output as part of variable declarations.\n    constructor(parent, expressions, method, referencedVars) {\n      var ref, ref1;\n      this.parent = parent;\n      this.expressions = expressions;\n      this.method = method;\n      this.referencedVars = referencedVars;\n      this.variables = [\n        {\n          name: 'arguments',\n          type: 'arguments'\n        }\n      ];\n      this.comments = {};\n      this.positions = {};\n      if (!this.parent) {\n        this.utilities = {};\n      }\n      // The `@root` is the top-level **Scope** object for a given file.\n      this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;\n    }\n\n    // Adds a new variable or overrides an existing one.\n    add(name, type, immediate) {\n      if (this.shared && !immediate) {\n        return this.parent.add(name, type, immediate);\n      }\n      if (Object.prototype.hasOwnProperty.call(this.positions, name)) {\n        return this.variables[this.positions[name]].type = type;\n      } else {\n        return this.positions[name] = this.variables.push({name, type}) - 1;\n      }\n    }\n\n    // When `super` is called, we need to find the name of the current method we're\n    // in, so that we know how to invoke the same method of the parent class. This\n    // can get complicated if super is being called from an inner function.\n    // `namedMethod` will walk up the scope tree until it either finds the first\n    // function object that has a name filled in, or bottoms out.\n    namedMethod() {\n      var ref;\n      if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {\n        return this.method;\n      }\n      return this.parent.namedMethod();\n    }\n\n    // Look up a variable name in lexical scope, and declare it if it does not\n    // already exist.\n    find(name, type = 'var') {\n      if (this.check(name)) {\n        return true;\n      }\n      this.add(name, type);\n      return false;\n    }\n\n    // Reserve a variable name as originating from a function parameter for this\n    // scope. No `var` required for internal references.\n    parameter(name) {\n      if (this.shared && this.parent.check(name, true)) {\n        return;\n      }\n      return this.add(name, 'param');\n    }\n\n    // Just check to see if a variable has already been declared, without reserving,\n    // walks up to the root scope.\n    check(name) {\n      var ref;\n      return !!(this.type(name) || ((ref = this.parent) != null ? ref.check(name) : void 0));\n    }\n\n    // Generate a temporary variable name at the given index.\n    temporary(name, index, single = false) {\n      var diff, endCode, letter, newCode, num, startCode;\n      if (single) {\n        startCode = name.charCodeAt(0);\n        endCode = 'z'.charCodeAt(0);\n        diff = endCode - startCode;\n        newCode = startCode + index % (diff + 1);\n        letter = String.fromCharCode(newCode);\n        num = Math.floor(index / (diff + 1));\n        return `${letter}${num || ''}`;\n      } else {\n        return `${name}${index || ''}`;\n      }\n    }\n\n    // Gets the type of a variable.\n    type(name) {\n      var i, len, ref, v;\n      ref = this.variables;\n      for (i = 0, len = ref.length; i < len; i++) {\n        v = ref[i];\n        if (v.name === name) {\n          return v.type;\n        }\n      }\n      return null;\n    }\n\n    // If we need to store an intermediate result, find an available name for a\n    // compiler-generated variable. `_var`, `_var2`, and so on...\n    freeVariable(name, options = {}) {\n      var index, ref, temp;\n      index = 0;\n      while (true) {\n        temp = this.temporary(name, index, options.single);\n        if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {\n          break;\n        }\n        index++;\n      }\n      if ((ref = options.reserve) != null ? ref : true) {\n        this.add(temp, 'var', true);\n      }\n      return temp;\n    }\n\n    // Ensure that an assignment is made at the top of this scope\n    // (or at the top-level scope, if requested).\n    assign(name, value) {\n      this.add(name, {\n        value,\n        assigned: true\n      }, true);\n      return this.hasAssignments = true;\n    }\n\n    // Does this scope have any declared variables?\n    hasDeclarations() {\n      return !!this.declaredVariables().length;\n    }\n\n    // Return the list of variables first declared in this scope.\n    declaredVariables() {\n      var v;\n      return ((function() {\n        var i, len, ref, results;\n        ref = this.variables;\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          v = ref[i];\n          if (v.type === 'var') {\n            results.push(v.name);\n          }\n        }\n        return results;\n      }).call(this)).sort();\n    }\n\n    // Return the list of assignments that are supposed to be made at the top\n    // of this scope.\n    assignedVariables() {\n      var i, len, ref, results, v;\n      ref = this.variables;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        v = ref[i];\n        if (v.type.assigned) {\n          results.push(`${v.name} = ${v.type.value}`);\n        }\n      }\n      return results;\n    }\n\n  };\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.265Z",
		"atimeMs": 1551857503265,
		"isfile": true
	},
	"filename": "lib/coffeescript/sourcemap.js",
	"content": "// Generated by CoffeeScript 2.3.2\n(function() {\n  // Source maps allow JavaScript runtimes to match running JavaScript back to\n  // the original source code that corresponds to it. This can be minified\n  // JavaScript, but in our case, we're concerned with mapping pretty-printed\n  // JavaScript back to CoffeeScript.\n\n  // In order to produce maps, we must keep track of positions (line number, column number)\n  // that originated every node in the syntax tree, and be able to generate a\n  // [map file](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit)\n  // â which is a compact, VLQ-encoded representation of the JSON serialization\n  // of this information â to write out alongside the generated JavaScript.\n\n  // LineMap\n  // -------\n\n  // A **LineMap** object keeps track of information about original line and column\n  // positions for a single line of output JavaScript code.\n  // **SourceMaps** are implemented in terms of **LineMaps**.\n  var LineMap, SourceMap;\n\n  LineMap = class LineMap {\n    constructor(line1) {\n      this.line = line1;\n      this.columns = [];\n    }\n\n    add(column, [sourceLine, sourceColumn], options = {}) {\n      if (this.columns[column] && options.noReplace) {\n        return;\n      }\n      return this.columns[column] = {\n        line: this.line,\n        column,\n        sourceLine,\n        sourceColumn\n      };\n    }\n\n    sourceLocation(column) {\n      var mapping;\n      while (!((mapping = this.columns[column]) || (column <= 0))) {\n        column--;\n      }\n      return mapping && [mapping.sourceLine, mapping.sourceColumn];\n    }\n\n  };\n\n  SourceMap = (function() {\n    var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;\n\n    // SourceMap\n    // ---------\n\n    // Maps locations in a single generated JavaScript file back to locations in\n    // the original CoffeeScript source file.\n\n    // This is intentionally agnostic towards how a source map might be represented on\n    // disk. Once the compiler is ready to produce a \"v3\"-style source map, we can walk\n    // through the arrays of line and column buffer to produce it.\n    class SourceMap {\n      constructor() {\n        this.lines = [];\n      }\n\n      // Adds a mapping to this SourceMap. `sourceLocation` and `generatedLocation`\n      // are both `[line, column]` arrays. If `options.noReplace` is true, then if there\n      // is already a mapping for the specified `line` and `column`, this will have no\n      // effect.\n      add(sourceLocation, generatedLocation, options = {}) {\n        var base, column, line, lineMap;\n        [line, column] = generatedLocation;\n        lineMap = ((base = this.lines)[line] || (base[line] = new LineMap(line)));\n        return lineMap.add(column, sourceLocation, options);\n      }\n\n      // Look up the original position of a given `line` and `column` in the generated\n      // code.\n      sourceLocation([line, column]) {\n        var lineMap;\n        while (!((lineMap = this.lines[line]) || (line <= 0))) {\n          line--;\n        }\n        return lineMap && lineMap.sourceLocation(column);\n      }\n\n      // V3 SourceMap Generation\n      // -----------------------\n\n      // Builds up a V3 source map, returning the generated JSON as a string.\n      // `options.sourceRoot` may be used to specify the sourceRoot written to the source\n      // map.  Also, `options.sourceFiles` and `options.generatedFile` may be passed to\n      // set \"sources\" and \"file\", respectively.\n      generate(options = {}, code = null) {\n        var buffer, i, j, lastColumn, lastSourceColumn, lastSourceLine, len, len1, lineMap, lineNumber, mapping, needComma, ref, ref1, sources, v3, writingline;\n        writingline = 0;\n        lastColumn = 0;\n        lastSourceLine = 0;\n        lastSourceColumn = 0;\n        needComma = false;\n        buffer = \"\";\n        ref = this.lines;\n        for (lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i) {\n          lineMap = ref[lineNumber];\n          if (lineMap) {\n            ref1 = lineMap.columns;\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              mapping = ref1[j];\n              if (!(mapping)) {\n                continue;\n              }\n              while (writingline < mapping.line) {\n                lastColumn = 0;\n                needComma = false;\n                buffer += \";\";\n                writingline++;\n              }\n              // Write a comma if we've already written a segment on this line.\n              if (needComma) {\n                buffer += \",\";\n                needComma = false;\n              }\n              // Write the next segment. Segments can be 1, 4, or 5 values.  If just one, then it\n              // is a generated column which doesn't match anything in the source code.\n\n              // The starting column in the generated source, relative to any previous recorded\n              // column for the current line:\n              buffer += this.encodeVlq(mapping.column - lastColumn);\n              lastColumn = mapping.column;\n              // The index into the list of sources:\n              buffer += this.encodeVlq(0);\n              // The starting line in the original source, relative to the previous source line.\n              buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);\n              lastSourceLine = mapping.sourceLine;\n              // The starting column in the original source, relative to the previous column.\n              buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);\n              lastSourceColumn = mapping.sourceColumn;\n              needComma = true;\n            }\n          }\n        }\n        // Produce the canonical JSON object format for a \"v3\" source map.\n        sources = options.sourceFiles ? options.sourceFiles : options.filename ? [options.filename] : ['<anonymous>'];\n        v3 = {\n          version: 3,\n          file: options.generatedFile || '',\n          sourceRoot: options.sourceRoot || '',\n          sources: sources,\n          names: [],\n          mappings: buffer\n        };\n        if (options.sourceMap || options.inlineMap) {\n          v3.sourcesContent = [code];\n        }\n        return v3;\n      }\n\n      encodeVlq(value) {\n        var answer, nextChunk, signBit, valueToEncode;\n        answer = '';\n        // Least significant bit represents the sign.\n        signBit = value < 0 ? 1 : 0;\n        // The next bits are the actual value.\n        valueToEncode = (Math.abs(value) << 1) + signBit;\n        // Make sure we encode at least one character, even if valueToEncode is 0.\n        while (valueToEncode || !answer) {\n          nextChunk = valueToEncode & VLQ_VALUE_MASK;\n          valueToEncode = valueToEncode >> VLQ_SHIFT;\n          if (valueToEncode) {\n            nextChunk |= VLQ_CONTINUATION_BIT;\n          }\n          answer += this.encodeBase64(nextChunk);\n        }\n        return answer;\n      }\n\n      encodeBase64(value) {\n        return BASE64_CHARS[value] || (function() {\n          throw new Error(`Cannot Base64 encode value: ${value}`);\n        })();\n      }\n\n    };\n\n    // Base64 VLQ Encoding\n    // -------------------\n\n    // Note that SourceMap VLQ encoding is \"backwards\".  MIDI-style VLQ encoding puts\n    // the most-significant-bit (MSB) from the original value into the MSB of the VLQ\n    // encoded value (see [Wikipedia](https://en.wikipedia.org/wiki/File:Uintvar_coding.svg)).\n    // SourceMap VLQ does things the other way around, with the least significat four\n    // bits of the original value encoded into the first byte of the VLQ encoded value.\n    VLQ_SHIFT = 5;\n\n    VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT; // 0010 0000\n\n    VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1; // 0001 1111\n\n    // Regular Base64 Encoding\n    // -----------------------\n    BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    return SourceMap;\n\n  }).call(this);\n\n  // Our API for source maps is just the `SourceMap` class.\n  module.exports = SourceMap;\n\n}).call(this);\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){return {
	"stat": {
		"mtime": "2019-03-06T07:31:43.268Z",
		"mtimeMs": 1551857503267.6765,
		"atime": "2019-03-06T07:31:43.296Z",
		"atimeMs": 1551857503295.677,
		"isdirectory": true
	},
	"filename": "node_modules"
}})
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.256Z",
		"atimeMs": 1551857503256,
		"isfile": true
	},
	"filename": "package.json",
	"content": "{\n  \"name\": \"coffeescript\",\n  \"description\": \"Unfancy JavaScript\",\n  \"keywords\": [\n    \"javascript\",\n    \"language\",\n    \"coffeescript\",\n    \"compiler\"\n  ],\n  \"author\": \"Jeremy Ashkenas\",\n  \"version\": \"2.3.2\",\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=6\"\n  },\n  \"directories\": {\n    \"lib\": \"./lib/coffeescript\"\n  },\n  \"main\": \"./lib/coffeescript/index\",\n  \"browser\": \"./lib/coffeescript/browser\",\n  \"bin\": {\n    \"coffee\": \"./bin/coffee\",\n    \"cake\": \"./bin/cake\"\n  },\n  \"files\": [\n    \"bin\",\n    \"lib\",\n    \"register.js\",\n    \"repl.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"node ./bin/cake test\",\n    \"test-harmony\": \"node --harmony ./bin/cake test\"\n  },\n  \"homepage\": \"https://coffeescript.org\",\n  \"bugs\": \"https://github.com/jashkenas/coffeescript/issues\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/jashkenas/coffeescript.git\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.0.0\",\n    \"@babel/preset-env\": \"^7.0.0\",\n    \"babel-preset-minify\": \"^0.4.3\",\n    \"codemirror\": \"^5.39.2\",\n    \"docco\": \"~0.8.0\",\n    \"highlight.js\": \"~9.12.0\",\n    \"jison\": \">=0.4.18\",\n    \"markdown-it\": \"~8.4.2\",\n    \"underscore\": \"~1.9.1\",\n    \"webpack\": \"~4.17.2\"\n  },\n  \"dependencies\": {}\n}\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.257Z",
		"atimeMs": 1551857503257,
		"isfile": true
	},
	"filename": "register.js",
	"content": "require('./lib/coffeescript/register');\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	fileData.push(function(){ var item= {
	"stat": {
		"mtime": "1985-10-26T08:15:00.000Z",
		"mtimeMs": 499162500000,
		"atime": "2019-03-06T07:31:43.258Z",
		"atimeMs": 1551857503258,
		"isfile": true
	},
	"filename": "repl.js",
	"content": "module.exports = require('./lib/coffeescript/repl');\n",
	"transpiled": true
}; item.content= Buffer.from(item.content,'binary'); return item; })
	var filenames={
	"": 0,
	"README.md": 1,
	"lib": 2,
	"lib/coffeescript": 3,
	"lib/coffeescript/browser.js": 4,
	"lib/coffeescript/cake.js": 5,
	"lib/coffeescript/coffeescript.js": 6,
	"lib/coffeescript/command.js": 7,
	"lib/coffeescript/grammar.js": 8,
	"lib/coffeescript/helpers.js": 9,
	"lib/coffeescript/index.js": 10,
	"lib/coffeescript/lexer.js": 11,
	"lib/coffeescript/nodes.js": 12,
	"lib/coffeescript/optparse.js": 13,
	"lib/coffeescript/parser.js": 14,
	"lib/coffeescript/register.js": 15,
	"lib/coffeescript/repl.js": 16,
	"lib/coffeescript/rewriter.js": 17,
	"lib/coffeescript/scope.js": 18,
	"lib/coffeescript/sourcemap.js": 19,
	"node_modules": 20,
	"package.json": 21,
	"register.js": 22,
	"repl.js": 23
}
        var mod1= function(KModule, exports){
            var i=0, main, pe, filecount, pjson
            for(var id in filenames){
                if(typeof module == "object"){
                    
                    if(id == "package.json"){
                        pjson= fileData[i]()
                        pjson= JSON.parse(pjson.content)
                    }
                                 
                }
                KModule.addVirtualFile("coffeescript$v$2.3.2" + (id ? ("/"+id) : ""), fileData[i])
                i++
            }
            if(pjson){
                main= pjson.main
                if(!main){
                    main= "index.js"
                }
                if(main.substring(0,2)=="./"){
                    main= main.substring(2)
                }
                main= "coffeescript$v$2.3.2" + (main ? ("/" + main) : "")
            }
            if(main){
                return KModule.import("/virtual/" + main)
            }
            if(typeof module == "object"){
                return exports 
            }
            return {}
        }
        /*
        if(typeof module == "object"){
            module.exports.__kawi= mod1
        }*/

        if(typeof window == "object"){
            if(window.KModuleLoader){
                module.exports= mod1(window.KModuleLoader, module.exports)
            }
        }
        if(typeof KModule == "object"){
            module.exports= mod1(KModule, module.exports)
        }
        return mod1
        
})()
// kawi converted. Preserve this line, Kawi transpiler will not reprocess if this line found